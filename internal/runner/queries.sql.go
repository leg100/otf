// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package runner

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/leg100/otf/internal/resource"
)

const deleteAgentPool = `-- name: DeleteAgentPool :one
DELETE
FROM agent_pools
WHERE agent_pool_id = $1
RETURNING agent_pool_id, name, created_at, organization_name, organization_scoped
`

func (q *Queries) DeleteAgentPool(ctx context.Context, db DBTX, poolID resource.ID) (AgentPool, error) {
	row := db.QueryRow(ctx, deleteAgentPool, poolID)
	var i AgentPool
	err := row.Scan(
		&i.AgentPoolID,
		&i.Name,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.OrganizationScoped,
	)
	return i, err
}

const deleteAgentPoolAllowedWorkspace = `-- name: DeleteAgentPoolAllowedWorkspace :exec
DELETE
FROM agent_pool_allowed_workspaces
WHERE agent_pool_id = $1
AND workspace_id = $2
`

type DeleteAgentPoolAllowedWorkspaceParams struct {
	PoolID      resource.ID
	WorkspaceID resource.ID
}

func (q *Queries) DeleteAgentPoolAllowedWorkspace(ctx context.Context, db DBTX, arg DeleteAgentPoolAllowedWorkspaceParams) error {
	_, err := db.Exec(ctx, deleteAgentPoolAllowedWorkspace, arg.PoolID, arg.WorkspaceID)
	return err
}

const deleteAgentTokenByID = `-- name: DeleteAgentTokenByID :one
DELETE
FROM agent_tokens
WHERE agent_token_id = $1
RETURNING agent_token_id
`

func (q *Queries) DeleteAgentTokenByID(ctx context.Context, db DBTX, agentTokenID resource.ID) (resource.ID, error) {
	row := db.QueryRow(ctx, deleteAgentTokenByID, agentTokenID)
	var agent_token_id resource.ID
	err := row.Scan(&agent_token_id)
	return agent_token_id, err
}

const deleteRunner = `-- name: DeleteRunner :one
DELETE
FROM runners
WHERE runner_id = $1
RETURNING runner_id, name, version, max_jobs, ip_address, last_ping_at, last_status_at, status, agent_pool_id
`

func (q *Queries) DeleteRunner(ctx context.Context, db DBTX, runnerID resource.ID) (RunnerModel, error) {
	row := db.QueryRow(ctx, deleteRunner, runnerID)
	var i RunnerModel
	err := row.Scan(
		&i.RunnerID,
		&i.Name,
		&i.Version,
		&i.MaxJobs,
		&i.IPAddress,
		&i.LastPingAt,
		&i.LastStatusAt,
		&i.Status,
		&i.AgentPoolID,
	)
	return i, err
}

const findAgentPool = `-- name: FindAgentPool :one
SELECT ap.agent_pool_id, ap.name, ap.created_at, ap.organization_name, ap.organization_scoped,
    (
        SELECT array_agg(w.workspace_id)::text[]
        FROM workspaces w
        WHERE w.agent_pool_id = ap.agent_pool_id
    ) AS workspace_ids,
    (
        SELECT array_agg(aw.workspace_id)::text[]
        FROM agent_pool_allowed_workspaces aw
        WHERE aw.agent_pool_id = ap.agent_pool_id
    ) AS allowed_workspace_ids
FROM agent_pools ap
WHERE ap.agent_pool_id = $1
GROUP BY ap.agent_pool_id
`

type FindAgentPoolRow struct {
	AgentPoolID         resource.ID
	Name                pgtype.Text
	CreatedAt           pgtype.Timestamptz
	OrganizationName    resource.OrganizationName
	OrganizationScoped  pgtype.Bool
	WorkspaceIds        []pgtype.Text
	AllowedWorkspaceIds []pgtype.Text
}

func (q *Queries) FindAgentPool(ctx context.Context, db DBTX, poolID resource.ID) (FindAgentPoolRow, error) {
	row := db.QueryRow(ctx, findAgentPool, poolID)
	var i FindAgentPoolRow
	err := row.Scan(
		&i.AgentPoolID,
		&i.Name,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.OrganizationScoped,
		&i.WorkspaceIds,
		&i.AllowedWorkspaceIds,
	)
	return i, err
}

const findAgentPoolByAgentTokenID = `-- name: FindAgentPoolByAgentTokenID :one
SELECT ap.agent_pool_id, ap.name, ap.created_at, ap.organization_name, ap.organization_scoped,
    (
        SELECT array_agg(w.workspace_id)::text[]
        FROM workspaces w
        WHERE w.agent_pool_id = ap.agent_pool_id
    ) AS workspace_ids,
    (
        SELECT array_agg(aw.workspace_id)::text[]
        FROM agent_pool_allowed_workspaces aw
        WHERE aw.agent_pool_id = ap.agent_pool_id
    ) AS allowed_workspace_ids
FROM agent_pools ap
JOIN agent_tokens at USING (agent_pool_id)
WHERE at.agent_token_id = $1
GROUP BY ap.agent_pool_id
`

type FindAgentPoolByAgentTokenIDRow struct {
	AgentPoolID         resource.ID
	Name                pgtype.Text
	CreatedAt           pgtype.Timestamptz
	OrganizationName    resource.OrganizationName
	OrganizationScoped  pgtype.Bool
	WorkspaceIds        []pgtype.Text
	AllowedWorkspaceIds []pgtype.Text
}

func (q *Queries) FindAgentPoolByAgentTokenID(ctx context.Context, db DBTX, agentTokenID resource.ID) (FindAgentPoolByAgentTokenIDRow, error) {
	row := db.QueryRow(ctx, findAgentPoolByAgentTokenID, agentTokenID)
	var i FindAgentPoolByAgentTokenIDRow
	err := row.Scan(
		&i.AgentPoolID,
		&i.Name,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.OrganizationScoped,
		&i.WorkspaceIds,
		&i.AllowedWorkspaceIds,
	)
	return i, err
}

const findAgentPools = `-- name: FindAgentPools :many
SELECT ap.agent_pool_id, ap.name, ap.created_at, ap.organization_name, ap.organization_scoped,
    (
        SELECT array_agg(w.workspace_id)::text[]
        FROM workspaces w
        WHERE w.agent_pool_id = ap.agent_pool_id
    ) AS workspace_ids,
    (
        SELECT array_agg(aw.workspace_id)::text[]
        FROM agent_pool_allowed_workspaces aw
        WHERE aw.agent_pool_id = ap.agent_pool_id
    ) AS allowed_workspace_ids
FROM agent_pools ap
ORDER BY ap.created_at DESC
`

type FindAgentPoolsRow struct {
	AgentPoolID         resource.ID
	Name                pgtype.Text
	CreatedAt           pgtype.Timestamptz
	OrganizationName    resource.OrganizationName
	OrganizationScoped  pgtype.Bool
	WorkspaceIds        []pgtype.Text
	AllowedWorkspaceIds []pgtype.Text
}

func (q *Queries) FindAgentPools(ctx context.Context, db DBTX) ([]FindAgentPoolsRow, error) {
	rows, err := db.Query(ctx, findAgentPools)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAgentPoolsRow
	for rows.Next() {
		var i FindAgentPoolsRow
		if err := rows.Scan(
			&i.AgentPoolID,
			&i.Name,
			&i.CreatedAt,
			&i.OrganizationName,
			&i.OrganizationScoped,
			&i.WorkspaceIds,
			&i.AllowedWorkspaceIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAgentPoolsByOrganization = `-- name: FindAgentPoolsByOrganization :many
SELECT ap.agent_pool_id, ap.name, ap.created_at, ap.organization_name, ap.organization_scoped,
    (
        SELECT array_agg(w.workspace_id)::text[]
        FROM workspaces w
        WHERE w.agent_pool_id = ap.agent_pool_id
    ) AS workspace_ids,
    (
        SELECT array_agg(aw.workspace_id)::text[]
        FROM agent_pool_allowed_workspaces aw
        WHERE aw.agent_pool_id = ap.agent_pool_id
    ) AS allowed_workspace_ids
FROM agent_pools ap
LEFT JOIN (agent_pool_allowed_workspaces aw JOIN workspaces w USING (workspace_id)) ON ap.agent_pool_id = aw.agent_pool_id
WHERE ap.organization_name = $1
AND   (($2::text IS NULL) OR ap.name LIKE '%' || $2 || '%')
AND   (($3::text IS NULL) OR
       ap.organization_scoped OR
       w.name = $3
      )
AND   (($4::text IS NULL) OR
       ap.organization_scoped OR
       w.workspace_id = $4
      )
GROUP BY ap.agent_pool_id
ORDER BY ap.created_at DESC
`

type FindAgentPoolsByOrganizationParams struct {
	OrganizationName     resource.OrganizationName
	NameSubstring        pgtype.Text
	AllowedWorkspaceName pgtype.Text
	AllowedWorkspaceID   pgtype.Text
}

type FindAgentPoolsByOrganizationRow struct {
	AgentPoolID         resource.ID
	Name                pgtype.Text
	CreatedAt           pgtype.Timestamptz
	OrganizationName    resource.OrganizationName
	OrganizationScoped  pgtype.Bool
	WorkspaceIds        []pgtype.Text
	AllowedWorkspaceIds []pgtype.Text
}

// Find agent pools in an organization, optionally filtering by any combination of:
// (a) name_substring: pool name contains substring
// (b) allowed_workspace_name: workspace with name is allowed to use pool
// (c) allowed_workspace_id: workspace with ID is allowed to use pool
func (q *Queries) FindAgentPoolsByOrganization(ctx context.Context, db DBTX, arg FindAgentPoolsByOrganizationParams) ([]FindAgentPoolsByOrganizationRow, error) {
	rows, err := db.Query(ctx, findAgentPoolsByOrganization,
		arg.OrganizationName,
		arg.NameSubstring,
		arg.AllowedWorkspaceName,
		arg.AllowedWorkspaceID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAgentPoolsByOrganizationRow
	for rows.Next() {
		var i FindAgentPoolsByOrganizationRow
		if err := rows.Scan(
			&i.AgentPoolID,
			&i.Name,
			&i.CreatedAt,
			&i.OrganizationName,
			&i.OrganizationScoped,
			&i.WorkspaceIds,
			&i.AllowedWorkspaceIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAgentTokenByID = `-- name: FindAgentTokenByID :one
SELECT agent_token_id, created_at, description, agent_pool_id
FROM agent_tokens
WHERE agent_token_id = $1
`

func (q *Queries) FindAgentTokenByID(ctx context.Context, db DBTX, agentTokenID resource.ID) (AgentToken, error) {
	row := db.QueryRow(ctx, findAgentTokenByID, agentTokenID)
	var i AgentToken
	err := row.Scan(
		&i.AgentTokenID,
		&i.CreatedAt,
		&i.Description,
		&i.AgentPoolID,
	)
	return i, err
}

const findAgentTokensByAgentPoolID = `-- name: FindAgentTokensByAgentPoolID :many
SELECT agent_token_id, created_at, description, agent_pool_id
FROM agent_tokens
WHERE agent_pool_id = $1
ORDER BY created_at DESC
`

func (q *Queries) FindAgentTokensByAgentPoolID(ctx context.Context, db DBTX, agentPoolID resource.ID) ([]AgentToken, error) {
	rows, err := db.Query(ctx, findAgentTokensByAgentPoolID, agentPoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AgentToken
	for rows.Next() {
		var i AgentToken
		if err := rows.Scan(
			&i.AgentTokenID,
			&i.CreatedAt,
			&i.Description,
			&i.AgentPoolID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAllocatedJobs = `-- name: FindAllocatedJobs :many
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.runner_id = $1
AND   j.status = 'allocated'
`

type FindAllocatedJobsRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName resource.OrganizationName
}

func (q *Queries) FindAllocatedJobs(ctx context.Context, db DBTX, runnerID *resource.ID) ([]FindAllocatedJobsRow, error) {
	rows, err := db.Query(ctx, findAllocatedJobs, runnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllocatedJobsRow
	for rows.Next() {
		var i FindAllocatedJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.RunID,
			&i.Phase,
			&i.Status,
			&i.Signaled,
			&i.RunnerID,
			&i.AgentPoolID,
			&i.WorkspaceID,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAndUpdateSignaledJobs = `-- name: FindAndUpdateSignaledJobs :many
UPDATE jobs AS j
SET signaled = NULL
FROM runs r, workspaces w
WHERE j.run_id = r.run_id
AND   r.workspace_id = w.workspace_id
AND   j.runner_id = $1
AND   j.status = 'running'
AND   j.signaled IS NOT NULL
RETURNING
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
`

type FindAndUpdateSignaledJobsRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName resource.OrganizationName
}

// Find signaled jobs and then immediately update signal with null.
func (q *Queries) FindAndUpdateSignaledJobs(ctx context.Context, db DBTX, runnerID *resource.ID) ([]FindAndUpdateSignaledJobsRow, error) {
	rows, err := db.Query(ctx, findAndUpdateSignaledJobs, runnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAndUpdateSignaledJobsRow
	for rows.Next() {
		var i FindAndUpdateSignaledJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.RunID,
			&i.Phase,
			&i.Status,
			&i.Signaled,
			&i.RunnerID,
			&i.AgentPoolID,
			&i.WorkspaceID,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findJob = `-- name: FindJob :one
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.job_id = $1
`

type FindJobRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName resource.OrganizationName
}

func (q *Queries) FindJob(ctx context.Context, db DBTX, jobID resource.ID) (FindJobRow, error) {
	row := db.QueryRow(ctx, findJob, jobID)
	var i FindJobRow
	err := row.Scan(
		&i.JobID,
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.Signaled,
		&i.RunnerID,
		&i.AgentPoolID,
		&i.WorkspaceID,
		&i.OrganizationName,
	)
	return i, err
}

const findJobForUpdate = `-- name: FindJobForUpdate :one
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.job_id = $1
FOR UPDATE OF j
`

type FindJobForUpdateRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName resource.OrganizationName
}

func (q *Queries) FindJobForUpdate(ctx context.Context, db DBTX, jobID resource.ID) (FindJobForUpdateRow, error) {
	row := db.QueryRow(ctx, findJobForUpdate, jobID)
	var i FindJobForUpdateRow
	err := row.Scan(
		&i.JobID,
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.Signaled,
		&i.RunnerID,
		&i.AgentPoolID,
		&i.WorkspaceID,
		&i.OrganizationName,
	)
	return i, err
}

const findJobs = `-- name: FindJobs :many
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
`

type FindJobsRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName resource.OrganizationName
}

func (q *Queries) FindJobs(ctx context.Context, db DBTX) ([]FindJobsRow, error) {
	rows, err := db.Query(ctx, findJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindJobsRow
	for rows.Next() {
		var i FindJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.RunID,
			&i.Phase,
			&i.Status,
			&i.Signaled,
			&i.RunnerID,
			&i.AgentPoolID,
			&i.WorkspaceID,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRunnerByID = `-- name: FindRunnerByID :one
SELECT
    a.runner_id, a.name, a.version, a.max_jobs, a.ip_address, a.last_ping_at, a.last_status_at, a.status, a.agent_pool_id,
    ap::"agent_pools" AS agent_pool,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.runner_id = j.runner_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM runners a
LEFT JOIN agent_pools ap USING (agent_pool_id)
LEFT JOIN jobs j USING (runner_id)
WHERE a.runner_id = $1
`

type FindRunnerByIDRow struct {
	RunnerID     resource.ID
	Name         pgtype.Text
	Version      pgtype.Text
	MaxJobs      pgtype.Int4
	IPAddress    netip.Addr
	LastPingAt   pgtype.Timestamptz
	LastStatusAt pgtype.Timestamptz
	Status       pgtype.Text
	AgentPoolID  *resource.ID
	AgentPool    *AgentPool
	CurrentJobs  int64
}

func (q *Queries) FindRunnerByID(ctx context.Context, db DBTX, runnerID resource.ID) (FindRunnerByIDRow, error) {
	row := db.QueryRow(ctx, findRunnerByID, runnerID)
	var i FindRunnerByIDRow
	err := row.Scan(
		&i.RunnerID,
		&i.Name,
		&i.Version,
		&i.MaxJobs,
		&i.IPAddress,
		&i.LastPingAt,
		&i.LastStatusAt,
		&i.Status,
		&i.AgentPoolID,
		&i.AgentPool,
		&i.CurrentJobs,
	)
	return i, err
}

const findRunnerByIDForUpdate = `-- name: FindRunnerByIDForUpdate :one
SELECT
    a.runner_id, a.name, a.version, a.max_jobs, a.ip_address, a.last_ping_at, a.last_status_at, a.status, a.agent_pool_id,
    ap::"agent_pools" AS agent_pool,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.runner_id = j.runner_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM runners a
LEFT JOIN agent_pools ap USING (agent_pool_id)
WHERE a.runner_id = $1
FOR UPDATE OF a
`

type FindRunnerByIDForUpdateRow struct {
	RunnerID     resource.ID
	Name         pgtype.Text
	Version      pgtype.Text
	MaxJobs      pgtype.Int4
	IPAddress    netip.Addr
	LastPingAt   pgtype.Timestamptz
	LastStatusAt pgtype.Timestamptz
	Status       pgtype.Text
	AgentPoolID  *resource.ID
	AgentPool    *AgentPool
	CurrentJobs  int64
}

func (q *Queries) FindRunnerByIDForUpdate(ctx context.Context, db DBTX, runnerID resource.ID) (FindRunnerByIDForUpdateRow, error) {
	row := db.QueryRow(ctx, findRunnerByIDForUpdate, runnerID)
	var i FindRunnerByIDForUpdateRow
	err := row.Scan(
		&i.RunnerID,
		&i.Name,
		&i.Version,
		&i.MaxJobs,
		&i.IPAddress,
		&i.LastPingAt,
		&i.LastStatusAt,
		&i.Status,
		&i.AgentPoolID,
		&i.AgentPool,
		&i.CurrentJobs,
	)
	return i, err
}

const findRunners = `-- name: FindRunners :many
SELECT
    a.runner_id, a.name, a.version, a.max_jobs, a.ip_address, a.last_ping_at, a.last_status_at, a.status, a.agent_pool_id,
    ap::"agent_pools" AS agent_pool,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.runner_id = j.runner_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM runners a
LEFT JOIN agent_pools ap USING (agent_pool_id)
ORDER BY a.last_ping_at DESC
`

type FindRunnersRow struct {
	RunnerID     resource.ID
	Name         pgtype.Text
	Version      pgtype.Text
	MaxJobs      pgtype.Int4
	IPAddress    netip.Addr
	LastPingAt   pgtype.Timestamptz
	LastStatusAt pgtype.Timestamptz
	Status       pgtype.Text
	AgentPoolID  *resource.ID
	AgentPool    *AgentPool
	CurrentJobs  int64
}

func (q *Queries) FindRunners(ctx context.Context, db DBTX) ([]FindRunnersRow, error) {
	rows, err := db.Query(ctx, findRunners)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindRunnersRow
	for rows.Next() {
		var i FindRunnersRow
		if err := rows.Scan(
			&i.RunnerID,
			&i.Name,
			&i.Version,
			&i.MaxJobs,
			&i.IPAddress,
			&i.LastPingAt,
			&i.LastStatusAt,
			&i.Status,
			&i.AgentPoolID,
			&i.AgentPool,
			&i.CurrentJobs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRunnersByOrganization = `-- name: FindRunnersByOrganization :many
SELECT
    a.runner_id, a.name, a.version, a.max_jobs, a.ip_address, a.last_ping_at, a.last_status_at, a.status, a.agent_pool_id,
    ap::"agent_pools" AS agent_pool,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.runner_id = j.runner_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM runners a
JOIN agent_pools ap USING (agent_pool_id)
WHERE ap.organization_name = $1
ORDER BY last_ping_at DESC
`

type FindRunnersByOrganizationRow struct {
	RunnerID     resource.ID
	Name         pgtype.Text
	Version      pgtype.Text
	MaxJobs      pgtype.Int4
	IPAddress    netip.Addr
	LastPingAt   pgtype.Timestamptz
	LastStatusAt pgtype.Timestamptz
	Status       pgtype.Text
	AgentPoolID  *resource.ID
	AgentPool    *AgentPool
	CurrentJobs  int64
}

func (q *Queries) FindRunnersByOrganization(ctx context.Context, db DBTX, organizationName resource.OrganizationName) ([]FindRunnersByOrganizationRow, error) {
	rows, err := db.Query(ctx, findRunnersByOrganization, organizationName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindRunnersByOrganizationRow
	for rows.Next() {
		var i FindRunnersByOrganizationRow
		if err := rows.Scan(
			&i.RunnerID,
			&i.Name,
			&i.Version,
			&i.MaxJobs,
			&i.IPAddress,
			&i.LastPingAt,
			&i.LastStatusAt,
			&i.Status,
			&i.AgentPoolID,
			&i.AgentPool,
			&i.CurrentJobs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRunnersByPoolID = `-- name: FindRunnersByPoolID :many
SELECT
    a.runner_id, a.name, a.version, a.max_jobs, a.ip_address, a.last_ping_at, a.last_status_at, a.status, a.agent_pool_id,
    ap::"agent_pools" AS agent_pool,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.runner_id = j.runner_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM runners a
JOIN agent_pools ap USING (agent_pool_id)
WHERE ap.agent_pool_id = $1
ORDER BY last_ping_at DESC
`

type FindRunnersByPoolIDRow struct {
	RunnerID     resource.ID
	Name         pgtype.Text
	Version      pgtype.Text
	MaxJobs      pgtype.Int4
	IPAddress    netip.Addr
	LastPingAt   pgtype.Timestamptz
	LastStatusAt pgtype.Timestamptz
	Status       pgtype.Text
	AgentPoolID  *resource.ID
	AgentPool    *AgentPool
	CurrentJobs  int64
}

func (q *Queries) FindRunnersByPoolID(ctx context.Context, db DBTX, agentPoolID resource.ID) ([]FindRunnersByPoolIDRow, error) {
	rows, err := db.Query(ctx, findRunnersByPoolID, agentPoolID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindRunnersByPoolIDRow
	for rows.Next() {
		var i FindRunnersByPoolIDRow
		if err := rows.Scan(
			&i.RunnerID,
			&i.Name,
			&i.Version,
			&i.MaxJobs,
			&i.IPAddress,
			&i.LastPingAt,
			&i.LastStatusAt,
			&i.Status,
			&i.AgentPoolID,
			&i.AgentPool,
			&i.CurrentJobs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findServerRunners = `-- name: FindServerRunners :many
SELECT
    a.runner_id, a.name, a.version, a.max_jobs, a.ip_address, a.last_ping_at, a.last_status_at, a.status, a.agent_pool_id,
    ap::"agent_pools" AS agent_pool,
    ( SELECT count(*)
      FROM jobs j
      WHERE a.runner_id = j.runner_id
      AND j.status IN ('allocated', 'running')
    ) AS current_jobs
FROM runners a
LEFT JOIN agent_pools ap USING (agent_pool_id)
WHERE agent_pool_id IS NULL
ORDER BY last_ping_at DESC
`

type FindServerRunnersRow struct {
	RunnerID     resource.ID
	Name         pgtype.Text
	Version      pgtype.Text
	MaxJobs      pgtype.Int4
	IPAddress    netip.Addr
	LastPingAt   pgtype.Timestamptz
	LastStatusAt pgtype.Timestamptz
	Status       pgtype.Text
	AgentPoolID  *resource.ID
	AgentPool    *AgentPool
	CurrentJobs  int64
}

func (q *Queries) FindServerRunners(ctx context.Context, db DBTX) ([]FindServerRunnersRow, error) {
	rows, err := db.Query(ctx, findServerRunners)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindServerRunnersRow
	for rows.Next() {
		var i FindServerRunnersRow
		if err := rows.Scan(
			&i.RunnerID,
			&i.Name,
			&i.Version,
			&i.MaxJobs,
			&i.IPAddress,
			&i.LastPingAt,
			&i.LastStatusAt,
			&i.Status,
			&i.AgentPoolID,
			&i.AgentPool,
			&i.CurrentJobs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUnfinishedJobForUpdateByRunID = `-- name: FindUnfinishedJobForUpdateByRunID :one
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.run_id = $1
AND   j.status IN ('unallocated', 'allocated', 'running')
FOR UPDATE OF j
`

type FindUnfinishedJobForUpdateByRunIDRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName resource.OrganizationName
}

// FindUnfinishedJobForUpdateByRunID finds an unfinished job belonging to a run.
// (There should only be one such job for a run).
func (q *Queries) FindUnfinishedJobForUpdateByRunID(ctx context.Context, db DBTX, runID resource.ID) (FindUnfinishedJobForUpdateByRunIDRow, error) {
	row := db.QueryRow(ctx, findUnfinishedJobForUpdateByRunID, runID)
	var i FindUnfinishedJobForUpdateByRunIDRow
	err := row.Scan(
		&i.JobID,
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.Signaled,
		&i.RunnerID,
		&i.AgentPoolID,
		&i.WorkspaceID,
		&i.OrganizationName,
	)
	return i, err
}

const insertAgentPool = `-- name: InsertAgentPool :exec

INSERT INTO agent_pools (
    agent_pool_id,
    name,
    created_at,
    organization_name,
    organization_scoped
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type InsertAgentPoolParams struct {
	AgentPoolID        resource.ID
	Name               pgtype.Text
	CreatedAt          pgtype.Timestamptz
	OrganizationName   resource.OrganizationName
	OrganizationScoped pgtype.Bool
}

// agent pools
func (q *Queries) InsertAgentPool(ctx context.Context, db DBTX, arg InsertAgentPoolParams) error {
	_, err := db.Exec(ctx, insertAgentPool,
		arg.AgentPoolID,
		arg.Name,
		arg.CreatedAt,
		arg.OrganizationName,
		arg.OrganizationScoped,
	)
	return err
}

const insertAgentPoolAllowedWorkspace = `-- name: InsertAgentPoolAllowedWorkspace :exec
INSERT INTO agent_pool_allowed_workspaces (
    agent_pool_id,
    workspace_id
) VALUES (
    $1,
    $2
)
`

type InsertAgentPoolAllowedWorkspaceParams struct {
	PoolID      resource.ID
	WorkspaceID resource.ID
}

func (q *Queries) InsertAgentPoolAllowedWorkspace(ctx context.Context, db DBTX, arg InsertAgentPoolAllowedWorkspaceParams) error {
	_, err := db.Exec(ctx, insertAgentPoolAllowedWorkspace, arg.PoolID, arg.WorkspaceID)
	return err
}

const insertAgentToken = `-- name: InsertAgentToken :exec

INSERT INTO agent_tokens (
    agent_token_id,
    created_at,
    description,
    agent_pool_id
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertAgentTokenParams struct {
	AgentTokenID resource.ID
	CreatedAt    pgtype.Timestamptz
	Description  pgtype.Text
	AgentPoolID  resource.ID
}

// agent tokens
func (q *Queries) InsertAgentToken(ctx context.Context, db DBTX, arg InsertAgentTokenParams) error {
	_, err := db.Exec(ctx, insertAgentToken,
		arg.AgentTokenID,
		arg.CreatedAt,
		arg.Description,
		arg.AgentPoolID,
	)
	return err
}

const insertJob = `-- name: InsertJob :exec

INSERT INTO jobs (
    job_id,
    run_id,
    phase,
    status
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertJobParams struct {
	JobID  resource.ID
	RunID  resource.ID
	Phase  pgtype.Text
	Status pgtype.Text
}

// jobs
func (q *Queries) InsertJob(ctx context.Context, db DBTX, arg InsertJobParams) error {
	_, err := db.Exec(ctx, insertJob,
		arg.JobID,
		arg.RunID,
		arg.Phase,
		arg.Status,
	)
	return err
}

const insertRunner = `-- name: InsertRunner :exec

INSERT INTO runners (
    runner_id,
    name,
    version,
    max_jobs,
    ip_address,
    last_ping_at,
    last_status_at,
    status,
    agent_pool_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
`

type InsertRunnerParams struct {
	RunnerID     resource.ID
	Name         pgtype.Text
	Version      pgtype.Text
	MaxJobs      pgtype.Int4
	IPAddress    netip.Addr
	LastPingAt   pgtype.Timestamptz
	LastStatusAt pgtype.Timestamptz
	Status       pgtype.Text
	AgentPoolID  *resource.ID
}

// runners
func (q *Queries) InsertRunner(ctx context.Context, db DBTX, arg InsertRunnerParams) error {
	_, err := db.Exec(ctx, insertRunner,
		arg.RunnerID,
		arg.Name,
		arg.Version,
		arg.MaxJobs,
		arg.IPAddress,
		arg.LastPingAt,
		arg.LastStatusAt,
		arg.Status,
		arg.AgentPoolID,
	)
	return err
}

const updateAgentPool = `-- name: UpdateAgentPool :one
UPDATE agent_pools
SET name = $1,
    organization_scoped = $2
WHERE agent_pool_id = $3
RETURNING agent_pool_id, name, created_at, organization_name, organization_scoped
`

type UpdateAgentPoolParams struct {
	Name               pgtype.Text
	OrganizationScoped pgtype.Bool
	PoolID             resource.ID
}

func (q *Queries) UpdateAgentPool(ctx context.Context, db DBTX, arg UpdateAgentPoolParams) (AgentPool, error) {
	row := db.QueryRow(ctx, updateAgentPool, arg.Name, arg.OrganizationScoped, arg.PoolID)
	var i AgentPool
	err := row.Scan(
		&i.AgentPoolID,
		&i.Name,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.OrganizationScoped,
	)
	return i, err
}

const updateJob = `-- name: UpdateJob :one
UPDATE jobs
SET status   = $1,
    signaled = $2,
    runner_id = $3
WHERE job_id = $4
RETURNING run_id, phase, status, runner_id, signaled, job_id
`

type UpdateJobParams struct {
	Status   pgtype.Text
	Signaled pgtype.Bool
	RunnerID *resource.ID
	JobID    resource.ID
}

func (q *Queries) UpdateJob(ctx context.Context, db DBTX, arg UpdateJobParams) (JobModel, error) {
	row := db.QueryRow(ctx, updateJob,
		arg.Status,
		arg.Signaled,
		arg.RunnerID,
		arg.JobID,
	)
	var i JobModel
	err := row.Scan(
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.RunnerID,
		&i.Signaled,
		&i.JobID,
	)
	return i, err
}

const updateRunner = `-- name: UpdateRunner :one
UPDATE runners
SET status = $1,
    last_ping_at = $2,
    last_status_at = $3
WHERE runner_id = $4
RETURNING runner_id, name, version, max_jobs, ip_address, last_ping_at, last_status_at, status, agent_pool_id
`

type UpdateRunnerParams struct {
	Status       pgtype.Text
	LastPingAt   pgtype.Timestamptz
	LastStatusAt pgtype.Timestamptz
	RunnerID     resource.ID
}

func (q *Queries) UpdateRunner(ctx context.Context, db DBTX, arg UpdateRunnerParams) (RunnerModel, error) {
	row := db.QueryRow(ctx, updateRunner,
		arg.Status,
		arg.LastPingAt,
		arg.LastStatusAt,
		arg.RunnerID,
	)
	var i RunnerModel
	err := row.Scan(
		&i.RunnerID,
		&i.Name,
		&i.Version,
		&i.MaxJobs,
		&i.IPAddress,
		&i.LastPingAt,
		&i.LastStatusAt,
		&i.Status,
		&i.AgentPoolID,
	)
	return i, err
}
