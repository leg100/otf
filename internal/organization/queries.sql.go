// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package organization

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/leg100/otf/internal/resource"
)

const countOrganizations = `-- name: CountOrganizations :one
SELECT count(*)
FROM organizations
WHERE name LIKE ANY($1::text[])
`

func (q *Queries) CountOrganizations(ctx context.Context, db DBTX, names []pgtype.Text) (int64, error) {
	row := db.QueryRow(ctx, countOrganizations, names)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOrganiationTokenByName = `-- name: DeleteOrganiationTokenByName :one
DELETE
FROM organization_tokens
WHERE organization_name = $1
RETURNING organization_token_id
`

func (q *Queries) DeleteOrganiationTokenByName(ctx context.Context, db DBTX, organizationName resource.OrganizationName) (resource.ID, error) {
	row := db.QueryRow(ctx, deleteOrganiationTokenByName, organizationName)
	var organization_token_id resource.ID
	err := row.Scan(&organization_token_id)
	return organization_token_id, err
}

const deleteOrganizationByName = `-- name: DeleteOrganizationByName :one
DELETE
FROM organizations
WHERE name = $1
RETURNING organization_id
`

func (q *Queries) DeleteOrganizationByName(ctx context.Context, db DBTX, name resource.OrganizationName) (resource.ID, error) {
	row := db.QueryRow(ctx, deleteOrganizationByName, name)
	var organization_id resource.ID
	err := row.Scan(&organization_id)
	return organization_id, err
}

const findOrganizationByID = `-- name: FindOrganizationByID :one
SELECT organization_id, created_at, updated_at, name, session_remember, session_timeout, email, collaborator_auth_policy, allow_force_delete_workspaces, cost_estimation_enabled FROM organizations WHERE organization_id = $1
`

func (q *Queries) FindOrganizationByID(ctx context.Context, db DBTX, organizationID resource.ID) (Model, error) {
	row := db.QueryRow(ctx, findOrganizationByID, organizationID)
	var i Model
	err := row.Scan(
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.SessionRemember,
		&i.SessionTimeout,
		&i.Email,
		&i.CollaboratorAuthPolicy,
		&i.AllowForceDeleteWorkspaces,
		&i.CostEstimationEnabled,
	)
	return i, err
}

const findOrganizationByName = `-- name: FindOrganizationByName :one
SELECT organization_id, created_at, updated_at, name, session_remember, session_timeout, email, collaborator_auth_policy, allow_force_delete_workspaces, cost_estimation_enabled FROM organizations WHERE name = $1
`

func (q *Queries) FindOrganizationByName(ctx context.Context, db DBTX, name resource.OrganizationName) (Model, error) {
	row := db.QueryRow(ctx, findOrganizationByName, name)
	var i Model
	err := row.Scan(
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.SessionRemember,
		&i.SessionTimeout,
		&i.Email,
		&i.CollaboratorAuthPolicy,
		&i.AllowForceDeleteWorkspaces,
		&i.CostEstimationEnabled,
	)
	return i, err
}

const findOrganizationByNameForUpdate = `-- name: FindOrganizationByNameForUpdate :one
SELECT organization_id, created_at, updated_at, name, session_remember, session_timeout, email, collaborator_auth_policy, allow_force_delete_workspaces, cost_estimation_enabled
FROM organizations
WHERE name = $1
FOR UPDATE
`

func (q *Queries) FindOrganizationByNameForUpdate(ctx context.Context, db DBTX, name resource.OrganizationName) (Model, error) {
	row := db.QueryRow(ctx, findOrganizationByNameForUpdate, name)
	var i Model
	err := row.Scan(
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.SessionRemember,
		&i.SessionTimeout,
		&i.Email,
		&i.CollaboratorAuthPolicy,
		&i.AllowForceDeleteWorkspaces,
		&i.CostEstimationEnabled,
	)
	return i, err
}

const findOrganizationNameByWorkspaceID = `-- name: FindOrganizationNameByWorkspaceID :one
SELECT organization_name
FROM workspaces
WHERE workspace_id = $1
`

func (q *Queries) FindOrganizationNameByWorkspaceID(ctx context.Context, db DBTX, workspaceID resource.ID) (pgtype.Text, error) {
	row := db.QueryRow(ctx, findOrganizationNameByWorkspaceID, workspaceID)
	var organization_name pgtype.Text
	err := row.Scan(&organization_name)
	return organization_name, err
}

const findOrganizationTokens = `-- name: FindOrganizationTokens :many
SELECT organization_token_id, created_at, organization_name, expiry
FROM organization_tokens
WHERE organization_name = $1
`

func (q *Queries) FindOrganizationTokens(ctx context.Context, db DBTX, organizationName resource.OrganizationName) ([]TokenModel, error) {
	rows, err := db.Query(ctx, findOrganizationTokens, organizationName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TokenModel
	for rows.Next() {
		var i TokenModel
		if err := rows.Scan(
			&i.OrganizationTokenID,
			&i.CreatedAt,
			&i.OrganizationName,
			&i.Expiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findOrganizationTokensByID = `-- name: FindOrganizationTokensByID :one
SELECT organization_token_id, created_at, organization_name, expiry
FROM organization_tokens
WHERE organization_token_id = $1
`

func (q *Queries) FindOrganizationTokensByID(ctx context.Context, db DBTX, organizationTokenID resource.ID) (TokenModel, error) {
	row := db.QueryRow(ctx, findOrganizationTokensByID, organizationTokenID)
	var i TokenModel
	err := row.Scan(
		&i.OrganizationTokenID,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.Expiry,
	)
	return i, err
}

const findOrganizationTokensByName = `-- name: FindOrganizationTokensByName :one
SELECT organization_token_id, created_at, organization_name, expiry
FROM organization_tokens
WHERE organization_name = $1
`

func (q *Queries) FindOrganizationTokensByName(ctx context.Context, db DBTX, organizationName resource.OrganizationName) (TokenModel, error) {
	row := db.QueryRow(ctx, findOrganizationTokensByName, organizationName)
	var i TokenModel
	err := row.Scan(
		&i.OrganizationTokenID,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.Expiry,
	)
	return i, err
}

const findOrganizations = `-- name: FindOrganizations :many
SELECT organization_id, created_at, updated_at, name, session_remember, session_timeout, email, collaborator_auth_policy, allow_force_delete_workspaces, cost_estimation_enabled
FROM organizations
WHERE name LIKE ANY($1::text[])
ORDER BY updated_at DESC
LIMIT $3::int OFFSET $2::int
`

type FindOrganizationsParams struct {
	Names  []pgtype.Text
	Offset pgtype.Int4
	Limit  pgtype.Int4
}

func (q *Queries) FindOrganizations(ctx context.Context, db DBTX, arg FindOrganizationsParams) ([]Model, error) {
	rows, err := db.Query(ctx, findOrganizations, arg.Names, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Model
	for rows.Next() {
		var i Model
		if err := rows.Scan(
			&i.OrganizationID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.SessionRemember,
			&i.SessionTimeout,
			&i.Email,
			&i.CollaboratorAuthPolicy,
			&i.AllowForceDeleteWorkspaces,
			&i.CostEstimationEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrganization = `-- name: InsertOrganization :exec
INSERT INTO organizations (
    organization_id,
    created_at,
    updated_at,
    name,
    email,
    collaborator_auth_policy,
    cost_estimation_enabled,
    session_remember,
    session_timeout,
    allow_force_delete_workspaces
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
`

type InsertOrganizationParams struct {
	ID                         resource.ID
	CreatedAt                  pgtype.Timestamptz
	UpdatedAt                  pgtype.Timestamptz
	Name                       resource.OrganizationName
	Email                      pgtype.Text
	CollaboratorAuthPolicy     pgtype.Text
	CostEstimationEnabled      pgtype.Bool
	SessionRemember            pgtype.Int4
	SessionTimeout             pgtype.Int4
	AllowForceDeleteWorkspaces pgtype.Bool
}

func (q *Queries) InsertOrganization(ctx context.Context, db DBTX, arg InsertOrganizationParams) error {
	_, err := db.Exec(ctx, insertOrganization,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.Email,
		arg.CollaboratorAuthPolicy,
		arg.CostEstimationEnabled,
		arg.SessionRemember,
		arg.SessionTimeout,
		arg.AllowForceDeleteWorkspaces,
	)
	return err
}

const updateOrganizationByName = `-- name: UpdateOrganizationByName :one
UPDATE organizations
SET
    name = $1,
    email = $2,
    collaborator_auth_policy = $3,
    cost_estimation_enabled = $4,
    session_remember = $5,
    session_timeout = $6,
    allow_force_delete_workspaces = $7,
    updated_at = $8
WHERE name = $9
RETURNING organization_id
`

type UpdateOrganizationByNameParams struct {
	NewName                    resource.OrganizationName
	Email                      pgtype.Text
	CollaboratorAuthPolicy     pgtype.Text
	CostEstimationEnabled      pgtype.Bool
	SessionRemember            pgtype.Int4
	SessionTimeout             pgtype.Int4
	AllowForceDeleteWorkspaces pgtype.Bool
	UpdatedAt                  pgtype.Timestamptz
	Name                       resource.OrganizationName
}

func (q *Queries) UpdateOrganizationByName(ctx context.Context, db DBTX, arg UpdateOrganizationByNameParams) (resource.ID, error) {
	row := db.QueryRow(ctx, updateOrganizationByName,
		arg.NewName,
		arg.Email,
		arg.CollaboratorAuthPolicy,
		arg.CostEstimationEnabled,
		arg.SessionRemember,
		arg.SessionTimeout,
		arg.AllowForceDeleteWorkspaces,
		arg.UpdatedAt,
		arg.Name,
	)
	var organization_id resource.ID
	err := row.Scan(&organization_id)
	return organization_id, err
}

const upsertOrganizationToken = `-- name: UpsertOrganizationToken :exec
INSERT INTO organization_tokens (
    organization_token_id,
    created_at,
    organization_name,
    expiry
) VALUES (
    $1,
    $2,
    $3,
    $4
) ON CONFLICT (organization_name) DO UPDATE
  SET created_at            = $2,
      organization_token_id = $1,
      expiry                = $4
`

type UpsertOrganizationTokenParams struct {
	OrganizationTokenID resource.ID
	CreatedAt           pgtype.Timestamptz
	OrganizationName    resource.OrganizationName
	Expiry              pgtype.Timestamptz
}

func (q *Queries) UpsertOrganizationToken(ctx context.Context, db DBTX, arg UpsertOrganizationTokenParams) error {
	_, err := db.Exec(ctx, upsertOrganizationToken,
		arg.OrganizationTokenID,
		arg.CreatedAt,
		arg.OrganizationName,
		arg.Expiry,
	)
	return err
}
