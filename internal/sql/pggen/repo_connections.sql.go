// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertRepoConnectionSQL = `INSERT INTO repo_connections (
    vcs_provider_id,
    repo_path,
    workspace_id,
    module_id
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertRepoConnectionParams struct {
	VCSProviderID pgtype.Text
	RepoPath      pgtype.Text
	WorkspaceID   pgtype.Text
	ModuleID      pgtype.Text
}

// InsertRepoConnection implements Querier.InsertRepoConnection.
func (q *DBQuerier) InsertRepoConnection(ctx context.Context, params InsertRepoConnectionParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertRepoConnection")
	cmdTag, err := q.conn.Exec(ctx, insertRepoConnectionSQL, params.VCSProviderID, params.RepoPath, params.WorkspaceID, params.ModuleID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertRepoConnection: %w", err)
	}
	return cmdTag, err
}

// InsertRepoConnectionBatch implements Querier.InsertRepoConnectionBatch.
func (q *DBQuerier) InsertRepoConnectionBatch(batch genericBatch, params InsertRepoConnectionParams) {
	batch.Queue(insertRepoConnectionSQL, params.VCSProviderID, params.RepoPath, params.WorkspaceID, params.ModuleID)
}

// InsertRepoConnectionScan implements Querier.InsertRepoConnectionScan.
func (q *DBQuerier) InsertRepoConnectionScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertRepoConnectionBatch: %w", err)
	}
	return cmdTag, err
}

const deleteWorkspaceConnectionByIDSQL = `DELETE
FROM repo_connections
WHERE workspace_id = $1
RETURNING *;`

type DeleteWorkspaceConnectionByIDRow struct {
	ModuleID      pgtype.Text `json:"module_id"`
	WorkspaceID   pgtype.Text `json:"workspace_id"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
}

// DeleteWorkspaceConnectionByID implements Querier.DeleteWorkspaceConnectionByID.
func (q *DBQuerier) DeleteWorkspaceConnectionByID(ctx context.Context, workspaceID pgtype.Text) (DeleteWorkspaceConnectionByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceConnectionByID")
	row := q.conn.QueryRow(ctx, deleteWorkspaceConnectionByIDSQL, workspaceID)
	var item DeleteWorkspaceConnectionByIDRow
	if err := row.Scan(&item.ModuleID, &item.WorkspaceID, &item.RepoPath, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("query DeleteWorkspaceConnectionByID: %w", err)
	}
	return item, nil
}

// DeleteWorkspaceConnectionByIDBatch implements Querier.DeleteWorkspaceConnectionByIDBatch.
func (q *DBQuerier) DeleteWorkspaceConnectionByIDBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(deleteWorkspaceConnectionByIDSQL, workspaceID)
}

// DeleteWorkspaceConnectionByIDScan implements Querier.DeleteWorkspaceConnectionByIDScan.
func (q *DBQuerier) DeleteWorkspaceConnectionByIDScan(results pgx.BatchResults) (DeleteWorkspaceConnectionByIDRow, error) {
	row := results.QueryRow()
	var item DeleteWorkspaceConnectionByIDRow
	if err := row.Scan(&item.ModuleID, &item.WorkspaceID, &item.RepoPath, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("scan DeleteWorkspaceConnectionByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteModuleConnectionByIDSQL = `DELETE
FROM repo_connections
WHERE module_id = $1
RETURNING *;`

type DeleteModuleConnectionByIDRow struct {
	ModuleID      pgtype.Text `json:"module_id"`
	WorkspaceID   pgtype.Text `json:"workspace_id"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
}

// DeleteModuleConnectionByID implements Querier.DeleteModuleConnectionByID.
func (q *DBQuerier) DeleteModuleConnectionByID(ctx context.Context, moduleID pgtype.Text) (DeleteModuleConnectionByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteModuleConnectionByID")
	row := q.conn.QueryRow(ctx, deleteModuleConnectionByIDSQL, moduleID)
	var item DeleteModuleConnectionByIDRow
	if err := row.Scan(&item.ModuleID, &item.WorkspaceID, &item.RepoPath, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("query DeleteModuleConnectionByID: %w", err)
	}
	return item, nil
}

// DeleteModuleConnectionByIDBatch implements Querier.DeleteModuleConnectionByIDBatch.
func (q *DBQuerier) DeleteModuleConnectionByIDBatch(batch genericBatch, moduleID pgtype.Text) {
	batch.Queue(deleteModuleConnectionByIDSQL, moduleID)
}

// DeleteModuleConnectionByIDScan implements Querier.DeleteModuleConnectionByIDScan.
func (q *DBQuerier) DeleteModuleConnectionByIDScan(results pgx.BatchResults) (DeleteModuleConnectionByIDRow, error) {
	row := results.QueryRow()
	var item DeleteModuleConnectionByIDRow
	if err := row.Scan(&item.ModuleID, &item.WorkspaceID, &item.RepoPath, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("scan DeleteModuleConnectionByIDBatch row: %w", err)
	}
	return item, nil
}
