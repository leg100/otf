// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertWorkspaceVariableSQL = `INSERT INTO workspace_variables (
    variable_id,
    workspace_id
) VALUES (
    $1,
    $2
);`

// InsertWorkspaceVariable implements Querier.InsertWorkspaceVariable.
func (q *DBQuerier) InsertWorkspaceVariable(ctx context.Context, variableID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspaceVariable")
	cmdTag, err := q.conn.Exec(ctx, insertWorkspaceVariableSQL, variableID, workspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertWorkspaceVariable: %w", err)
	}
	return cmdTag, err
}

// InsertWorkspaceVariableBatch implements Querier.InsertWorkspaceVariableBatch.
func (q *DBQuerier) InsertWorkspaceVariableBatch(batch genericBatch, variableID pgtype.Text, workspaceID pgtype.Text) {
	batch.Queue(insertWorkspaceVariableSQL, variableID, workspaceID)
}

// InsertWorkspaceVariableScan implements Querier.InsertWorkspaceVariableScan.
func (q *DBQuerier) InsertWorkspaceVariableScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertWorkspaceVariableBatch: %w", err)
	}
	return cmdTag, err
}

const findWorkspaceVariablesByWorkspaceIDSQL = `SELECT *
FROM workspace_variables
JOIN variables USING (variable_id)
WHERE workspace_id = $1
;`

type FindWorkspaceVariablesByWorkspaceIDRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   bool        `json:"sensitive"`
	HCL         bool        `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// FindWorkspaceVariablesByWorkspaceID implements Querier.FindWorkspaceVariablesByWorkspaceID.
func (q *DBQuerier) FindWorkspaceVariablesByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) ([]FindWorkspaceVariablesByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceVariablesByWorkspaceID")
	rows, err := q.conn.Query(ctx, findWorkspaceVariablesByWorkspaceIDSQL, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaceVariablesByWorkspaceID: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspaceVariablesByWorkspaceIDRow{}
	for rows.Next() {
		var item FindWorkspaceVariablesByWorkspaceIDRow
		if err := rows.Scan(&item.VariableID, &item.WorkspaceID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
			return nil, fmt.Errorf("scan FindWorkspaceVariablesByWorkspaceID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspaceVariablesByWorkspaceID rows: %w", err)
	}
	return items, err
}

// FindWorkspaceVariablesByWorkspaceIDBatch implements Querier.FindWorkspaceVariablesByWorkspaceIDBatch.
func (q *DBQuerier) FindWorkspaceVariablesByWorkspaceIDBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(findWorkspaceVariablesByWorkspaceIDSQL, workspaceID)
}

// FindWorkspaceVariablesByWorkspaceIDScan implements Querier.FindWorkspaceVariablesByWorkspaceIDScan.
func (q *DBQuerier) FindWorkspaceVariablesByWorkspaceIDScan(results pgx.BatchResults) ([]FindWorkspaceVariablesByWorkspaceIDRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaceVariablesByWorkspaceIDBatch: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspaceVariablesByWorkspaceIDRow{}
	for rows.Next() {
		var item FindWorkspaceVariablesByWorkspaceIDRow
		if err := rows.Scan(&item.VariableID, &item.WorkspaceID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
			return nil, fmt.Errorf("scan FindWorkspaceVariablesByWorkspaceIDBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspaceVariablesByWorkspaceIDBatch rows: %w", err)
	}
	return items, err
}

const findWorkspaceVariableByIDSQL = `SELECT *
FROM workspace_variables
JOIN variables USING (variable_id)
WHERE variable_id = $1
;`

type FindWorkspaceVariableByIDRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   bool        `json:"sensitive"`
	HCL         bool        `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// FindWorkspaceVariableByID implements Querier.FindWorkspaceVariableByID.
func (q *DBQuerier) FindWorkspaceVariableByID(ctx context.Context, variableID pgtype.Text) (FindWorkspaceVariableByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceVariableByID")
	row := q.conn.QueryRow(ctx, findWorkspaceVariableByIDSQL, variableID)
	var item FindWorkspaceVariableByIDRow
	if err := row.Scan(&item.VariableID, &item.WorkspaceID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
		return item, fmt.Errorf("query FindWorkspaceVariableByID: %w", err)
	}
	return item, nil
}

// FindWorkspaceVariableByIDBatch implements Querier.FindWorkspaceVariableByIDBatch.
func (q *DBQuerier) FindWorkspaceVariableByIDBatch(batch genericBatch, variableID pgtype.Text) {
	batch.Queue(findWorkspaceVariableByIDSQL, variableID)
}

// FindWorkspaceVariableByIDScan implements Querier.FindWorkspaceVariableByIDScan.
func (q *DBQuerier) FindWorkspaceVariableByIDScan(results pgx.BatchResults) (FindWorkspaceVariableByIDRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceVariableByIDRow
	if err := row.Scan(&item.VariableID, &item.WorkspaceID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceVariableByIDBatch row: %w", err)
	}
	return item, nil
}

const findWorkspaceVariableForUpdateSQL = `SELECT *
FROM workspace_variables
JOIN variables v USING (variable_id)
WHERE variable_id = $1
FOR UPDATE OF v;`

type FindWorkspaceVariableForUpdateRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   bool        `json:"sensitive"`
	HCL         bool        `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// FindWorkspaceVariableForUpdate implements Querier.FindWorkspaceVariableForUpdate.
func (q *DBQuerier) FindWorkspaceVariableForUpdate(ctx context.Context, variableID pgtype.Text) (FindWorkspaceVariableForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceVariableForUpdate")
	row := q.conn.QueryRow(ctx, findWorkspaceVariableForUpdateSQL, variableID)
	var item FindWorkspaceVariableForUpdateRow
	if err := row.Scan(&item.VariableID, &item.WorkspaceID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
		return item, fmt.Errorf("query FindWorkspaceVariableForUpdate: %w", err)
	}
	return item, nil
}

// FindWorkspaceVariableForUpdateBatch implements Querier.FindWorkspaceVariableForUpdateBatch.
func (q *DBQuerier) FindWorkspaceVariableForUpdateBatch(batch genericBatch, variableID pgtype.Text) {
	batch.Queue(findWorkspaceVariableForUpdateSQL, variableID)
}

// FindWorkspaceVariableForUpdateScan implements Querier.FindWorkspaceVariableForUpdateScan.
func (q *DBQuerier) FindWorkspaceVariableForUpdateScan(results pgx.BatchResults) (FindWorkspaceVariableForUpdateRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceVariableForUpdateRow
	if err := row.Scan(&item.VariableID, &item.WorkspaceID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceVariableForUpdateBatch row: %w", err)
	}
	return item, nil
}

const deleteWorkspaceVariableByIDSQL = `DELETE
FROM workspace_variables
WHERE variable_id = $1
AND workspace_id = $2
RETURNING *;`

type DeleteWorkspaceVariableByIDRow struct {
	WorkspaceID pgtype.Text `json:"workspace_id"`
	VariableID  pgtype.Text `json:"variable_id"`
}

// DeleteWorkspaceVariableByID implements Querier.DeleteWorkspaceVariableByID.
func (q *DBQuerier) DeleteWorkspaceVariableByID(ctx context.Context, variableID pgtype.Text, workspaceID pgtype.Text) (DeleteWorkspaceVariableByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceVariableByID")
	row := q.conn.QueryRow(ctx, deleteWorkspaceVariableByIDSQL, variableID, workspaceID)
	var item DeleteWorkspaceVariableByIDRow
	if err := row.Scan(&item.WorkspaceID, &item.VariableID); err != nil {
		return item, fmt.Errorf("query DeleteWorkspaceVariableByID: %w", err)
	}
	return item, nil
}

// DeleteWorkspaceVariableByIDBatch implements Querier.DeleteWorkspaceVariableByIDBatch.
func (q *DBQuerier) DeleteWorkspaceVariableByIDBatch(batch genericBatch, variableID pgtype.Text, workspaceID pgtype.Text) {
	batch.Queue(deleteWorkspaceVariableByIDSQL, variableID, workspaceID)
}

// DeleteWorkspaceVariableByIDScan implements Querier.DeleteWorkspaceVariableByIDScan.
func (q *DBQuerier) DeleteWorkspaceVariableByIDScan(results pgx.BatchResults) (DeleteWorkspaceVariableByIDRow, error) {
	row := results.QueryRow()
	var item DeleteWorkspaceVariableByIDRow
	if err := row.Scan(&item.WorkspaceID, &item.VariableID); err != nil {
		return item, fmt.Errorf("scan DeleteWorkspaceVariableByIDBatch row: %w", err)
	}
	return item, nil
}
