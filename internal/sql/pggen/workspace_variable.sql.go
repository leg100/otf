// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertWorkspaceVariableSQL = `INSERT INTO workspace_variables (
    variable_id,
    workspace_id
) VALUES (
    $1,
    $2
);`

// InsertWorkspaceVariable implements Querier.InsertWorkspaceVariable.
func (q *DBQuerier) InsertWorkspaceVariable(ctx context.Context, variableID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspaceVariable")
	cmdTag, err := q.conn.Exec(ctx, insertWorkspaceVariableSQL, variableID, workspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertWorkspaceVariable: %w", err)
	}
	return cmdTag, err
}

// InsertWorkspaceVariableBatch implements Querier.InsertWorkspaceVariableBatch.
func (q *DBQuerier) InsertWorkspaceVariableBatch(batch genericBatch, variableID pgtype.Text, workspaceID pgtype.Text) {
	batch.Queue(insertWorkspaceVariableSQL, variableID, workspaceID)
}

// InsertWorkspaceVariableScan implements Querier.InsertWorkspaceVariableScan.
func (q *DBQuerier) InsertWorkspaceVariableScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertWorkspaceVariableBatch: %w", err)
	}
	return cmdTag, err
}

const findVariablesByWorkspaceIDSQL = `SELECT v.*
FROM workspace_variables
JOIN variables v USING (variable_id)
WHERE workspace_id = $1
;`

type FindVariablesByWorkspaceIDRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   bool        `json:"sensitive"`
	HCL         bool        `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// FindVariablesByWorkspaceID implements Querier.FindVariablesByWorkspaceID.
func (q *DBQuerier) FindVariablesByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) ([]FindVariablesByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindVariablesByWorkspaceID")
	rows, err := q.conn.Query(ctx, findVariablesByWorkspaceIDSQL, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("query FindVariablesByWorkspaceID: %w", err)
	}
	defer rows.Close()
	items := []FindVariablesByWorkspaceIDRow{}
	for rows.Next() {
		var item FindVariablesByWorkspaceIDRow
		if err := rows.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
			return nil, fmt.Errorf("scan FindVariablesByWorkspaceID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindVariablesByWorkspaceID rows: %w", err)
	}
	return items, err
}

// FindVariablesByWorkspaceIDBatch implements Querier.FindVariablesByWorkspaceIDBatch.
func (q *DBQuerier) FindVariablesByWorkspaceIDBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(findVariablesByWorkspaceIDSQL, workspaceID)
}

// FindVariablesByWorkspaceIDScan implements Querier.FindVariablesByWorkspaceIDScan.
func (q *DBQuerier) FindVariablesByWorkspaceIDScan(results pgx.BatchResults) ([]FindVariablesByWorkspaceIDRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindVariablesByWorkspaceIDBatch: %w", err)
	}
	defer rows.Close()
	items := []FindVariablesByWorkspaceIDRow{}
	for rows.Next() {
		var item FindVariablesByWorkspaceIDRow
		if err := rows.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
			return nil, fmt.Errorf("scan FindVariablesByWorkspaceIDBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindVariablesByWorkspaceIDBatch rows: %w", err)
	}
	return items, err
}

const findWorkspaceVariableByIDSQL = `SELECT workspace_id, (v.*)::"variables" AS variable
FROM workspace_variables
JOIN variables v USING (variable_id)
WHERE variable_id = $1
;`

type FindWorkspaceVariableByIDRow struct {
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Variable    *Variables  `json:"variable"`
}

// FindWorkspaceVariableByID implements Querier.FindWorkspaceVariableByID.
func (q *DBQuerier) FindWorkspaceVariableByID(ctx context.Context, variableID pgtype.Text) (FindWorkspaceVariableByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceVariableByID")
	row := q.conn.QueryRow(ctx, findWorkspaceVariableByIDSQL, variableID)
	var item FindWorkspaceVariableByIDRow
	variableRow := q.types.newVariables()
	if err := row.Scan(&item.WorkspaceID, variableRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceVariableByID: %w", err)
	}
	if err := variableRow.AssignTo(&item.Variable); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceVariableByID row: %w", err)
	}
	return item, nil
}

// FindWorkspaceVariableByIDBatch implements Querier.FindWorkspaceVariableByIDBatch.
func (q *DBQuerier) FindWorkspaceVariableByIDBatch(batch genericBatch, variableID pgtype.Text) {
	batch.Queue(findWorkspaceVariableByIDSQL, variableID)
}

// FindWorkspaceVariableByIDScan implements Querier.FindWorkspaceVariableByIDScan.
func (q *DBQuerier) FindWorkspaceVariableByIDScan(results pgx.BatchResults) (FindWorkspaceVariableByIDRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceVariableByIDRow
	variableRow := q.types.newVariables()
	if err := row.Scan(&item.WorkspaceID, variableRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceVariableByIDBatch row: %w", err)
	}
	if err := variableRow.AssignTo(&item.Variable); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceVariableByID row: %w", err)
	}
	return item, nil
}

const deleteWorkspaceVariableByIDSQL = `DELETE
FROM workspace_variables
WHERE variable_id = $1
AND workspace_id = $2
RETURNING *;`

type DeleteWorkspaceVariableByIDRow struct {
	WorkspaceID pgtype.Text `json:"workspace_id"`
	VariableID  pgtype.Text `json:"variable_id"`
}

// DeleteWorkspaceVariableByID implements Querier.DeleteWorkspaceVariableByID.
func (q *DBQuerier) DeleteWorkspaceVariableByID(ctx context.Context, variableID pgtype.Text, workspaceID pgtype.Text) (DeleteWorkspaceVariableByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceVariableByID")
	row := q.conn.QueryRow(ctx, deleteWorkspaceVariableByIDSQL, variableID, workspaceID)
	var item DeleteWorkspaceVariableByIDRow
	if err := row.Scan(&item.WorkspaceID, &item.VariableID); err != nil {
		return item, fmt.Errorf("query DeleteWorkspaceVariableByID: %w", err)
	}
	return item, nil
}

// DeleteWorkspaceVariableByIDBatch implements Querier.DeleteWorkspaceVariableByIDBatch.
func (q *DBQuerier) DeleteWorkspaceVariableByIDBatch(batch genericBatch, variableID pgtype.Text, workspaceID pgtype.Text) {
	batch.Queue(deleteWorkspaceVariableByIDSQL, variableID, workspaceID)
}

// DeleteWorkspaceVariableByIDScan implements Querier.DeleteWorkspaceVariableByIDScan.
func (q *DBQuerier) DeleteWorkspaceVariableByIDScan(results pgx.BatchResults) (DeleteWorkspaceVariableByIDRow, error) {
	row := results.QueryRow()
	var item DeleteWorkspaceVariableByIDRow
	if err := row.Scan(&item.WorkspaceID, &item.VariableID); err != nil {
		return item, fmt.Errorf("scan DeleteWorkspaceVariableByIDBatch row: %w", err)
	}
	return item, nil
}
