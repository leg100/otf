// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertWorkspaceVariableSQL = `INSERT INTO workspace_variables (
    variable_id,
    workspace_id
) VALUES (
    $1,
    $2
);`

// InsertWorkspaceVariable implements Querier.InsertWorkspaceVariable.
func (q *DBQuerier) InsertWorkspaceVariable(ctx context.Context, variableID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspaceVariable")
	cmdTag, err := q.conn.Exec(ctx, insertWorkspaceVariableSQL, variableID, workspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertWorkspaceVariable: %w", err)
	}
	return cmdTag, err
}

// InsertWorkspaceVariableBatch implements Querier.InsertWorkspaceVariableBatch.
func (q *DBQuerier) InsertWorkspaceVariableBatch(batch genericBatch, variableID pgtype.Text, workspaceID pgtype.Text) {
	batch.Queue(insertWorkspaceVariableSQL, variableID, workspaceID)
}

// InsertWorkspaceVariableScan implements Querier.InsertWorkspaceVariableScan.
func (q *DBQuerier) InsertWorkspaceVariableScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertWorkspaceVariableBatch: %w", err)
	}
	return cmdTag, err
}

const findWorkspaceVariablesByWorkspaceIDSQL = `SELECT v.*
FROM workspace_variables
JOIN variables v USING (variable_id)
WHERE workspace_id = $1;`

type FindWorkspaceVariablesByWorkspaceIDRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   pgtype.Bool `json:"sensitive"`
	HCL         pgtype.Bool `json:"hcl"`
	VersionID   pgtype.Text `json:"version_id"`
}

// FindWorkspaceVariablesByWorkspaceID implements Querier.FindWorkspaceVariablesByWorkspaceID.
func (q *DBQuerier) FindWorkspaceVariablesByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) ([]FindWorkspaceVariablesByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceVariablesByWorkspaceID")
	rows, err := q.conn.Query(ctx, findWorkspaceVariablesByWorkspaceIDSQL, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaceVariablesByWorkspaceID: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspaceVariablesByWorkspaceIDRow{}
	for rows.Next() {
		var item FindWorkspaceVariablesByWorkspaceIDRow
		if err := rows.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
			return nil, fmt.Errorf("scan FindWorkspaceVariablesByWorkspaceID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspaceVariablesByWorkspaceID rows: %w", err)
	}
	return items, err
}

// FindWorkspaceVariablesByWorkspaceIDBatch implements Querier.FindWorkspaceVariablesByWorkspaceIDBatch.
func (q *DBQuerier) FindWorkspaceVariablesByWorkspaceIDBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(findWorkspaceVariablesByWorkspaceIDSQL, workspaceID)
}

// FindWorkspaceVariablesByWorkspaceIDScan implements Querier.FindWorkspaceVariablesByWorkspaceIDScan.
func (q *DBQuerier) FindWorkspaceVariablesByWorkspaceIDScan(results pgx.BatchResults) ([]FindWorkspaceVariablesByWorkspaceIDRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaceVariablesByWorkspaceIDBatch: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspaceVariablesByWorkspaceIDRow{}
	for rows.Next() {
		var item FindWorkspaceVariablesByWorkspaceIDRow
		if err := rows.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.VersionID); err != nil {
			return nil, fmt.Errorf("scan FindWorkspaceVariablesByWorkspaceIDBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspaceVariablesByWorkspaceIDBatch rows: %w", err)
	}
	return items, err
}

const findWorkspaceVariableByVariableIDSQL = `SELECT workspace_id, (v.*)::"variables" AS variable
FROM workspace_variables
JOIN variables v USING (variable_id)
WHERE variable_id = $1;`

type FindWorkspaceVariableByVariableIDRow struct {
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Variable    *Variables  `json:"variable"`
}

// FindWorkspaceVariableByVariableID implements Querier.FindWorkspaceVariableByVariableID.
func (q *DBQuerier) FindWorkspaceVariableByVariableID(ctx context.Context, variableID pgtype.Text) (FindWorkspaceVariableByVariableIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceVariableByVariableID")
	row := q.conn.QueryRow(ctx, findWorkspaceVariableByVariableIDSQL, variableID)
	var item FindWorkspaceVariableByVariableIDRow
	variableRow := q.types.newVariables()
	if err := row.Scan(&item.WorkspaceID, variableRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceVariableByVariableID: %w", err)
	}
	if err := variableRow.AssignTo(&item.Variable); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceVariableByVariableID row: %w", err)
	}
	return item, nil
}

// FindWorkspaceVariableByVariableIDBatch implements Querier.FindWorkspaceVariableByVariableIDBatch.
func (q *DBQuerier) FindWorkspaceVariableByVariableIDBatch(batch genericBatch, variableID pgtype.Text) {
	batch.Queue(findWorkspaceVariableByVariableIDSQL, variableID)
}

// FindWorkspaceVariableByVariableIDScan implements Querier.FindWorkspaceVariableByVariableIDScan.
func (q *DBQuerier) FindWorkspaceVariableByVariableIDScan(results pgx.BatchResults) (FindWorkspaceVariableByVariableIDRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceVariableByVariableIDRow
	variableRow := q.types.newVariables()
	if err := row.Scan(&item.WorkspaceID, variableRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceVariableByVariableIDBatch row: %w", err)
	}
	if err := variableRow.AssignTo(&item.Variable); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceVariableByVariableID row: %w", err)
	}
	return item, nil
}

const deleteWorkspaceVariableByIDSQL = `DELETE
FROM workspace_variables wv USING variables v
WHERE wv.variable_id = $1
RETURNING wv.workspace_id, (v.*)::"variables" AS variable;`

type DeleteWorkspaceVariableByIDRow struct {
	WorkspaceID pgtype.Text `json:"workspace_id"`
	Variable    *Variables  `json:"variable"`
}

// DeleteWorkspaceVariableByID implements Querier.DeleteWorkspaceVariableByID.
func (q *DBQuerier) DeleteWorkspaceVariableByID(ctx context.Context, variableID pgtype.Text) (DeleteWorkspaceVariableByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceVariableByID")
	row := q.conn.QueryRow(ctx, deleteWorkspaceVariableByIDSQL, variableID)
	var item DeleteWorkspaceVariableByIDRow
	variableRow := q.types.newVariables()
	if err := row.Scan(&item.WorkspaceID, variableRow); err != nil {
		return item, fmt.Errorf("query DeleteWorkspaceVariableByID: %w", err)
	}
	if err := variableRow.AssignTo(&item.Variable); err != nil {
		return item, fmt.Errorf("assign DeleteWorkspaceVariableByID row: %w", err)
	}
	return item, nil
}

// DeleteWorkspaceVariableByIDBatch implements Querier.DeleteWorkspaceVariableByIDBatch.
func (q *DBQuerier) DeleteWorkspaceVariableByIDBatch(batch genericBatch, variableID pgtype.Text) {
	batch.Queue(deleteWorkspaceVariableByIDSQL, variableID)
}

// DeleteWorkspaceVariableByIDScan implements Querier.DeleteWorkspaceVariableByIDScan.
func (q *DBQuerier) DeleteWorkspaceVariableByIDScan(results pgx.BatchResults) (DeleteWorkspaceVariableByIDRow, error) {
	row := results.QueryRow()
	var item DeleteWorkspaceVariableByIDRow
	variableRow := q.types.newVariables()
	if err := row.Scan(&item.WorkspaceID, variableRow); err != nil {
		return item, fmt.Errorf("scan DeleteWorkspaceVariableByIDBatch row: %w", err)
	}
	if err := variableRow.AssignTo(&item.Variable); err != nil {
		return item, fmt.Errorf("assign DeleteWorkspaceVariableByID row: %w", err)
	}
	return item, nil
}
