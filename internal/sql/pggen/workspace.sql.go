// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertWorkspaceSQL = `INSERT INTO workspaces (
    workspace_id,
    created_at,
    updated_at,
    allow_destroy_plan,
    auto_apply,
    branch,
    can_queue_destroy_plan,
    description,
    environment,
    execution_mode,
    file_triggers_enabled,
    global_remote_state,
    migration_environment,
    name,
    queue_all_runs,
    speculative_enabled,
    source_name,
    source_url,
    structured_run_output_enabled,
    terraform_version,
    trigger_prefixes,
    working_directory,
    organization_name
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20,
    $21,
    $22,
    $23
);`

type InsertWorkspaceParams struct {
	ID                         pgtype.Text
	CreatedAt                  pgtype.Timestamptz
	UpdatedAt                  pgtype.Timestamptz
	AllowDestroyPlan           bool
	AutoApply                  bool
	Branch                     pgtype.Text
	CanQueueDestroyPlan        bool
	Description                pgtype.Text
	Environment                pgtype.Text
	ExecutionMode              pgtype.Text
	FileTriggersEnabled        bool
	GlobalRemoteState          bool
	MigrationEnvironment       pgtype.Text
	Name                       pgtype.Text
	QueueAllRuns               bool
	SpeculativeEnabled         bool
	SourceName                 pgtype.Text
	SourceURL                  pgtype.Text
	StructuredRunOutputEnabled bool
	TerraformVersion           pgtype.Text
	TriggerPrefixes            []string
	WorkingDirectory           pgtype.Text
	OrganizationName           pgtype.Text
}

// InsertWorkspace implements Querier.InsertWorkspace.
func (q *DBQuerier) InsertWorkspace(ctx context.Context, params InsertWorkspaceParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspace")
	cmdTag, err := q.conn.Exec(ctx, insertWorkspaceSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.AllowDestroyPlan, params.AutoApply, params.Branch, params.CanQueueDestroyPlan, params.Description, params.Environment, params.ExecutionMode, params.FileTriggersEnabled, params.GlobalRemoteState, params.MigrationEnvironment, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.SourceName, params.SourceURL, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.WorkingDirectory, params.OrganizationName)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertWorkspace: %w", err)
	}
	return cmdTag, err
}

// InsertWorkspaceBatch implements Querier.InsertWorkspaceBatch.
func (q *DBQuerier) InsertWorkspaceBatch(batch genericBatch, params InsertWorkspaceParams) {
	batch.Queue(insertWorkspaceSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.AllowDestroyPlan, params.AutoApply, params.Branch, params.CanQueueDestroyPlan, params.Description, params.Environment, params.ExecutionMode, params.FileTriggersEnabled, params.GlobalRemoteState, params.MigrationEnvironment, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.SourceName, params.SourceURL, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.WorkingDirectory, params.OrganizationName)
}

// InsertWorkspaceScan implements Querier.InsertWorkspaceScan.
func (q *DBQuerier) InsertWorkspaceScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertWorkspaceBatch: %w", err)
	}
	return cmdTag, err
}

const findWorkspacesSQL = `SELECT
    w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (
        SELECT (u.*)::"users"
        FROM users u
        WHERE u.username = w.lock_username
    ) AS user_lock,
    (
        SELECT (rl.*)::"runs"
        FROM runs rl
        WHERE rl.run_id = w.lock_run_id
    ) AS run_lock,
    (
        SELECT (rc.*)::"repo_connections"
        FROM repo_connections rc
        WHERE rc.workspace_id = w.workspace_id
    ) AS workspace_connection,
    (
        SELECT (wh.*)::"webhooks"
        FROM webhooks wh
        JOIN repo_connections rc USING (webhook_id)
        WHERE rc.workspace_id = w.workspace_id
    ) AS webhook
FROM workspaces w
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN (workspace_tags wt JOIN tags t USING (tag_id)) ON wt.workspace_id = w.workspace_id
WHERE w.name                LIKE '%' || $1 || '%'
AND   w.organization_name   LIKE ANY($2)
GROUP BY w.workspace_id, r.status
HAVING array_agg(t.name) @> $3
ORDER BY w.updated_at DESC
LIMIT $4
OFFSET $5
;`

type FindWorkspacesParams struct {
	Search            pgtype.Text
	OrganizationNames []string
	Tags              []string
	Limit             int
	Offset            int
}

type FindWorkspacesRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           bool               `json:"allow_destroy_plan"`
	AutoApply                  bool               `json:"auto_apply"`
	CanQueueDestroyPlan        bool               `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	FileTriggersEnabled        bool               `json:"file_triggers_enabled"`
	GlobalRemoteState          bool               `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               bool               `json:"queue_all_runs"`
	SpeculativeEnabled         bool               `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled bool               `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
	Webhook                    *Webhooks          `json:"webhook"`
}

// FindWorkspaces implements Querier.FindWorkspaces.
func (q *DBQuerier) FindWorkspaces(ctx context.Context, params FindWorkspacesParams) ([]FindWorkspacesRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaces")
	rows, err := q.conn.Query(ctx, findWorkspacesSQL, params.Search, params.OrganizationNames, params.Tags, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaces: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspacesRow{}
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	for rows.Next() {
		var item FindWorkspacesRow
		if err := rows.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
			return nil, fmt.Errorf("scan FindWorkspaces row: %w", err)
		}
		if err := userLockRow.AssignTo(&item.UserLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		if err := runLockRow.AssignTo(&item.RunLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		if err := webhookRow.AssignTo(&item.Webhook); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspaces rows: %w", err)
	}
	return items, err
}

// FindWorkspacesBatch implements Querier.FindWorkspacesBatch.
func (q *DBQuerier) FindWorkspacesBatch(batch genericBatch, params FindWorkspacesParams) {
	batch.Queue(findWorkspacesSQL, params.Search, params.OrganizationNames, params.Tags, params.Limit, params.Offset)
}

// FindWorkspacesScan implements Querier.FindWorkspacesScan.
func (q *DBQuerier) FindWorkspacesScan(results pgx.BatchResults) ([]FindWorkspacesRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspacesBatch: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspacesRow{}
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	for rows.Next() {
		var item FindWorkspacesRow
		if err := rows.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
			return nil, fmt.Errorf("scan FindWorkspacesBatch row: %w", err)
		}
		if err := userLockRow.AssignTo(&item.UserLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		if err := runLockRow.AssignTo(&item.RunLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		if err := webhookRow.AssignTo(&item.Webhook); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspacesBatch rows: %w", err)
	}
	return items, err
}

const countWorkspacesSQL = `SELECT count(distinct(w.workspace_id))
FROM workspaces w
LEFT JOIN (workspace_tags wt JOIN tags t USING (tag_id)) ON w.workspace_id = wt.workspace_id
WHERE w.name              LIKE '%' || $1 || '%'
AND   w.organization_name LIKE ANY($2)
AND   CASE WHEN cardinality($3::text[]) > 0 THEN t.name LIKE ANY($3)
      ELSE 1 = 1
      END
;`

type CountWorkspacesParams struct {
	Search            pgtype.Text
	OrganizationNames []string
	Tags              []string
}

// CountWorkspaces implements Querier.CountWorkspaces.
func (q *DBQuerier) CountWorkspaces(ctx context.Context, params CountWorkspacesParams) (int, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountWorkspaces")
	row := q.conn.QueryRow(ctx, countWorkspacesSQL, params.Search, params.OrganizationNames, params.Tags)
	var item int
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query CountWorkspaces: %w", err)
	}
	return item, nil
}

// CountWorkspacesBatch implements Querier.CountWorkspacesBatch.
func (q *DBQuerier) CountWorkspacesBatch(batch genericBatch, params CountWorkspacesParams) {
	batch.Queue(countWorkspacesSQL, params.Search, params.OrganizationNames, params.Tags)
}

// CountWorkspacesScan implements Querier.CountWorkspacesScan.
func (q *DBQuerier) CountWorkspacesScan(results pgx.BatchResults) (int, error) {
	row := results.QueryRow()
	var item int
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan CountWorkspacesBatch row: %w", err)
	}
	return item, nil
}

const findWorkspacesByWebhookIDSQL = `SELECT
    w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (vr.*)::"repo_connections" AS workspace_connection,
    (h.*)::"webhooks" AS webhook
FROM workspaces w
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
JOIN (repo_connections vr JOIN webhooks h USING (webhook_id)) ON w.workspace_id = vr.workspace_id
WHERE h.webhook_id = $1
;`

type FindWorkspacesByWebhookIDRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           bool               `json:"allow_destroy_plan"`
	AutoApply                  bool               `json:"auto_apply"`
	CanQueueDestroyPlan        bool               `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	FileTriggersEnabled        bool               `json:"file_triggers_enabled"`
	GlobalRemoteState          bool               `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               bool               `json:"queue_all_runs"`
	SpeculativeEnabled         bool               `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled bool               `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
	Webhook                    *Webhooks          `json:"webhook"`
}

// FindWorkspacesByWebhookID implements Querier.FindWorkspacesByWebhookID.
func (q *DBQuerier) FindWorkspacesByWebhookID(ctx context.Context, webhookID pgtype.UUID) ([]FindWorkspacesByWebhookIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspacesByWebhookID")
	rows, err := q.conn.Query(ctx, findWorkspacesByWebhookIDSQL, webhookID)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspacesByWebhookID: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspacesByWebhookIDRow{}
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	for rows.Next() {
		var item FindWorkspacesByWebhookIDRow
		if err := rows.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
			return nil, fmt.Errorf("scan FindWorkspacesByWebhookID row: %w", err)
		}
		if err := userLockRow.AssignTo(&item.UserLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByWebhookID row: %w", err)
		}
		if err := runLockRow.AssignTo(&item.RunLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByWebhookID row: %w", err)
		}
		if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByWebhookID row: %w", err)
		}
		if err := webhookRow.AssignTo(&item.Webhook); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByWebhookID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspacesByWebhookID rows: %w", err)
	}
	return items, err
}

// FindWorkspacesByWebhookIDBatch implements Querier.FindWorkspacesByWebhookIDBatch.
func (q *DBQuerier) FindWorkspacesByWebhookIDBatch(batch genericBatch, webhookID pgtype.UUID) {
	batch.Queue(findWorkspacesByWebhookIDSQL, webhookID)
}

// FindWorkspacesByWebhookIDScan implements Querier.FindWorkspacesByWebhookIDScan.
func (q *DBQuerier) FindWorkspacesByWebhookIDScan(results pgx.BatchResults) ([]FindWorkspacesByWebhookIDRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspacesByWebhookIDBatch: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspacesByWebhookIDRow{}
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	for rows.Next() {
		var item FindWorkspacesByWebhookIDRow
		if err := rows.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
			return nil, fmt.Errorf("scan FindWorkspacesByWebhookIDBatch row: %w", err)
		}
		if err := userLockRow.AssignTo(&item.UserLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByWebhookID row: %w", err)
		}
		if err := runLockRow.AssignTo(&item.RunLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByWebhookID row: %w", err)
		}
		if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByWebhookID row: %w", err)
		}
		if err := webhookRow.AssignTo(&item.Webhook); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByWebhookID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspacesByWebhookIDBatch rows: %w", err)
	}
	return items, err
}

const findWorkspacesByUsernameSQL = `SELECT
    w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (vr.*)::"repo_connections" AS workspace_connection,
    (h.*)::"webhooks" AS webhook
FROM workspaces w
JOIN workspace_permissions p USING (workspace_id)
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN (repo_connections vr JOIN webhooks h USING (webhook_id)) ON w.workspace_id = vr.workspace_id
JOIN teams t USING (team_id)
JOIN team_memberships tm USING (team_id)
JOIN users u ON tm.username = u.username
WHERE w.organization_name  = $1
AND   u.username           = $2
ORDER BY w.updated_at DESC
LIMIT $3
OFFSET $4
;`

type FindWorkspacesByUsernameParams struct {
	OrganizationName pgtype.Text
	Username         pgtype.Text
	Limit            int
	Offset           int
}

type FindWorkspacesByUsernameRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           bool               `json:"allow_destroy_plan"`
	AutoApply                  bool               `json:"auto_apply"`
	CanQueueDestroyPlan        bool               `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	FileTriggersEnabled        bool               `json:"file_triggers_enabled"`
	GlobalRemoteState          bool               `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               bool               `json:"queue_all_runs"`
	SpeculativeEnabled         bool               `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled bool               `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
	Webhook                    *Webhooks          `json:"webhook"`
}

// FindWorkspacesByUsername implements Querier.FindWorkspacesByUsername.
func (q *DBQuerier) FindWorkspacesByUsername(ctx context.Context, params FindWorkspacesByUsernameParams) ([]FindWorkspacesByUsernameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspacesByUsername")
	rows, err := q.conn.Query(ctx, findWorkspacesByUsernameSQL, params.OrganizationName, params.Username, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspacesByUsername: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspacesByUsernameRow{}
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	for rows.Next() {
		var item FindWorkspacesByUsernameRow
		if err := rows.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
			return nil, fmt.Errorf("scan FindWorkspacesByUsername row: %w", err)
		}
		if err := userLockRow.AssignTo(&item.UserLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByUsername row: %w", err)
		}
		if err := runLockRow.AssignTo(&item.RunLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByUsername row: %w", err)
		}
		if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByUsername row: %w", err)
		}
		if err := webhookRow.AssignTo(&item.Webhook); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByUsername row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspacesByUsername rows: %w", err)
	}
	return items, err
}

// FindWorkspacesByUsernameBatch implements Querier.FindWorkspacesByUsernameBatch.
func (q *DBQuerier) FindWorkspacesByUsernameBatch(batch genericBatch, params FindWorkspacesByUsernameParams) {
	batch.Queue(findWorkspacesByUsernameSQL, params.OrganizationName, params.Username, params.Limit, params.Offset)
}

// FindWorkspacesByUsernameScan implements Querier.FindWorkspacesByUsernameScan.
func (q *DBQuerier) FindWorkspacesByUsernameScan(results pgx.BatchResults) ([]FindWorkspacesByUsernameRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspacesByUsernameBatch: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspacesByUsernameRow{}
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	for rows.Next() {
		var item FindWorkspacesByUsernameRow
		if err := rows.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
			return nil, fmt.Errorf("scan FindWorkspacesByUsernameBatch row: %w", err)
		}
		if err := userLockRow.AssignTo(&item.UserLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByUsername row: %w", err)
		}
		if err := runLockRow.AssignTo(&item.RunLock); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByUsername row: %w", err)
		}
		if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByUsername row: %w", err)
		}
		if err := webhookRow.AssignTo(&item.Webhook); err != nil {
			return nil, fmt.Errorf("assign FindWorkspacesByUsername row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspacesByUsernameBatch rows: %w", err)
	}
	return items, err
}

const countWorkspacesByUsernameSQL = `SELECT count(*)
FROM workspaces w
JOIN workspace_permissions p USING (workspace_id)
JOIN teams t USING (team_id)
JOIN team_memberships tm USING (team_id)
JOIN users u USING (username)
WHERE w.organization_name = $1
AND   u.username          = $2
;`

// CountWorkspacesByUsername implements Querier.CountWorkspacesByUsername.
func (q *DBQuerier) CountWorkspacesByUsername(ctx context.Context, organizationName pgtype.Text, username pgtype.Text) (int, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountWorkspacesByUsername")
	row := q.conn.QueryRow(ctx, countWorkspacesByUsernameSQL, organizationName, username)
	var item int
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query CountWorkspacesByUsername: %w", err)
	}
	return item, nil
}

// CountWorkspacesByUsernameBatch implements Querier.CountWorkspacesByUsernameBatch.
func (q *DBQuerier) CountWorkspacesByUsernameBatch(batch genericBatch, organizationName pgtype.Text, username pgtype.Text) {
	batch.Queue(countWorkspacesByUsernameSQL, organizationName, username)
}

// CountWorkspacesByUsernameScan implements Querier.CountWorkspacesByUsernameScan.
func (q *DBQuerier) CountWorkspacesByUsernameScan(results pgx.BatchResults) (int, error) {
	row := results.QueryRow()
	var item int
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan CountWorkspacesByUsernameBatch row: %w", err)
	}
	return item, nil
}

const findWorkspaceByNameSQL = `SELECT w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (vr.*)::"repo_connections" AS workspace_connection,
    (h.*)::"webhooks" AS webhook
FROM workspaces w
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN (repo_connections vr JOIN webhooks h USING (webhook_id)) ON w.workspace_id = vr.workspace_id
WHERE w.name              = $1
AND   w.organization_name = $2
;`

type FindWorkspaceByNameRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           bool               `json:"allow_destroy_plan"`
	AutoApply                  bool               `json:"auto_apply"`
	CanQueueDestroyPlan        bool               `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	FileTriggersEnabled        bool               `json:"file_triggers_enabled"`
	GlobalRemoteState          bool               `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               bool               `json:"queue_all_runs"`
	SpeculativeEnabled         bool               `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled bool               `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
	Webhook                    *Webhooks          `json:"webhook"`
}

// FindWorkspaceByName implements Querier.FindWorkspaceByName.
func (q *DBQuerier) FindWorkspaceByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindWorkspaceByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByName")
	row := q.conn.QueryRow(ctx, findWorkspaceByNameSQL, name, organizationName)
	var item FindWorkspaceByNameRow
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceByName: %w", err)
	}
	if err := userLockRow.AssignTo(&item.UserLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	if err := runLockRow.AssignTo(&item.RunLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	if err := webhookRow.AssignTo(&item.Webhook); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	return item, nil
}

// FindWorkspaceByNameBatch implements Querier.FindWorkspaceByNameBatch.
func (q *DBQuerier) FindWorkspaceByNameBatch(batch genericBatch, name pgtype.Text, organizationName pgtype.Text) {
	batch.Queue(findWorkspaceByNameSQL, name, organizationName)
}

// FindWorkspaceByNameScan implements Querier.FindWorkspaceByNameScan.
func (q *DBQuerier) FindWorkspaceByNameScan(results pgx.BatchResults) (FindWorkspaceByNameRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceByNameRow
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceByNameBatch row: %w", err)
	}
	if err := userLockRow.AssignTo(&item.UserLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	if err := runLockRow.AssignTo(&item.RunLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	if err := webhookRow.AssignTo(&item.Webhook); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	return item, nil
}

const findWorkspaceByIDSQL = `SELECT w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (vr.*)::"repo_connections" AS workspace_connection,
    (h.*)::"webhooks" AS webhook
FROM workspaces w
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN (repo_connections vr JOIN webhooks h USING (webhook_id)) ON w.workspace_id = vr.workspace_id
WHERE w.workspace_id = $1
;`

type FindWorkspaceByIDRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           bool               `json:"allow_destroy_plan"`
	AutoApply                  bool               `json:"auto_apply"`
	CanQueueDestroyPlan        bool               `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	FileTriggersEnabled        bool               `json:"file_triggers_enabled"`
	GlobalRemoteState          bool               `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               bool               `json:"queue_all_runs"`
	SpeculativeEnabled         bool               `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled bool               `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
	Webhook                    *Webhooks          `json:"webhook"`
}

// FindWorkspaceByID implements Querier.FindWorkspaceByID.
func (q *DBQuerier) FindWorkspaceByID(ctx context.Context, id pgtype.Text) (FindWorkspaceByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByID")
	row := q.conn.QueryRow(ctx, findWorkspaceByIDSQL, id)
	var item FindWorkspaceByIDRow
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceByID: %w", err)
	}
	if err := userLockRow.AssignTo(&item.UserLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	if err := runLockRow.AssignTo(&item.RunLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	if err := webhookRow.AssignTo(&item.Webhook); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	return item, nil
}

// FindWorkspaceByIDBatch implements Querier.FindWorkspaceByIDBatch.
func (q *DBQuerier) FindWorkspaceByIDBatch(batch genericBatch, id pgtype.Text) {
	batch.Queue(findWorkspaceByIDSQL, id)
}

// FindWorkspaceByIDScan implements Querier.FindWorkspaceByIDScan.
func (q *DBQuerier) FindWorkspaceByIDScan(results pgx.BatchResults) (FindWorkspaceByIDRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceByIDRow
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceByIDBatch row: %w", err)
	}
	if err := userLockRow.AssignTo(&item.UserLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	if err := runLockRow.AssignTo(&item.RunLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	if err := webhookRow.AssignTo(&item.Webhook); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	return item, nil
}

const findWorkspaceByIDForUpdateSQL = `SELECT w.*,
    (
        SELECT array_agg(name)
        FROM tags
        JOIN workspace_tags wt USING (tag_id)
        WHERE wt.workspace_id = w.workspace_id
    ) AS tags,
    r.status AS latest_run_status,
    (ul.*)::"users" AS user_lock,
    (rl.*)::"runs" AS run_lock,
    (vr.*)::"repo_connections" AS workspace_connection,
    (h.*)::"webhooks" AS webhook
FROM workspaces w
LEFT JOIN users ul ON w.lock_username = ul.username
LEFT JOIN runs rl ON w.lock_run_id = rl.run_id
LEFT JOIN runs r ON w.latest_run_id = r.run_id
LEFT JOIN (repo_connections vr JOIN webhooks h USING (webhook_id)) ON w.workspace_id = vr.workspace_id
WHERE w.workspace_id = $1
FOR UPDATE OF w;`

type FindWorkspaceByIDForUpdateRow struct {
	WorkspaceID                pgtype.Text        `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           bool               `json:"allow_destroy_plan"`
	AutoApply                  bool               `json:"auto_apply"`
	CanQueueDestroyPlan        bool               `json:"can_queue_destroy_plan"`
	Description                pgtype.Text        `json:"description"`
	Environment                pgtype.Text        `json:"environment"`
	ExecutionMode              pgtype.Text        `json:"execution_mode"`
	FileTriggersEnabled        bool               `json:"file_triggers_enabled"`
	GlobalRemoteState          bool               `json:"global_remote_state"`
	MigrationEnvironment       pgtype.Text        `json:"migration_environment"`
	Name                       pgtype.Text        `json:"name"`
	QueueAllRuns               bool               `json:"queue_all_runs"`
	SpeculativeEnabled         bool               `json:"speculative_enabled"`
	SourceName                 pgtype.Text        `json:"source_name"`
	SourceURL                  pgtype.Text        `json:"source_url"`
	StructuredRunOutputEnabled bool               `json:"structured_run_output_enabled"`
	TerraformVersion           pgtype.Text        `json:"terraform_version"`
	TriggerPrefixes            []string           `json:"trigger_prefixes"`
	WorkingDirectory           pgtype.Text        `json:"working_directory"`
	LockRunID                  pgtype.Text        `json:"lock_run_id"`
	LatestRunID                pgtype.Text        `json:"latest_run_id"`
	OrganizationName           pgtype.Text        `json:"organization_name"`
	Branch                     pgtype.Text        `json:"branch"`
	LockUsername               pgtype.Text        `json:"lock_username"`
	CurrentStateVersionID      pgtype.Text        `json:"current_state_version_id"`
	Tags                       []string           `json:"tags"`
	LatestRunStatus            pgtype.Text        `json:"latest_run_status"`
	UserLock                   *Users             `json:"user_lock"`
	RunLock                    *Runs              `json:"run_lock"`
	WorkspaceConnection        *RepoConnections   `json:"workspace_connection"`
	Webhook                    *Webhooks          `json:"webhook"`
}

// FindWorkspaceByIDForUpdate implements Querier.FindWorkspaceByIDForUpdate.
func (q *DBQuerier) FindWorkspaceByIDForUpdate(ctx context.Context, id pgtype.Text) (FindWorkspaceByIDForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByIDForUpdate")
	row := q.conn.QueryRow(ctx, findWorkspaceByIDForUpdateSQL, id)
	var item FindWorkspaceByIDForUpdateRow
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceByIDForUpdate: %w", err)
	}
	if err := userLockRow.AssignTo(&item.UserLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	if err := runLockRow.AssignTo(&item.RunLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	if err := webhookRow.AssignTo(&item.Webhook); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	return item, nil
}

// FindWorkspaceByIDForUpdateBatch implements Querier.FindWorkspaceByIDForUpdateBatch.
func (q *DBQuerier) FindWorkspaceByIDForUpdateBatch(batch genericBatch, id pgtype.Text) {
	batch.Queue(findWorkspaceByIDForUpdateSQL, id)
}

// FindWorkspaceByIDForUpdateScan implements Querier.FindWorkspaceByIDForUpdateScan.
func (q *DBQuerier) FindWorkspaceByIDForUpdateScan(results pgx.BatchResults) (FindWorkspaceByIDForUpdateRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceByIDForUpdateRow
	userLockRow := q.types.newUsers()
	runLockRow := q.types.newRuns()
	workspaceConnectionRow := q.types.newRepoConnections()
	webhookRow := q.types.newWebhooks()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.LockRunID, &item.LatestRunID, &item.OrganizationName, &item.Branch, &item.LockUsername, &item.CurrentStateVersionID, &item.Tags, &item.LatestRunStatus, userLockRow, runLockRow, workspaceConnectionRow, webhookRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceByIDForUpdateBatch row: %w", err)
	}
	if err := userLockRow.AssignTo(&item.UserLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	if err := runLockRow.AssignTo(&item.RunLock); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	if err := workspaceConnectionRow.AssignTo(&item.WorkspaceConnection); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	if err := webhookRow.AssignTo(&item.Webhook); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	return item, nil
}

const updateWorkspaceByIDSQL = `UPDATE workspaces
SET
    allow_destroy_plan              = $1,
    auto_apply                      = $2,
    branch                          = $3,
    description                     = $4,
    execution_mode                  = $5,
    name                            = $6,
    queue_all_runs                  = $7,
    speculative_enabled             = $8,
    structured_run_output_enabled   = $9,
    terraform_version               = $10,
    trigger_prefixes                = $11,
    working_directory               = $12,
    updated_at                      = $13
WHERE workspace_id = $14
RETURNING workspace_id;`

type UpdateWorkspaceByIDParams struct {
	AllowDestroyPlan           bool
	AutoApply                  bool
	Branch                     pgtype.Text
	Description                pgtype.Text
	ExecutionMode              pgtype.Text
	Name                       pgtype.Text
	QueueAllRuns               bool
	SpeculativeEnabled         bool
	StructuredRunOutputEnabled bool
	TerraformVersion           pgtype.Text
	TriggerPrefixes            []string
	WorkingDirectory           pgtype.Text
	UpdatedAt                  pgtype.Timestamptz
	ID                         pgtype.Text
}

// UpdateWorkspaceByID implements Querier.UpdateWorkspaceByID.
func (q *DBQuerier) UpdateWorkspaceByID(ctx context.Context, params UpdateWorkspaceByIDParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWorkspaceByID")
	row := q.conn.QueryRow(ctx, updateWorkspaceByIDSQL, params.AllowDestroyPlan, params.AutoApply, params.Branch, params.Description, params.ExecutionMode, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.WorkingDirectory, params.UpdatedAt, params.ID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateWorkspaceByID: %w", err)
	}
	return item, nil
}

// UpdateWorkspaceByIDBatch implements Querier.UpdateWorkspaceByIDBatch.
func (q *DBQuerier) UpdateWorkspaceByIDBatch(batch genericBatch, params UpdateWorkspaceByIDParams) {
	batch.Queue(updateWorkspaceByIDSQL, params.AllowDestroyPlan, params.AutoApply, params.Branch, params.Description, params.ExecutionMode, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.WorkingDirectory, params.UpdatedAt, params.ID)
}

// UpdateWorkspaceByIDScan implements Querier.UpdateWorkspaceByIDScan.
func (q *DBQuerier) UpdateWorkspaceByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateWorkspaceByIDBatch row: %w", err)
	}
	return item, nil
}

const updateWorkspaceLockByIDSQL = `UPDATE workspaces
SET
    lock_username = $1,
    lock_run_id = $2
WHERE workspace_id = $3;`

type UpdateWorkspaceLockByIDParams struct {
	Username    pgtype.Text
	RunID       pgtype.Text
	WorkspaceID pgtype.Text
}

// UpdateWorkspaceLockByID implements Querier.UpdateWorkspaceLockByID.
func (q *DBQuerier) UpdateWorkspaceLockByID(ctx context.Context, params UpdateWorkspaceLockByIDParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWorkspaceLockByID")
	cmdTag, err := q.conn.Exec(ctx, updateWorkspaceLockByIDSQL, params.Username, params.RunID, params.WorkspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query UpdateWorkspaceLockByID: %w", err)
	}
	return cmdTag, err
}

// UpdateWorkspaceLockByIDBatch implements Querier.UpdateWorkspaceLockByIDBatch.
func (q *DBQuerier) UpdateWorkspaceLockByIDBatch(batch genericBatch, params UpdateWorkspaceLockByIDParams) {
	batch.Queue(updateWorkspaceLockByIDSQL, params.Username, params.RunID, params.WorkspaceID)
}

// UpdateWorkspaceLockByIDScan implements Querier.UpdateWorkspaceLockByIDScan.
func (q *DBQuerier) UpdateWorkspaceLockByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec UpdateWorkspaceLockByIDBatch: %w", err)
	}
	return cmdTag, err
}

const updateWorkspaceLatestRunSQL = `UPDATE workspaces
SET latest_run_id = $1
WHERE workspace_id = $2;`

// UpdateWorkspaceLatestRun implements Querier.UpdateWorkspaceLatestRun.
func (q *DBQuerier) UpdateWorkspaceLatestRun(ctx context.Context, runID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWorkspaceLatestRun")
	cmdTag, err := q.conn.Exec(ctx, updateWorkspaceLatestRunSQL, runID, workspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query UpdateWorkspaceLatestRun: %w", err)
	}
	return cmdTag, err
}

// UpdateWorkspaceLatestRunBatch implements Querier.UpdateWorkspaceLatestRunBatch.
func (q *DBQuerier) UpdateWorkspaceLatestRunBatch(batch genericBatch, runID pgtype.Text, workspaceID pgtype.Text) {
	batch.Queue(updateWorkspaceLatestRunSQL, runID, workspaceID)
}

// UpdateWorkspaceLatestRunScan implements Querier.UpdateWorkspaceLatestRunScan.
func (q *DBQuerier) UpdateWorkspaceLatestRunScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec UpdateWorkspaceLatestRunBatch: %w", err)
	}
	return cmdTag, err
}

const updateWorkspaceCurrentStateVersionIDSQL = `UPDATE workspaces
SET current_state_version_id = $1
WHERE workspace_id = $2
RETURNING workspace_id;`

// UpdateWorkspaceCurrentStateVersionID implements Querier.UpdateWorkspaceCurrentStateVersionID.
func (q *DBQuerier) UpdateWorkspaceCurrentStateVersionID(ctx context.Context, stateVersionID pgtype.Text, workspaceID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWorkspaceCurrentStateVersionID")
	row := q.conn.QueryRow(ctx, updateWorkspaceCurrentStateVersionIDSQL, stateVersionID, workspaceID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateWorkspaceCurrentStateVersionID: %w", err)
	}
	return item, nil
}

// UpdateWorkspaceCurrentStateVersionIDBatch implements Querier.UpdateWorkspaceCurrentStateVersionIDBatch.
func (q *DBQuerier) UpdateWorkspaceCurrentStateVersionIDBatch(batch genericBatch, stateVersionID pgtype.Text, workspaceID pgtype.Text) {
	batch.Queue(updateWorkspaceCurrentStateVersionIDSQL, stateVersionID, workspaceID)
}

// UpdateWorkspaceCurrentStateVersionIDScan implements Querier.UpdateWorkspaceCurrentStateVersionIDScan.
func (q *DBQuerier) UpdateWorkspaceCurrentStateVersionIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateWorkspaceCurrentStateVersionIDBatch row: %w", err)
	}
	return item, nil
}

const deleteWorkspaceByIDSQL = `DELETE
FROM workspaces
WHERE workspace_id = $1;`

// DeleteWorkspaceByID implements Querier.DeleteWorkspaceByID.
func (q *DBQuerier) DeleteWorkspaceByID(ctx context.Context, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceByID")
	cmdTag, err := q.conn.Exec(ctx, deleteWorkspaceByIDSQL, workspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteWorkspaceByID: %w", err)
	}
	return cmdTag, err
}

// DeleteWorkspaceByIDBatch implements Querier.DeleteWorkspaceByIDBatch.
func (q *DBQuerier) DeleteWorkspaceByIDBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(deleteWorkspaceByIDSQL, workspaceID)
}

// DeleteWorkspaceByIDScan implements Querier.DeleteWorkspaceByIDScan.
func (q *DBQuerier) DeleteWorkspaceByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteWorkspaceByIDBatch: %w", err)
	}
	return cmdTag, err
}
