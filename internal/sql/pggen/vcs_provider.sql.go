// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertVCSProviderSQL = `INSERT INTO vcs_providers (
    vcs_provider_id,
    created_at,
    name,
    cloud,
    token,
    github_app_id,
    organization_name
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
);`

type InsertVCSProviderParams struct {
	VCSProviderID    pgtype.Text
	CreatedAt        pgtype.Timestamptz
	Name             pgtype.Text
	Cloud            pgtype.Text
	Token            pgtype.Text
	GithubAppID      pgtype.Int8
	OrganizationName pgtype.Text
}

// InsertVCSProvider implements Querier.InsertVCSProvider.
func (q *DBQuerier) InsertVCSProvider(ctx context.Context, params InsertVCSProviderParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertVCSProvider")
	cmdTag, err := q.conn.Exec(ctx, insertVCSProviderSQL, params.VCSProviderID, params.CreatedAt, params.Name, params.Cloud, params.Token, params.GithubAppID, params.OrganizationName)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertVCSProvider: %w", err)
	}
	return cmdTag, err
}

// InsertVCSProviderBatch implements Querier.InsertVCSProviderBatch.
func (q *DBQuerier) InsertVCSProviderBatch(batch genericBatch, params InsertVCSProviderParams) {
	batch.Queue(insertVCSProviderSQL, params.VCSProviderID, params.CreatedAt, params.Name, params.Cloud, params.Token, params.GithubAppID, params.OrganizationName)
}

// InsertVCSProviderScan implements Querier.InsertVCSProviderScan.
func (q *DBQuerier) InsertVCSProviderScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertVCSProviderBatch: %w", err)
	}
	return cmdTag, err
}

const findVCSProvidersByOrganizationSQL = `SELECT *
FROM vcs_providers
LEFT JOIN github_apps USING (github_app_id)
WHERE organization_name = $1
;`

type FindVCSProvidersByOrganizationRow struct {
	GithubAppID      pgtype.Int8        `json:"github_app_id"`
	VCSProviderID    pgtype.Text        `json:"vcs_provider_id"`
	Token            pgtype.Text        `json:"token"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	Name             pgtype.Text        `json:"name"`
	Cloud            pgtype.Text        `json:"cloud"`
	OrganizationName pgtype.Text        `json:"organization_name"`
	WebhookSecret    pgtype.Text        `json:"webhook_secret"`
	PrivateKey       pgtype.Text        `json:"private_key"`
}

// FindVCSProvidersByOrganization implements Querier.FindVCSProvidersByOrganization.
func (q *DBQuerier) FindVCSProvidersByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindVCSProvidersByOrganizationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindVCSProvidersByOrganization")
	rows, err := q.conn.Query(ctx, findVCSProvidersByOrganizationSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindVCSProvidersByOrganization: %w", err)
	}
	defer rows.Close()
	items := []FindVCSProvidersByOrganizationRow{}
	for rows.Next() {
		var item FindVCSProvidersByOrganizationRow
		if err := rows.Scan(&item.GithubAppID, &item.VCSProviderID, &item.Token, &item.CreatedAt, &item.Name, &item.Cloud, &item.OrganizationName, &item.WebhookSecret, &item.PrivateKey); err != nil {
			return nil, fmt.Errorf("scan FindVCSProvidersByOrganization row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindVCSProvidersByOrganization rows: %w", err)
	}
	return items, err
}

// FindVCSProvidersByOrganizationBatch implements Querier.FindVCSProvidersByOrganizationBatch.
func (q *DBQuerier) FindVCSProvidersByOrganizationBatch(batch genericBatch, organizationName pgtype.Text) {
	batch.Queue(findVCSProvidersByOrganizationSQL, organizationName)
}

// FindVCSProvidersByOrganizationScan implements Querier.FindVCSProvidersByOrganizationScan.
func (q *DBQuerier) FindVCSProvidersByOrganizationScan(results pgx.BatchResults) ([]FindVCSProvidersByOrganizationRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindVCSProvidersByOrganizationBatch: %w", err)
	}
	defer rows.Close()
	items := []FindVCSProvidersByOrganizationRow{}
	for rows.Next() {
		var item FindVCSProvidersByOrganizationRow
		if err := rows.Scan(&item.GithubAppID, &item.VCSProviderID, &item.Token, &item.CreatedAt, &item.Name, &item.Cloud, &item.OrganizationName, &item.WebhookSecret, &item.PrivateKey); err != nil {
			return nil, fmt.Errorf("scan FindVCSProvidersByOrganizationBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindVCSProvidersByOrganizationBatch rows: %w", err)
	}
	return items, err
}

const findVCSProvidersSQL = `SELECT *
FROM vcs_providers
LEFT JOIN github_apps USING (github_app_id)
;`

type FindVCSProvidersRow struct {
	GithubAppID      pgtype.Int8        `json:"github_app_id"`
	VCSProviderID    pgtype.Text        `json:"vcs_provider_id"`
	Token            pgtype.Text        `json:"token"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	Name             pgtype.Text        `json:"name"`
	Cloud            pgtype.Text        `json:"cloud"`
	OrganizationName pgtype.Text        `json:"organization_name"`
	WebhookSecret    pgtype.Text        `json:"webhook_secret"`
	PrivateKey       pgtype.Text        `json:"private_key"`
}

// FindVCSProviders implements Querier.FindVCSProviders.
func (q *DBQuerier) FindVCSProviders(ctx context.Context) ([]FindVCSProvidersRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindVCSProviders")
	rows, err := q.conn.Query(ctx, findVCSProvidersSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindVCSProviders: %w", err)
	}
	defer rows.Close()
	items := []FindVCSProvidersRow{}
	for rows.Next() {
		var item FindVCSProvidersRow
		if err := rows.Scan(&item.GithubAppID, &item.VCSProviderID, &item.Token, &item.CreatedAt, &item.Name, &item.Cloud, &item.OrganizationName, &item.WebhookSecret, &item.PrivateKey); err != nil {
			return nil, fmt.Errorf("scan FindVCSProviders row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindVCSProviders rows: %w", err)
	}
	return items, err
}

// FindVCSProvidersBatch implements Querier.FindVCSProvidersBatch.
func (q *DBQuerier) FindVCSProvidersBatch(batch genericBatch) {
	batch.Queue(findVCSProvidersSQL)
}

// FindVCSProvidersScan implements Querier.FindVCSProvidersScan.
func (q *DBQuerier) FindVCSProvidersScan(results pgx.BatchResults) ([]FindVCSProvidersRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindVCSProvidersBatch: %w", err)
	}
	defer rows.Close()
	items := []FindVCSProvidersRow{}
	for rows.Next() {
		var item FindVCSProvidersRow
		if err := rows.Scan(&item.GithubAppID, &item.VCSProviderID, &item.Token, &item.CreatedAt, &item.Name, &item.Cloud, &item.OrganizationName, &item.WebhookSecret, &item.PrivateKey); err != nil {
			return nil, fmt.Errorf("scan FindVCSProvidersBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindVCSProvidersBatch rows: %w", err)
	}
	return items, err
}

const findVCSProviderSQL = `SELECT *
FROM vcs_providers
LEFT JOIN github_apps USING (github_app_id)
WHERE vcs_provider_id = $1
;`

type FindVCSProviderRow struct {
	GithubAppID      pgtype.Int8        `json:"github_app_id"`
	VCSProviderID    pgtype.Text        `json:"vcs_provider_id"`
	Token            pgtype.Text        `json:"token"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	Name             pgtype.Text        `json:"name"`
	Cloud            pgtype.Text        `json:"cloud"`
	OrganizationName pgtype.Text        `json:"organization_name"`
	WebhookSecret    pgtype.Text        `json:"webhook_secret"`
	PrivateKey       pgtype.Text        `json:"private_key"`
}

// FindVCSProvider implements Querier.FindVCSProvider.
func (q *DBQuerier) FindVCSProvider(ctx context.Context, vcsProviderID pgtype.Text) (FindVCSProviderRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindVCSProvider")
	row := q.conn.QueryRow(ctx, findVCSProviderSQL, vcsProviderID)
	var item FindVCSProviderRow
	if err := row.Scan(&item.GithubAppID, &item.VCSProviderID, &item.Token, &item.CreatedAt, &item.Name, &item.Cloud, &item.OrganizationName, &item.WebhookSecret, &item.PrivateKey); err != nil {
		return item, fmt.Errorf("query FindVCSProvider: %w", err)
	}
	return item, nil
}

// FindVCSProviderBatch implements Querier.FindVCSProviderBatch.
func (q *DBQuerier) FindVCSProviderBatch(batch genericBatch, vcsProviderID pgtype.Text) {
	batch.Queue(findVCSProviderSQL, vcsProviderID)
}

// FindVCSProviderScan implements Querier.FindVCSProviderScan.
func (q *DBQuerier) FindVCSProviderScan(results pgx.BatchResults) (FindVCSProviderRow, error) {
	row := results.QueryRow()
	var item FindVCSProviderRow
	if err := row.Scan(&item.GithubAppID, &item.VCSProviderID, &item.Token, &item.CreatedAt, &item.Name, &item.Cloud, &item.OrganizationName, &item.WebhookSecret, &item.PrivateKey); err != nil {
		return item, fmt.Errorf("scan FindVCSProviderBatch row: %w", err)
	}
	return item, nil
}

const deleteVCSProviderByIDSQL = `DELETE
FROM vcs_providers
WHERE vcs_provider_id = $1
RETURNING vcs_provider_id
;`

// DeleteVCSProviderByID implements Querier.DeleteVCSProviderByID.
func (q *DBQuerier) DeleteVCSProviderByID(ctx context.Context, vcsProviderID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteVCSProviderByID")
	row := q.conn.QueryRow(ctx, deleteVCSProviderByIDSQL, vcsProviderID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteVCSProviderByID: %w", err)
	}
	return item, nil
}

// DeleteVCSProviderByIDBatch implements Querier.DeleteVCSProviderByIDBatch.
func (q *DBQuerier) DeleteVCSProviderByIDBatch(batch genericBatch, vcsProviderID pgtype.Text) {
	batch.Queue(deleteVCSProviderByIDSQL, vcsProviderID)
}

// DeleteVCSProviderByIDScan implements Querier.DeleteVCSProviderByIDScan.
func (q *DBQuerier) DeleteVCSProviderByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteVCSProviderByIDBatch row: %w", err)
	}
	return item, nil
}

const insertGithubAppSQL = `INSERT INTO github_apps (
    github_app_id,
    webhook_secret,
    private_key
) VALUES (
    $1,
    $2,
    $3
);`

type InsertGithubAppParams struct {
	GithubAppID   pgtype.Int8
	WebhookSecret pgtype.Text
	PrivateKey    pgtype.Text
}

// InsertGithubApp implements Querier.InsertGithubApp.
func (q *DBQuerier) InsertGithubApp(ctx context.Context, params InsertGithubAppParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertGithubApp")
	cmdTag, err := q.conn.Exec(ctx, insertGithubAppSQL, params.GithubAppID, params.WebhookSecret, params.PrivateKey)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertGithubApp: %w", err)
	}
	return cmdTag, err
}

// InsertGithubAppBatch implements Querier.InsertGithubAppBatch.
func (q *DBQuerier) InsertGithubAppBatch(batch genericBatch, params InsertGithubAppParams) {
	batch.Queue(insertGithubAppSQL, params.GithubAppID, params.WebhookSecret, params.PrivateKey)
}

// InsertGithubAppScan implements Querier.InsertGithubAppScan.
func (q *DBQuerier) InsertGithubAppScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertGithubAppBatch: %w", err)
	}
	return cmdTag, err
}

const findGithubAppByIDSQL = `SELECT *
FROM github_apps
WHERE github_app_id = $1;`

type FindGithubAppByIDRow struct {
	GithubAppID   pgtype.Int8 `json:"github_app_id"`
	WebhookSecret pgtype.Text `json:"webhook_secret"`
	PrivateKey    pgtype.Text `json:"private_key"`
}

// FindGithubAppByID implements Querier.FindGithubAppByID.
func (q *DBQuerier) FindGithubAppByID(ctx context.Context, githubAppID pgtype.Int8) (FindGithubAppByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindGithubAppByID")
	row := q.conn.QueryRow(ctx, findGithubAppByIDSQL, githubAppID)
	var item FindGithubAppByIDRow
	if err := row.Scan(&item.GithubAppID, &item.WebhookSecret, &item.PrivateKey); err != nil {
		return item, fmt.Errorf("query FindGithubAppByID: %w", err)
	}
	return item, nil
}

// FindGithubAppByIDBatch implements Querier.FindGithubAppByIDBatch.
func (q *DBQuerier) FindGithubAppByIDBatch(batch genericBatch, githubAppID pgtype.Int8) {
	batch.Queue(findGithubAppByIDSQL, githubAppID)
}

// FindGithubAppByIDScan implements Querier.FindGithubAppByIDScan.
func (q *DBQuerier) FindGithubAppByIDScan(results pgx.BatchResults) (FindGithubAppByIDRow, error) {
	row := results.QueryRow()
	var item FindGithubAppByIDRow
	if err := row.Scan(&item.GithubAppID, &item.WebhookSecret, &item.PrivateKey); err != nil {
		return item, fmt.Errorf("scan FindGithubAppByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteGithubAppByIDSQL = `DELETE
FROM github_apps
WHERE github_app_id = $1
RETURNING *;`

type DeleteGithubAppByIDRow struct {
	GithubAppID   pgtype.Int8 `json:"github_app_id"`
	WebhookSecret pgtype.Text `json:"webhook_secret"`
	PrivateKey    pgtype.Text `json:"private_key"`
}

// DeleteGithubAppByID implements Querier.DeleteGithubAppByID.
func (q *DBQuerier) DeleteGithubAppByID(ctx context.Context, githubAppID pgtype.Int8) (DeleteGithubAppByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteGithubAppByID")
	row := q.conn.QueryRow(ctx, deleteGithubAppByIDSQL, githubAppID)
	var item DeleteGithubAppByIDRow
	if err := row.Scan(&item.GithubAppID, &item.WebhookSecret, &item.PrivateKey); err != nil {
		return item, fmt.Errorf("query DeleteGithubAppByID: %w", err)
	}
	return item, nil
}

// DeleteGithubAppByIDBatch implements Querier.DeleteGithubAppByIDBatch.
func (q *DBQuerier) DeleteGithubAppByIDBatch(batch genericBatch, githubAppID pgtype.Int8) {
	batch.Queue(deleteGithubAppByIDSQL, githubAppID)
}

// DeleteGithubAppByIDScan implements Querier.DeleteGithubAppByIDScan.
func (q *DBQuerier) DeleteGithubAppByIDScan(results pgx.BatchResults) (DeleteGithubAppByIDRow, error) {
	row := results.QueryRow()
	var item DeleteGithubAppByIDRow
	if err := row.Scan(&item.GithubAppID, &item.WebhookSecret, &item.PrivateKey); err != nil {
		return item, fmt.Errorf("scan DeleteGithubAppByIDBatch row: %w", err)
	}
	return item, nil
}
