// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const allocateJobSQL = `UPDATE jobs
SET agent_id = $1
WHERE run_id = $2
AND   phase = $3
RETURNING *;`

type AllocateJobParams struct {
	AgentID pgtype.Text
	RunID   pgtype.Text
	Phase   pgtype.Text
}

type AllocateJobRow struct {
	RunID   pgtype.Text `json:"run_id"`
	Phase   pgtype.Text `json:"phase"`
	Status  pgtype.Text `json:"status"`
	AgentID pgtype.Text `json:"agent_id"`
}

// AllocateJob implements Querier.AllocateJob.
func (q *DBQuerier) AllocateJob(ctx context.Context, params AllocateJobParams) (AllocateJobRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "AllocateJob")
	row := q.conn.QueryRow(ctx, allocateJobSQL, params.AgentID, params.RunID, params.Phase)
	var item AllocateJobRow
	if err := row.Scan(&item.RunID, &item.Phase, &item.Status, &item.AgentID); err != nil {
		return item, fmt.Errorf("query AllocateJob: %w", err)
	}
	return item, nil
}

// AllocateJobBatch implements Querier.AllocateJobBatch.
func (q *DBQuerier) AllocateJobBatch(batch genericBatch, params AllocateJobParams) {
	batch.Queue(allocateJobSQL, params.AgentID, params.RunID, params.Phase)
}

// AllocateJobScan implements Querier.AllocateJobScan.
func (q *DBQuerier) AllocateJobScan(results pgx.BatchResults) (AllocateJobRow, error) {
	row := results.QueryRow()
	var item AllocateJobRow
	if err := row.Scan(&item.RunID, &item.Phase, &item.Status, &item.AgentID); err != nil {
		return item, fmt.Errorf("scan AllocateJobBatch row: %w", err)
	}
	return item, nil
}

const updateJobStatusSQL = `UPDATE jobs
SET status = $1
WHERE run_id = $2
AND   phase = $3
RETURNING *;`

type UpdateJobStatusParams struct {
	Status pgtype.Text
	RunID  pgtype.Text
	Phase  pgtype.Text
}

type UpdateJobStatusRow struct {
	RunID   pgtype.Text `json:"run_id"`
	Phase   pgtype.Text `json:"phase"`
	Status  pgtype.Text `json:"status"`
	AgentID pgtype.Text `json:"agent_id"`
}

// UpdateJobStatus implements Querier.UpdateJobStatus.
func (q *DBQuerier) UpdateJobStatus(ctx context.Context, params UpdateJobStatusParams) (UpdateJobStatusRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateJobStatus")
	row := q.conn.QueryRow(ctx, updateJobStatusSQL, params.Status, params.RunID, params.Phase)
	var item UpdateJobStatusRow
	if err := row.Scan(&item.RunID, &item.Phase, &item.Status, &item.AgentID); err != nil {
		return item, fmt.Errorf("query UpdateJobStatus: %w", err)
	}
	return item, nil
}

// UpdateJobStatusBatch implements Querier.UpdateJobStatusBatch.
func (q *DBQuerier) UpdateJobStatusBatch(batch genericBatch, params UpdateJobStatusParams) {
	batch.Queue(updateJobStatusSQL, params.Status, params.RunID, params.Phase)
}

// UpdateJobStatusScan implements Querier.UpdateJobStatusScan.
func (q *DBQuerier) UpdateJobStatusScan(results pgx.BatchResults) (UpdateJobStatusRow, error) {
	row := results.QueryRow()
	var item UpdateJobStatusRow
	if err := row.Scan(&item.RunID, &item.Phase, &item.Status, &item.AgentID); err != nil {
		return item, fmt.Errorf("scan UpdateJobStatusBatch row: %w", err)
	}
	return item, nil
}

const findAllocatedJobsSQL = `SELECT
    j.run_id,
    j.phase,
    j.status,
    w.execution_mode,
    r.workspace_id,
    j.agent_id
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.agent_id = $1
AND   j.status = 'allocated'
;`

type FindAllocatedJobsRow struct {
	RunID         pgtype.Text `json:"run_id"`
	Phase         pgtype.Text `json:"phase"`
	Status        pgtype.Text `json:"status"`
	ExecutionMode pgtype.Text `json:"execution_mode"`
	WorkspaceID   pgtype.Text `json:"workspace_id"`
	AgentID       pgtype.Text `json:"agent_id"`
}

// FindAllocatedJobs implements Querier.FindAllocatedJobs.
func (q *DBQuerier) FindAllocatedJobs(ctx context.Context, agentID pgtype.Text) ([]FindAllocatedJobsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindAllocatedJobs")
	rows, err := q.conn.Query(ctx, findAllocatedJobsSQL, agentID)
	if err != nil {
		return nil, fmt.Errorf("query FindAllocatedJobs: %w", err)
	}
	defer rows.Close()
	items := []FindAllocatedJobsRow{}
	for rows.Next() {
		var item FindAllocatedJobsRow
		if err := rows.Scan(&item.RunID, &item.Phase, &item.Status, &item.ExecutionMode, &item.WorkspaceID, &item.AgentID); err != nil {
			return nil, fmt.Errorf("scan FindAllocatedJobs row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindAllocatedJobs rows: %w", err)
	}
	return items, err
}

// FindAllocatedJobsBatch implements Querier.FindAllocatedJobsBatch.
func (q *DBQuerier) FindAllocatedJobsBatch(batch genericBatch, agentID pgtype.Text) {
	batch.Queue(findAllocatedJobsSQL, agentID)
}

// FindAllocatedJobsScan implements Querier.FindAllocatedJobsScan.
func (q *DBQuerier) FindAllocatedJobsScan(results pgx.BatchResults) ([]FindAllocatedJobsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindAllocatedJobsBatch: %w", err)
	}
	defer rows.Close()
	items := []FindAllocatedJobsRow{}
	for rows.Next() {
		var item FindAllocatedJobsRow
		if err := rows.Scan(&item.RunID, &item.Phase, &item.Status, &item.ExecutionMode, &item.WorkspaceID, &item.AgentID); err != nil {
			return nil, fmt.Errorf("scan FindAllocatedJobsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindAllocatedJobsBatch rows: %w", err)
	}
	return items, err
}
