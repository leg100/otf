// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertStateVersionSQL = `INSERT INTO state_versions (
    state_version_id,
    created_at,
    serial,
    state,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
);`

type InsertStateVersionParams struct {
	ID          pgtype.Text
	CreatedAt   pgtype.Timestamptz
	Serial      int
	State       []byte
	WorkspaceID pgtype.Text
}

// InsertStateVersion implements Querier.InsertStateVersion.
func (q *DBQuerier) InsertStateVersion(ctx context.Context, params InsertStateVersionParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertStateVersion")
	cmdTag, err := q.conn.Exec(ctx, insertStateVersionSQL, params.ID, params.CreatedAt, params.Serial, params.State, params.WorkspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertStateVersion: %w", err)
	}
	return cmdTag, err
}

// InsertStateVersionBatch implements Querier.InsertStateVersionBatch.
func (q *DBQuerier) InsertStateVersionBatch(batch genericBatch, params InsertStateVersionParams) {
	batch.Queue(insertStateVersionSQL, params.ID, params.CreatedAt, params.Serial, params.State, params.WorkspaceID)
}

// InsertStateVersionScan implements Querier.InsertStateVersionScan.
func (q *DBQuerier) InsertStateVersionScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertStateVersionBatch: %w", err)
	}
	return cmdTag, err
}

const findStateVersionsByWorkspaceIDSQL = `SELECT
    state_versions.*,
    array_remove(array_agg(state_version_outputs), NULL) AS state_version_outputs
FROM state_versions
LEFT JOIN state_version_outputs USING (state_version_id)
WHERE workspace_id = $1
GROUP BY state_versions.state_version_id
ORDER BY created_at DESC
LIMIT $2
OFFSET $3
;`

type FindStateVersionsByWorkspaceIDParams struct {
	WorkspaceID pgtype.Text
	Limit       int
	Offset      int
}

type FindStateVersionsByWorkspaceIDRow struct {
	StateVersionID      pgtype.Text           `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz    `json:"created_at"`
	Serial              int                   `json:"serial"`
	State               []byte                `json:"state"`
	WorkspaceID         pgtype.Text           `json:"workspace_id"`
	StateVersionOutputs []StateVersionOutputs `json:"state_version_outputs"`
}

// FindStateVersionsByWorkspaceID implements Querier.FindStateVersionsByWorkspaceID.
func (q *DBQuerier) FindStateVersionsByWorkspaceID(ctx context.Context, params FindStateVersionsByWorkspaceIDParams) ([]FindStateVersionsByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionsByWorkspaceID")
	rows, err := q.conn.Query(ctx, findStateVersionsByWorkspaceIDSQL, params.WorkspaceID, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindStateVersionsByWorkspaceID: %w", err)
	}
	defer rows.Close()
	items := []FindStateVersionsByWorkspaceIDRow{}
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	for rows.Next() {
		var item FindStateVersionsByWorkspaceIDRow
		if err := rows.Scan(&item.StateVersionID, &item.CreatedAt, &item.Serial, &item.State, &item.WorkspaceID, stateVersionOutputsArray); err != nil {
			return nil, fmt.Errorf("scan FindStateVersionsByWorkspaceID row: %w", err)
		}
		if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
			return nil, fmt.Errorf("assign FindStateVersionsByWorkspaceID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindStateVersionsByWorkspaceID rows: %w", err)
	}
	return items, err
}

// FindStateVersionsByWorkspaceIDBatch implements Querier.FindStateVersionsByWorkspaceIDBatch.
func (q *DBQuerier) FindStateVersionsByWorkspaceIDBatch(batch genericBatch, params FindStateVersionsByWorkspaceIDParams) {
	batch.Queue(findStateVersionsByWorkspaceIDSQL, params.WorkspaceID, params.Limit, params.Offset)
}

// FindStateVersionsByWorkspaceIDScan implements Querier.FindStateVersionsByWorkspaceIDScan.
func (q *DBQuerier) FindStateVersionsByWorkspaceIDScan(results pgx.BatchResults) ([]FindStateVersionsByWorkspaceIDRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindStateVersionsByWorkspaceIDBatch: %w", err)
	}
	defer rows.Close()
	items := []FindStateVersionsByWorkspaceIDRow{}
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	for rows.Next() {
		var item FindStateVersionsByWorkspaceIDRow
		if err := rows.Scan(&item.StateVersionID, &item.CreatedAt, &item.Serial, &item.State, &item.WorkspaceID, stateVersionOutputsArray); err != nil {
			return nil, fmt.Errorf("scan FindStateVersionsByWorkspaceIDBatch row: %w", err)
		}
		if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
			return nil, fmt.Errorf("assign FindStateVersionsByWorkspaceID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindStateVersionsByWorkspaceIDBatch rows: %w", err)
	}
	return items, err
}

const countStateVersionsByWorkspaceIDSQL = `SELECT count(*)
FROM state_versions
WHERE workspace_id = $1
;`

// CountStateVersionsByWorkspaceID implements Querier.CountStateVersionsByWorkspaceID.
func (q *DBQuerier) CountStateVersionsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (int, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountStateVersionsByWorkspaceID")
	row := q.conn.QueryRow(ctx, countStateVersionsByWorkspaceIDSQL, workspaceID)
	var item int
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query CountStateVersionsByWorkspaceID: %w", err)
	}
	return item, nil
}

// CountStateVersionsByWorkspaceIDBatch implements Querier.CountStateVersionsByWorkspaceIDBatch.
func (q *DBQuerier) CountStateVersionsByWorkspaceIDBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(countStateVersionsByWorkspaceIDSQL, workspaceID)
}

// CountStateVersionsByWorkspaceIDScan implements Querier.CountStateVersionsByWorkspaceIDScan.
func (q *DBQuerier) CountStateVersionsByWorkspaceIDScan(results pgx.BatchResults) (int, error) {
	row := results.QueryRow()
	var item int
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan CountStateVersionsByWorkspaceIDBatch row: %w", err)
	}
	return item, nil
}

const findStateVersionByIDSQL = `SELECT
    state_versions.*,
    array_remove(array_agg(state_version_outputs), NULL) AS state_version_outputs
FROM state_versions
LEFT JOIN state_version_outputs USING (state_version_id)
WHERE state_versions.state_version_id = $1
GROUP BY state_versions.state_version_id
;`

type FindStateVersionByIDRow struct {
	StateVersionID      pgtype.Text           `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz    `json:"created_at"`
	Serial              int                   `json:"serial"`
	State               []byte                `json:"state"`
	WorkspaceID         pgtype.Text           `json:"workspace_id"`
	StateVersionOutputs []StateVersionOutputs `json:"state_version_outputs"`
}

// FindStateVersionByID implements Querier.FindStateVersionByID.
func (q *DBQuerier) FindStateVersionByID(ctx context.Context, id pgtype.Text) (FindStateVersionByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionByID")
	row := q.conn.QueryRow(ctx, findStateVersionByIDSQL, id)
	var item FindStateVersionByIDRow
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.Serial, &item.State, &item.WorkspaceID, stateVersionOutputsArray); err != nil {
		return item, fmt.Errorf("query FindStateVersionByID: %w", err)
	}
	if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
		return item, fmt.Errorf("assign FindStateVersionByID row: %w", err)
	}
	return item, nil
}

// FindStateVersionByIDBatch implements Querier.FindStateVersionByIDBatch.
func (q *DBQuerier) FindStateVersionByIDBatch(batch genericBatch, id pgtype.Text) {
	batch.Queue(findStateVersionByIDSQL, id)
}

// FindStateVersionByIDScan implements Querier.FindStateVersionByIDScan.
func (q *DBQuerier) FindStateVersionByIDScan(results pgx.BatchResults) (FindStateVersionByIDRow, error) {
	row := results.QueryRow()
	var item FindStateVersionByIDRow
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.Serial, &item.State, &item.WorkspaceID, stateVersionOutputsArray); err != nil {
		return item, fmt.Errorf("scan FindStateVersionByIDBatch row: %w", err)
	}
	if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
		return item, fmt.Errorf("assign FindStateVersionByID row: %w", err)
	}
	return item, nil
}

const findCurrentStateVersionByWorkspaceIDSQL = `SELECT
    sv.*,
    array_remove(array_agg(svo), NULL) AS state_version_outputs
FROM state_versions sv
LEFT JOIN state_version_outputs svo USING (state_version_id)
JOIN workspaces w ON w.current_state_version_id = sv.state_version_id
WHERE w.workspace_id = $1
GROUP BY sv.state_version_id
;`

type FindCurrentStateVersionByWorkspaceIDRow struct {
	StateVersionID      pgtype.Text           `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz    `json:"created_at"`
	Serial              int                   `json:"serial"`
	State               []byte                `json:"state"`
	WorkspaceID         pgtype.Text           `json:"workspace_id"`
	StateVersionOutputs []StateVersionOutputs `json:"state_version_outputs"`
}

// FindCurrentStateVersionByWorkspaceID implements Querier.FindCurrentStateVersionByWorkspaceID.
func (q *DBQuerier) FindCurrentStateVersionByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (FindCurrentStateVersionByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindCurrentStateVersionByWorkspaceID")
	row := q.conn.QueryRow(ctx, findCurrentStateVersionByWorkspaceIDSQL, workspaceID)
	var item FindCurrentStateVersionByWorkspaceIDRow
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.Serial, &item.State, &item.WorkspaceID, stateVersionOutputsArray); err != nil {
		return item, fmt.Errorf("query FindCurrentStateVersionByWorkspaceID: %w", err)
	}
	if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
		return item, fmt.Errorf("assign FindCurrentStateVersionByWorkspaceID row: %w", err)
	}
	return item, nil
}

// FindCurrentStateVersionByWorkspaceIDBatch implements Querier.FindCurrentStateVersionByWorkspaceIDBatch.
func (q *DBQuerier) FindCurrentStateVersionByWorkspaceIDBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(findCurrentStateVersionByWorkspaceIDSQL, workspaceID)
}

// FindCurrentStateVersionByWorkspaceIDScan implements Querier.FindCurrentStateVersionByWorkspaceIDScan.
func (q *DBQuerier) FindCurrentStateVersionByWorkspaceIDScan(results pgx.BatchResults) (FindCurrentStateVersionByWorkspaceIDRow, error) {
	row := results.QueryRow()
	var item FindCurrentStateVersionByWorkspaceIDRow
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.Serial, &item.State, &item.WorkspaceID, stateVersionOutputsArray); err != nil {
		return item, fmt.Errorf("scan FindCurrentStateVersionByWorkspaceIDBatch row: %w", err)
	}
	if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
		return item, fmt.Errorf("assign FindCurrentStateVersionByWorkspaceID row: %w", err)
	}
	return item, nil
}

const findStateVersionStateByIDSQL = `SELECT state
FROM state_versions
WHERE state_version_id = $1
;`

// FindStateVersionStateByID implements Querier.FindStateVersionStateByID.
func (q *DBQuerier) FindStateVersionStateByID(ctx context.Context, id pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionStateByID")
	row := q.conn.QueryRow(ctx, findStateVersionStateByIDSQL, id)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindStateVersionStateByID: %w", err)
	}
	return item, nil
}

// FindStateVersionStateByIDBatch implements Querier.FindStateVersionStateByIDBatch.
func (q *DBQuerier) FindStateVersionStateByIDBatch(batch genericBatch, id pgtype.Text) {
	batch.Queue(findStateVersionStateByIDSQL, id)
}

// FindStateVersionStateByIDScan implements Querier.FindStateVersionStateByIDScan.
func (q *DBQuerier) FindStateVersionStateByIDScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindStateVersionStateByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteStateVersionByIDSQL = `DELETE
FROM state_versions
WHERE state_version_id = $1
RETURNING state_version_id
;`

// DeleteStateVersionByID implements Querier.DeleteStateVersionByID.
func (q *DBQuerier) DeleteStateVersionByID(ctx context.Context, stateVersionID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteStateVersionByID")
	row := q.conn.QueryRow(ctx, deleteStateVersionByIDSQL, stateVersionID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteStateVersionByID: %w", err)
	}
	return item, nil
}

// DeleteStateVersionByIDBatch implements Querier.DeleteStateVersionByIDBatch.
func (q *DBQuerier) DeleteStateVersionByIDBatch(batch genericBatch, stateVersionID pgtype.Text) {
	batch.Queue(deleteStateVersionByIDSQL, stateVersionID)
}

// DeleteStateVersionByIDScan implements Querier.DeleteStateVersionByIDScan.
func (q *DBQuerier) DeleteStateVersionByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteStateVersionByIDBatch row: %w", err)
	}
	return item, nil
}
