// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertRepohookSQL = `WITH inserted AS (
    INSERT INTO repohooks (
        repohook_id,
        vcs_id,
        vcs_provider_id,
        secret,
        repo_path
    ) VALUES (
        $1,
        $2,
        $3,
        $4,
        $5
    )
    RETURNING *
)
SELECT
    w.repohook_id,
    w.vcs_id,
    w.vcs_provider_id,
    w.secret,
    w.repo_path,
    v.vcs_kind
FROM inserted w
JOIN vcs_providers v USING (vcs_provider_id);`

type InsertRepohookParams struct {
	RepohookID    pgtype.UUID
	VCSID         pgtype.Text
	VCSProviderID pgtype.Text
	Secret        pgtype.Text
	RepoPath      pgtype.Text
}

type InsertRepohookRow struct {
	RepohookID    pgtype.UUID `json:"repohook_id"`
	VCSID         pgtype.Text `json:"vcs_id"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
	Secret        pgtype.Text `json:"secret"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSKind       pgtype.Text `json:"vcs_kind"`
}

// InsertRepohook implements Querier.InsertRepohook.
func (q *DBQuerier) InsertRepohook(ctx context.Context, params InsertRepohookParams) (InsertRepohookRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertRepohook")
	row := q.conn.QueryRow(ctx, insertRepohookSQL, params.RepohookID, params.VCSID, params.VCSProviderID, params.Secret, params.RepoPath)
	var item InsertRepohookRow
	if err := row.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
		return item, fmt.Errorf("query InsertRepohook: %w", err)
	}
	return item, nil
}

// InsertRepohookBatch implements Querier.InsertRepohookBatch.
func (q *DBQuerier) InsertRepohookBatch(batch genericBatch, params InsertRepohookParams) {
	batch.Queue(insertRepohookSQL, params.RepohookID, params.VCSID, params.VCSProviderID, params.Secret, params.RepoPath)
}

// InsertRepohookScan implements Querier.InsertRepohookScan.
func (q *DBQuerier) InsertRepohookScan(results pgx.BatchResults) (InsertRepohookRow, error) {
	row := results.QueryRow()
	var item InsertRepohookRow
	if err := row.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
		return item, fmt.Errorf("scan InsertRepohookBatch row: %w", err)
	}
	return item, nil
}

const updateRepohookVCSIDSQL = `UPDATE repohooks
SET vcs_id = $1
WHERE repohook_id = $2
RETURNING *;`

type UpdateRepohookVCSIDRow struct {
	RepohookID    pgtype.UUID `json:"repohook_id"`
	VCSID         pgtype.Text `json:"vcs_id"`
	Secret        pgtype.Text `json:"secret"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
}

// UpdateRepohookVCSID implements Querier.UpdateRepohookVCSID.
func (q *DBQuerier) UpdateRepohookVCSID(ctx context.Context, vcsID pgtype.Text, repohookID pgtype.UUID) (UpdateRepohookVCSIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateRepohookVCSID")
	row := q.conn.QueryRow(ctx, updateRepohookVCSIDSQL, vcsID, repohookID)
	var item UpdateRepohookVCSIDRow
	if err := row.Scan(&item.RepohookID, &item.VCSID, &item.Secret, &item.RepoPath, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("query UpdateRepohookVCSID: %w", err)
	}
	return item, nil
}

// UpdateRepohookVCSIDBatch implements Querier.UpdateRepohookVCSIDBatch.
func (q *DBQuerier) UpdateRepohookVCSIDBatch(batch genericBatch, vcsID pgtype.Text, repohookID pgtype.UUID) {
	batch.Queue(updateRepohookVCSIDSQL, vcsID, repohookID)
}

// UpdateRepohookVCSIDScan implements Querier.UpdateRepohookVCSIDScan.
func (q *DBQuerier) UpdateRepohookVCSIDScan(results pgx.BatchResults) (UpdateRepohookVCSIDRow, error) {
	row := results.QueryRow()
	var item UpdateRepohookVCSIDRow
	if err := row.Scan(&item.RepohookID, &item.VCSID, &item.Secret, &item.RepoPath, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("scan UpdateRepohookVCSIDBatch row: %w", err)
	}
	return item, nil
}

const findRepohooksSQL = `SELECT
    w.repohook_id,
    w.vcs_id,
    w.vcs_provider_id,
    w.secret,
    w.repo_path,
    v.vcs_kind
FROM repohooks w
JOIN vcs_providers v USING (vcs_provider_id);`

type FindRepohooksRow struct {
	RepohookID    pgtype.UUID `json:"repohook_id"`
	VCSID         pgtype.Text `json:"vcs_id"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
	Secret        pgtype.Text `json:"secret"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSKind       pgtype.Text `json:"vcs_kind"`
}

// FindRepohooks implements Querier.FindRepohooks.
func (q *DBQuerier) FindRepohooks(ctx context.Context) ([]FindRepohooksRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRepohooks")
	rows, err := q.conn.Query(ctx, findRepohooksSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindRepohooks: %w", err)
	}
	defer rows.Close()
	items := []FindRepohooksRow{}
	for rows.Next() {
		var item FindRepohooksRow
		if err := rows.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
			return nil, fmt.Errorf("scan FindRepohooks row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRepohooks rows: %w", err)
	}
	return items, err
}

// FindRepohooksBatch implements Querier.FindRepohooksBatch.
func (q *DBQuerier) FindRepohooksBatch(batch genericBatch) {
	batch.Queue(findRepohooksSQL)
}

// FindRepohooksScan implements Querier.FindRepohooksScan.
func (q *DBQuerier) FindRepohooksScan(results pgx.BatchResults) ([]FindRepohooksRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindRepohooksBatch: %w", err)
	}
	defer rows.Close()
	items := []FindRepohooksRow{}
	for rows.Next() {
		var item FindRepohooksRow
		if err := rows.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
			return nil, fmt.Errorf("scan FindRepohooksBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRepohooksBatch rows: %w", err)
	}
	return items, err
}

const findRepohookByIDSQL = `SELECT
    w.repohook_id,
    w.vcs_id,
    w.vcs_provider_id,
    w.secret,
    w.repo_path,
    v.vcs_kind
FROM repohooks w
JOIN vcs_providers v USING (vcs_provider_id)
WHERE w.repohook_id = $1;`

type FindRepohookByIDRow struct {
	RepohookID    pgtype.UUID `json:"repohook_id"`
	VCSID         pgtype.Text `json:"vcs_id"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
	Secret        pgtype.Text `json:"secret"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSKind       pgtype.Text `json:"vcs_kind"`
}

// FindRepohookByID implements Querier.FindRepohookByID.
func (q *DBQuerier) FindRepohookByID(ctx context.Context, repohookID pgtype.UUID) (FindRepohookByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRepohookByID")
	row := q.conn.QueryRow(ctx, findRepohookByIDSQL, repohookID)
	var item FindRepohookByIDRow
	if err := row.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
		return item, fmt.Errorf("query FindRepohookByID: %w", err)
	}
	return item, nil
}

// FindRepohookByIDBatch implements Querier.FindRepohookByIDBatch.
func (q *DBQuerier) FindRepohookByIDBatch(batch genericBatch, repohookID pgtype.UUID) {
	batch.Queue(findRepohookByIDSQL, repohookID)
}

// FindRepohookByIDScan implements Querier.FindRepohookByIDScan.
func (q *DBQuerier) FindRepohookByIDScan(results pgx.BatchResults) (FindRepohookByIDRow, error) {
	row := results.QueryRow()
	var item FindRepohookByIDRow
	if err := row.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
		return item, fmt.Errorf("scan FindRepohookByIDBatch row: %w", err)
	}
	return item, nil
}

const findRepohookByRepoAndProviderSQL = `SELECT
    w.repohook_id,
    w.vcs_id,
    w.vcs_provider_id,
    w.secret,
    w.repo_path,
    v.vcs_kind
FROM repohooks w
JOIN vcs_providers v USING (vcs_provider_id)
WHERE repo_path = $1
AND   vcs_provider_id = $2;`

type FindRepohookByRepoAndProviderRow struct {
	RepohookID    pgtype.UUID `json:"repohook_id"`
	VCSID         pgtype.Text `json:"vcs_id"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
	Secret        pgtype.Text `json:"secret"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSKind       pgtype.Text `json:"vcs_kind"`
}

// FindRepohookByRepoAndProvider implements Querier.FindRepohookByRepoAndProvider.
func (q *DBQuerier) FindRepohookByRepoAndProvider(ctx context.Context, repoPath pgtype.Text, vcsProviderID pgtype.Text) ([]FindRepohookByRepoAndProviderRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRepohookByRepoAndProvider")
	rows, err := q.conn.Query(ctx, findRepohookByRepoAndProviderSQL, repoPath, vcsProviderID)
	if err != nil {
		return nil, fmt.Errorf("query FindRepohookByRepoAndProvider: %w", err)
	}
	defer rows.Close()
	items := []FindRepohookByRepoAndProviderRow{}
	for rows.Next() {
		var item FindRepohookByRepoAndProviderRow
		if err := rows.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
			return nil, fmt.Errorf("scan FindRepohookByRepoAndProvider row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRepohookByRepoAndProvider rows: %w", err)
	}
	return items, err
}

// FindRepohookByRepoAndProviderBatch implements Querier.FindRepohookByRepoAndProviderBatch.
func (q *DBQuerier) FindRepohookByRepoAndProviderBatch(batch genericBatch, repoPath pgtype.Text, vcsProviderID pgtype.Text) {
	batch.Queue(findRepohookByRepoAndProviderSQL, repoPath, vcsProviderID)
}

// FindRepohookByRepoAndProviderScan implements Querier.FindRepohookByRepoAndProviderScan.
func (q *DBQuerier) FindRepohookByRepoAndProviderScan(results pgx.BatchResults) ([]FindRepohookByRepoAndProviderRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindRepohookByRepoAndProviderBatch: %w", err)
	}
	defer rows.Close()
	items := []FindRepohookByRepoAndProviderRow{}
	for rows.Next() {
		var item FindRepohookByRepoAndProviderRow
		if err := rows.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
			return nil, fmt.Errorf("scan FindRepohookByRepoAndProviderBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRepohookByRepoAndProviderBatch rows: %w", err)
	}
	return items, err
}

const findUnreferencedRepohooksSQL = `SELECT
    w.repohook_id,
    w.vcs_id,
    w.vcs_provider_id,
    w.secret,
    w.repo_path,
    v.vcs_kind
FROM repohooks w
JOIN vcs_providers v USING (vcs_provider_id)
WHERE NOT EXISTS (
    SELECT FROM repo_connections rc
    WHERE rc.vcs_provider_id = w.vcs_provider_id
    AND   rc.repo_path = w.repo_path
);`

type FindUnreferencedRepohooksRow struct {
	RepohookID    pgtype.UUID `json:"repohook_id"`
	VCSID         pgtype.Text `json:"vcs_id"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
	Secret        pgtype.Text `json:"secret"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSKind       pgtype.Text `json:"vcs_kind"`
}

// FindUnreferencedRepohooks implements Querier.FindUnreferencedRepohooks.
func (q *DBQuerier) FindUnreferencedRepohooks(ctx context.Context) ([]FindUnreferencedRepohooksRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUnreferencedRepohooks")
	rows, err := q.conn.Query(ctx, findUnreferencedRepohooksSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindUnreferencedRepohooks: %w", err)
	}
	defer rows.Close()
	items := []FindUnreferencedRepohooksRow{}
	for rows.Next() {
		var item FindUnreferencedRepohooksRow
		if err := rows.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
			return nil, fmt.Errorf("scan FindUnreferencedRepohooks row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUnreferencedRepohooks rows: %w", err)
	}
	return items, err
}

// FindUnreferencedRepohooksBatch implements Querier.FindUnreferencedRepohooksBatch.
func (q *DBQuerier) FindUnreferencedRepohooksBatch(batch genericBatch) {
	batch.Queue(findUnreferencedRepohooksSQL)
}

// FindUnreferencedRepohooksScan implements Querier.FindUnreferencedRepohooksScan.
func (q *DBQuerier) FindUnreferencedRepohooksScan(results pgx.BatchResults) ([]FindUnreferencedRepohooksRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindUnreferencedRepohooksBatch: %w", err)
	}
	defer rows.Close()
	items := []FindUnreferencedRepohooksRow{}
	for rows.Next() {
		var item FindUnreferencedRepohooksRow
		if err := rows.Scan(&item.RepohookID, &item.VCSID, &item.VCSProviderID, &item.Secret, &item.RepoPath, &item.VCSKind); err != nil {
			return nil, fmt.Errorf("scan FindUnreferencedRepohooksBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUnreferencedRepohooksBatch rows: %w", err)
	}
	return items, err
}

const deleteRepohookByIDSQL = `DELETE
FROM repohooks
WHERE repohook_id = $1
RETURNING *;`

type DeleteRepohookByIDRow struct {
	RepohookID    pgtype.UUID `json:"repohook_id"`
	VCSID         pgtype.Text `json:"vcs_id"`
	Secret        pgtype.Text `json:"secret"`
	RepoPath      pgtype.Text `json:"repo_path"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
}

// DeleteRepohookByID implements Querier.DeleteRepohookByID.
func (q *DBQuerier) DeleteRepohookByID(ctx context.Context, repohookID pgtype.UUID) (DeleteRepohookByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteRepohookByID")
	row := q.conn.QueryRow(ctx, deleteRepohookByIDSQL, repohookID)
	var item DeleteRepohookByIDRow
	if err := row.Scan(&item.RepohookID, &item.VCSID, &item.Secret, &item.RepoPath, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("query DeleteRepohookByID: %w", err)
	}
	return item, nil
}

// DeleteRepohookByIDBatch implements Querier.DeleteRepohookByIDBatch.
func (q *DBQuerier) DeleteRepohookByIDBatch(batch genericBatch, repohookID pgtype.UUID) {
	batch.Queue(deleteRepohookByIDSQL, repohookID)
}

// DeleteRepohookByIDScan implements Querier.DeleteRepohookByIDScan.
func (q *DBQuerier) DeleteRepohookByIDScan(results pgx.BatchResults) (DeleteRepohookByIDRow, error) {
	row := results.QueryRow()
	var item DeleteRepohookByIDRow
	if err := row.Scan(&item.RepohookID, &item.VCSID, &item.Secret, &item.RepoPath, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("scan DeleteRepohookByIDBatch row: %w", err)
	}
	return item, nil
}
