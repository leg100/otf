// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertTeamSQL = `INSERT INTO teams (
    team_id,
    name,
    created_at,
    organization_name,
    visibility,
    sso_team_id,
    permission_manage_workspaces,
    permission_manage_vcs,
    permission_manage_modules,
    permission_manage_providers,
    permission_manage_policies,
    permission_manage_policy_overrides
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
);`

type InsertTeamParams struct {
	ID                              pgtype.Text
	Name                            pgtype.Text
	CreatedAt                       pgtype.Timestamptz
	OrganizationName                pgtype.Text
	Visibility                      pgtype.Text
	SSOTeamID                       pgtype.Text
	PermissionManageWorkspaces      bool
	PermissionManageVCS             bool
	PermissionManageModules         bool
	PermissionManageProviders       bool
	PermissionManagePolicies        bool
	PermissionManagePolicyOverrides bool
}

// InsertTeam implements Querier.InsertTeam.
func (q *DBQuerier) InsertTeam(ctx context.Context, params InsertTeamParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertTeam")
	cmdTag, err := q.conn.Exec(ctx, insertTeamSQL, params.ID, params.Name, params.CreatedAt, params.OrganizationName, params.Visibility, params.SSOTeamID, params.PermissionManageWorkspaces, params.PermissionManageVCS, params.PermissionManageModules, params.PermissionManageProviders, params.PermissionManagePolicies, params.PermissionManagePolicyOverrides)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertTeam: %w", err)
	}
	return cmdTag, err
}

// InsertTeamBatch implements Querier.InsertTeamBatch.
func (q *DBQuerier) InsertTeamBatch(batch genericBatch, params InsertTeamParams) {
	batch.Queue(insertTeamSQL, params.ID, params.Name, params.CreatedAt, params.OrganizationName, params.Visibility, params.SSOTeamID, params.PermissionManageWorkspaces, params.PermissionManageVCS, params.PermissionManageModules, params.PermissionManageProviders, params.PermissionManagePolicies, params.PermissionManagePolicyOverrides)
}

// InsertTeamScan implements Querier.InsertTeamScan.
func (q *DBQuerier) InsertTeamScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertTeamBatch: %w", err)
	}
	return cmdTag, err
}

const findTeamsByOrgSQL = `SELECT *
FROM teams
WHERE organization_name = $1
;`

type FindTeamsByOrgRow struct {
	TeamID                          pgtype.Text        `json:"team_id"`
	Name                            pgtype.Text        `json:"name"`
	CreatedAt                       pgtype.Timestamptz `json:"created_at"`
	PermissionManageWorkspaces      bool               `json:"permission_manage_workspaces"`
	PermissionManageVCS             bool               `json:"permission_manage_vcs"`
	PermissionManageModules         bool               `json:"permission_manage_modules"`
	OrganizationName                pgtype.Text        `json:"organization_name"`
	SSOTeamID                       pgtype.Text        `json:"sso_team_id"`
	Visibility                      pgtype.Text        `json:"visibility"`
	PermissionManagePolicies        bool               `json:"permission_manage_policies"`
	PermissionManagePolicyOverrides bool               `json:"permission_manage_policy_overrides"`
	PermissionManageProviders       bool               `json:"permission_manage_providers"`
}

// FindTeamsByOrg implements Querier.FindTeamsByOrg.
func (q *DBQuerier) FindTeamsByOrg(ctx context.Context, organizationName pgtype.Text) ([]FindTeamsByOrgRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamsByOrg")
	rows, err := q.conn.Query(ctx, findTeamsByOrgSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindTeamsByOrg: %w", err)
	}
	defer rows.Close()
	items := []FindTeamsByOrgRow{}
	for rows.Next() {
		var item FindTeamsByOrgRow
		if err := rows.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, &item.PermissionManageModules, &item.OrganizationName, &item.SSOTeamID, &item.Visibility, &item.PermissionManagePolicies, &item.PermissionManagePolicyOverrides, &item.PermissionManageProviders); err != nil {
			return nil, fmt.Errorf("scan FindTeamsByOrg row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindTeamsByOrg rows: %w", err)
	}
	return items, err
}

// FindTeamsByOrgBatch implements Querier.FindTeamsByOrgBatch.
func (q *DBQuerier) FindTeamsByOrgBatch(batch genericBatch, organizationName pgtype.Text) {
	batch.Queue(findTeamsByOrgSQL, organizationName)
}

// FindTeamsByOrgScan implements Querier.FindTeamsByOrgScan.
func (q *DBQuerier) FindTeamsByOrgScan(results pgx.BatchResults) ([]FindTeamsByOrgRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindTeamsByOrgBatch: %w", err)
	}
	defer rows.Close()
	items := []FindTeamsByOrgRow{}
	for rows.Next() {
		var item FindTeamsByOrgRow
		if err := rows.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, &item.PermissionManageModules, &item.OrganizationName, &item.SSOTeamID, &item.Visibility, &item.PermissionManagePolicies, &item.PermissionManagePolicyOverrides, &item.PermissionManageProviders); err != nil {
			return nil, fmt.Errorf("scan FindTeamsByOrgBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindTeamsByOrgBatch rows: %w", err)
	}
	return items, err
}

const findTeamByNameSQL = `SELECT *
FROM teams
WHERE name              = $1
AND   organization_name = $2
;`

type FindTeamByNameRow struct {
	TeamID                          pgtype.Text        `json:"team_id"`
	Name                            pgtype.Text        `json:"name"`
	CreatedAt                       pgtype.Timestamptz `json:"created_at"`
	PermissionManageWorkspaces      bool               `json:"permission_manage_workspaces"`
	PermissionManageVCS             bool               `json:"permission_manage_vcs"`
	PermissionManageModules         bool               `json:"permission_manage_modules"`
	OrganizationName                pgtype.Text        `json:"organization_name"`
	SSOTeamID                       pgtype.Text        `json:"sso_team_id"`
	Visibility                      pgtype.Text        `json:"visibility"`
	PermissionManagePolicies        bool               `json:"permission_manage_policies"`
	PermissionManagePolicyOverrides bool               `json:"permission_manage_policy_overrides"`
	PermissionManageProviders       bool               `json:"permission_manage_providers"`
}

// FindTeamByName implements Querier.FindTeamByName.
func (q *DBQuerier) FindTeamByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindTeamByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamByName")
	row := q.conn.QueryRow(ctx, findTeamByNameSQL, name, organizationName)
	var item FindTeamByNameRow
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, &item.PermissionManageModules, &item.OrganizationName, &item.SSOTeamID, &item.Visibility, &item.PermissionManagePolicies, &item.PermissionManagePolicyOverrides, &item.PermissionManageProviders); err != nil {
		return item, fmt.Errorf("query FindTeamByName: %w", err)
	}
	return item, nil
}

// FindTeamByNameBatch implements Querier.FindTeamByNameBatch.
func (q *DBQuerier) FindTeamByNameBatch(batch genericBatch, name pgtype.Text, organizationName pgtype.Text) {
	batch.Queue(findTeamByNameSQL, name, organizationName)
}

// FindTeamByNameScan implements Querier.FindTeamByNameScan.
func (q *DBQuerier) FindTeamByNameScan(results pgx.BatchResults) (FindTeamByNameRow, error) {
	row := results.QueryRow()
	var item FindTeamByNameRow
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, &item.PermissionManageModules, &item.OrganizationName, &item.SSOTeamID, &item.Visibility, &item.PermissionManagePolicies, &item.PermissionManagePolicyOverrides, &item.PermissionManageProviders); err != nil {
		return item, fmt.Errorf("scan FindTeamByNameBatch row: %w", err)
	}
	return item, nil
}

const findTeamByIDSQL = `SELECT *
FROM teams
WHERE team_id = $1
;`

type FindTeamByIDRow struct {
	TeamID                          pgtype.Text        `json:"team_id"`
	Name                            pgtype.Text        `json:"name"`
	CreatedAt                       pgtype.Timestamptz `json:"created_at"`
	PermissionManageWorkspaces      bool               `json:"permission_manage_workspaces"`
	PermissionManageVCS             bool               `json:"permission_manage_vcs"`
	PermissionManageModules         bool               `json:"permission_manage_modules"`
	OrganizationName                pgtype.Text        `json:"organization_name"`
	SSOTeamID                       pgtype.Text        `json:"sso_team_id"`
	Visibility                      pgtype.Text        `json:"visibility"`
	PermissionManagePolicies        bool               `json:"permission_manage_policies"`
	PermissionManagePolicyOverrides bool               `json:"permission_manage_policy_overrides"`
	PermissionManageProviders       bool               `json:"permission_manage_providers"`
}

// FindTeamByID implements Querier.FindTeamByID.
func (q *DBQuerier) FindTeamByID(ctx context.Context, teamID pgtype.Text) (FindTeamByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamByID")
	row := q.conn.QueryRow(ctx, findTeamByIDSQL, teamID)
	var item FindTeamByIDRow
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, &item.PermissionManageModules, &item.OrganizationName, &item.SSOTeamID, &item.Visibility, &item.PermissionManagePolicies, &item.PermissionManagePolicyOverrides, &item.PermissionManageProviders); err != nil {
		return item, fmt.Errorf("query FindTeamByID: %w", err)
	}
	return item, nil
}

// FindTeamByIDBatch implements Querier.FindTeamByIDBatch.
func (q *DBQuerier) FindTeamByIDBatch(batch genericBatch, teamID pgtype.Text) {
	batch.Queue(findTeamByIDSQL, teamID)
}

// FindTeamByIDScan implements Querier.FindTeamByIDScan.
func (q *DBQuerier) FindTeamByIDScan(results pgx.BatchResults) (FindTeamByIDRow, error) {
	row := results.QueryRow()
	var item FindTeamByIDRow
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, &item.PermissionManageModules, &item.OrganizationName, &item.SSOTeamID, &item.Visibility, &item.PermissionManagePolicies, &item.PermissionManagePolicyOverrides, &item.PermissionManageProviders); err != nil {
		return item, fmt.Errorf("scan FindTeamByIDBatch row: %w", err)
	}
	return item, nil
}

const findTeamByIDForUpdateSQL = `SELECT *
FROM teams t
WHERE team_id = $1
FOR UPDATE OF t
;`

type FindTeamByIDForUpdateRow struct {
	TeamID                          pgtype.Text        `json:"team_id"`
	Name                            pgtype.Text        `json:"name"`
	CreatedAt                       pgtype.Timestamptz `json:"created_at"`
	PermissionManageWorkspaces      bool               `json:"permission_manage_workspaces"`
	PermissionManageVCS             bool               `json:"permission_manage_vcs"`
	PermissionManageModules         bool               `json:"permission_manage_modules"`
	OrganizationName                pgtype.Text        `json:"organization_name"`
	SSOTeamID                       pgtype.Text        `json:"sso_team_id"`
	Visibility                      pgtype.Text        `json:"visibility"`
	PermissionManagePolicies        bool               `json:"permission_manage_policies"`
	PermissionManagePolicyOverrides bool               `json:"permission_manage_policy_overrides"`
	PermissionManageProviders       bool               `json:"permission_manage_providers"`
}

// FindTeamByIDForUpdate implements Querier.FindTeamByIDForUpdate.
func (q *DBQuerier) FindTeamByIDForUpdate(ctx context.Context, teamID pgtype.Text) (FindTeamByIDForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamByIDForUpdate")
	row := q.conn.QueryRow(ctx, findTeamByIDForUpdateSQL, teamID)
	var item FindTeamByIDForUpdateRow
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, &item.PermissionManageModules, &item.OrganizationName, &item.SSOTeamID, &item.Visibility, &item.PermissionManagePolicies, &item.PermissionManagePolicyOverrides, &item.PermissionManageProviders); err != nil {
		return item, fmt.Errorf("query FindTeamByIDForUpdate: %w", err)
	}
	return item, nil
}

// FindTeamByIDForUpdateBatch implements Querier.FindTeamByIDForUpdateBatch.
func (q *DBQuerier) FindTeamByIDForUpdateBatch(batch genericBatch, teamID pgtype.Text) {
	batch.Queue(findTeamByIDForUpdateSQL, teamID)
}

// FindTeamByIDForUpdateScan implements Querier.FindTeamByIDForUpdateScan.
func (q *DBQuerier) FindTeamByIDForUpdateScan(results pgx.BatchResults) (FindTeamByIDForUpdateRow, error) {
	row := results.QueryRow()
	var item FindTeamByIDForUpdateRow
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, &item.PermissionManageModules, &item.OrganizationName, &item.SSOTeamID, &item.Visibility, &item.PermissionManagePolicies, &item.PermissionManagePolicyOverrides, &item.PermissionManageProviders); err != nil {
		return item, fmt.Errorf("scan FindTeamByIDForUpdateBatch row: %w", err)
	}
	return item, nil
}

const updateTeamByIDSQL = `UPDATE teams
SET
    name = $1,
    visibility = $2,
    sso_team_id = $3,
    permission_manage_workspaces = $4,
    permission_manage_vcs = $5,
    permission_manage_modules = $6,
    permission_manage_providers = $7,
    permission_manage_policies = $8,
    permission_manage_policy_overrides = $9
WHERE team_id = $10
RETURNING team_id;`

type UpdateTeamByIDParams struct {
	Name                            pgtype.Text
	Visibility                      pgtype.Text
	SSOTeamID                       pgtype.Text
	PermissionManageWorkspaces      bool
	PermissionManageVCS             bool
	PermissionManageModules         bool
	PermissionManageProviders       bool
	PermissionManagePolicies        bool
	PermissionManagePolicyOverrides bool
	TeamID                          pgtype.Text
}

// UpdateTeamByID implements Querier.UpdateTeamByID.
func (q *DBQuerier) UpdateTeamByID(ctx context.Context, params UpdateTeamByIDParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateTeamByID")
	row := q.conn.QueryRow(ctx, updateTeamByIDSQL, params.Name, params.Visibility, params.SSOTeamID, params.PermissionManageWorkspaces, params.PermissionManageVCS, params.PermissionManageModules, params.PermissionManageProviders, params.PermissionManagePolicies, params.PermissionManagePolicyOverrides, params.TeamID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateTeamByID: %w", err)
	}
	return item, nil
}

// UpdateTeamByIDBatch implements Querier.UpdateTeamByIDBatch.
func (q *DBQuerier) UpdateTeamByIDBatch(batch genericBatch, params UpdateTeamByIDParams) {
	batch.Queue(updateTeamByIDSQL, params.Name, params.Visibility, params.SSOTeamID, params.PermissionManageWorkspaces, params.PermissionManageVCS, params.PermissionManageModules, params.PermissionManageProviders, params.PermissionManagePolicies, params.PermissionManagePolicyOverrides, params.TeamID)
}

// UpdateTeamByIDScan implements Querier.UpdateTeamByIDScan.
func (q *DBQuerier) UpdateTeamByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateTeamByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteTeamByIDSQL = `DELETE
FROM teams
WHERE team_id = $1
RETURNING team_id
;`

// DeleteTeamByID implements Querier.DeleteTeamByID.
func (q *DBQuerier) DeleteTeamByID(ctx context.Context, teamID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteTeamByID")
	row := q.conn.QueryRow(ctx, deleteTeamByIDSQL, teamID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteTeamByID: %w", err)
	}
	return item, nil
}

// DeleteTeamByIDBatch implements Querier.DeleteTeamByIDBatch.
func (q *DBQuerier) DeleteTeamByIDBatch(batch genericBatch, teamID pgtype.Text) {
	batch.Queue(deleteTeamByIDSQL, teamID)
}

// DeleteTeamByIDScan implements Querier.DeleteTeamByIDScan.
func (q *DBQuerier) DeleteTeamByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteTeamByIDBatch row: %w", err)
	}
	return item, nil
}
