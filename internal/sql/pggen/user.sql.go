// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertUserSQL = `INSERT INTO users (
    user_id,
    created_at,
    updated_at,
    username
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertUserParams struct {
	ID        pgtype.Text
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Username  pgtype.Text
}

// InsertUser implements Querier.InsertUser.
func (q *DBQuerier) InsertUser(ctx context.Context, params InsertUserParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertUser")
	cmdTag, err := q.conn.Exec(ctx, insertUserSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.Username)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertUser: %w", err)
	}
	return cmdTag, err
}

// InsertUserBatch implements Querier.InsertUserBatch.
func (q *DBQuerier) InsertUserBatch(batch genericBatch, params InsertUserParams) {
	batch.Queue(insertUserSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.Username)
}

// InsertUserScan implements Querier.InsertUserScan.
func (q *DBQuerier) InsertUserScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertUserBatch: %w", err)
	}
	return cmdTag, err
}

const findUsersSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
;`

type FindUsersRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []Teams            `json:"teams"`
}

// FindUsers implements Querier.FindUsers.
func (q *DBQuerier) FindUsers(ctx context.Context) ([]FindUsersRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUsers")
	rows, err := q.conn.Query(ctx, findUsersSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindUsers: %w", err)
	}
	defer rows.Close()
	items := []FindUsersRow{}
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsers row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsers rows: %w", err)
	}
	return items, err
}

// FindUsersBatch implements Querier.FindUsersBatch.
func (q *DBQuerier) FindUsersBatch(batch genericBatch) {
	batch.Queue(findUsersSQL)
}

// FindUsersScan implements Querier.FindUsersScan.
func (q *DBQuerier) FindUsersScan(results pgx.BatchResults) ([]FindUsersRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindUsersBatch: %w", err)
	}
	defer rows.Close()
	items := []FindUsersRow{}
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersBatch row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersBatch rows: %w", err)
	}
	return items, err
}

const findUsersByOrganizationSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
JOIN team_memberships tm USING (username)
JOIN teams t USING (team_id)
WHERE t.organization_name = $1
GROUP BY u.user_id
;`

type FindUsersByOrganizationRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []Teams            `json:"teams"`
}

// FindUsersByOrganization implements Querier.FindUsersByOrganization.
func (q *DBQuerier) FindUsersByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindUsersByOrganizationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUsersByOrganization")
	rows, err := q.conn.Query(ctx, findUsersByOrganizationSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByOrganization: %w", err)
	}
	defer rows.Close()
	items := []FindUsersByOrganizationRow{}
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersByOrganizationRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersByOrganization row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersByOrganization rows: %w", err)
	}
	return items, err
}

// FindUsersByOrganizationBatch implements Querier.FindUsersByOrganizationBatch.
func (q *DBQuerier) FindUsersByOrganizationBatch(batch genericBatch, organizationName pgtype.Text) {
	batch.Queue(findUsersByOrganizationSQL, organizationName)
}

// FindUsersByOrganizationScan implements Querier.FindUsersByOrganizationScan.
func (q *DBQuerier) FindUsersByOrganizationScan(results pgx.BatchResults) ([]FindUsersByOrganizationRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByOrganizationBatch: %w", err)
	}
	defer rows.Close()
	items := []FindUsersByOrganizationRow{}
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersByOrganizationRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersByOrganizationBatch row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersByOrganizationBatch rows: %w", err)
	}
	return items, err
}

const findUsersByTeamIDSQL = `SELECT
    u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
JOIN team_memberships tm USING (username)
JOIN teams t USING (team_id)
WHERE t.team_id = $1
;`

type FindUsersByTeamIDRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []Teams            `json:"teams"`
}

// FindUsersByTeamID implements Querier.FindUsersByTeamID.
func (q *DBQuerier) FindUsersByTeamID(ctx context.Context, teamID pgtype.Text) ([]FindUsersByTeamIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUsersByTeamID")
	rows, err := q.conn.Query(ctx, findUsersByTeamIDSQL, teamID)
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByTeamID: %w", err)
	}
	defer rows.Close()
	items := []FindUsersByTeamIDRow{}
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersByTeamIDRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersByTeamID row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeamID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersByTeamID rows: %w", err)
	}
	return items, err
}

// FindUsersByTeamIDBatch implements Querier.FindUsersByTeamIDBatch.
func (q *DBQuerier) FindUsersByTeamIDBatch(batch genericBatch, teamID pgtype.Text) {
	batch.Queue(findUsersByTeamIDSQL, teamID)
}

// FindUsersByTeamIDScan implements Querier.FindUsersByTeamIDScan.
func (q *DBQuerier) FindUsersByTeamIDScan(results pgx.BatchResults) ([]FindUsersByTeamIDRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByTeamIDBatch: %w", err)
	}
	defer rows.Close()
	items := []FindUsersByTeamIDRow{}
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersByTeamIDRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersByTeamIDBatch row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeamID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersByTeamIDBatch rows: %w", err)
	}
	return items, err
}

const findUserByIDSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
WHERE u.user_id = $1
;`

type FindUserByIDRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []Teams            `json:"teams"`
}

// FindUserByID implements Querier.FindUserByID.
func (q *DBQuerier) FindUserByID(ctx context.Context, userID pgtype.Text) (FindUserByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByID")
	row := q.conn.QueryRow(ctx, findUserByIDSQL, userID)
	var item FindUserByIDRow
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
		return item, fmt.Errorf("query FindUserByID: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	return item, nil
}

// FindUserByIDBatch implements Querier.FindUserByIDBatch.
func (q *DBQuerier) FindUserByIDBatch(batch genericBatch, userID pgtype.Text) {
	batch.Queue(findUserByIDSQL, userID)
}

// FindUserByIDScan implements Querier.FindUserByIDScan.
func (q *DBQuerier) FindUserByIDScan(results pgx.BatchResults) (FindUserByIDRow, error) {
	row := results.QueryRow()
	var item FindUserByIDRow
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
		return item, fmt.Errorf("scan FindUserByIDBatch row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	return item, nil
}

const findUserByUsernameSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
WHERE u.username = $1
;`

type FindUserByUsernameRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []Teams            `json:"teams"`
}

// FindUserByUsername implements Querier.FindUserByUsername.
func (q *DBQuerier) FindUserByUsername(ctx context.Context, username pgtype.Text) (FindUserByUsernameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByUsername")
	row := q.conn.QueryRow(ctx, findUserByUsernameSQL, username)
	var item FindUserByUsernameRow
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
		return item, fmt.Errorf("query FindUserByUsername: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	return item, nil
}

// FindUserByUsernameBatch implements Querier.FindUserByUsernameBatch.
func (q *DBQuerier) FindUserByUsernameBatch(batch genericBatch, username pgtype.Text) {
	batch.Queue(findUserByUsernameSQL, username)
}

// FindUserByUsernameScan implements Querier.FindUserByUsernameScan.
func (q *DBQuerier) FindUserByUsernameScan(results pgx.BatchResults) (FindUserByUsernameRow, error) {
	row := results.QueryRow()
	var item FindUserByUsernameRow
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
		return item, fmt.Errorf("scan FindUserByUsernameBatch row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	return item, nil
}

const findUserByAuthenticationTokenIDSQL = `SELECT u.*,
    (
        SELECT array_agg(t)
        FROM teams t
        JOIN team_memberships tm USING (team_id)
        WHERE tm.username = u.username
    ) AS teams
FROM users u
JOIN tokens t ON u.username = t.username
WHERE t.token_id = $1
;`

type FindUserByAuthenticationTokenIDRow struct {
	UserID    pgtype.Text        `json:"user_id"`
	Username  pgtype.Text        `json:"username"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	SiteAdmin pgtype.Bool        `json:"site_admin"`
	Teams     []Teams            `json:"teams"`
}

// FindUserByAuthenticationTokenID implements Querier.FindUserByAuthenticationTokenID.
func (q *DBQuerier) FindUserByAuthenticationTokenID(ctx context.Context, tokenID pgtype.Text) (FindUserByAuthenticationTokenIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByAuthenticationTokenID")
	row := q.conn.QueryRow(ctx, findUserByAuthenticationTokenIDSQL, tokenID)
	var item FindUserByAuthenticationTokenIDRow
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
		return item, fmt.Errorf("query FindUserByAuthenticationTokenID: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	return item, nil
}

// FindUserByAuthenticationTokenIDBatch implements Querier.FindUserByAuthenticationTokenIDBatch.
func (q *DBQuerier) FindUserByAuthenticationTokenIDBatch(batch genericBatch, tokenID pgtype.Text) {
	batch.Queue(findUserByAuthenticationTokenIDSQL, tokenID)
}

// FindUserByAuthenticationTokenIDScan implements Querier.FindUserByAuthenticationTokenIDScan.
func (q *DBQuerier) FindUserByAuthenticationTokenIDScan(results pgx.BatchResults) (FindUserByAuthenticationTokenIDRow, error) {
	row := results.QueryRow()
	var item FindUserByAuthenticationTokenIDRow
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, &item.SiteAdmin, teamsArray); err != nil {
		return item, fmt.Errorf("scan FindUserByAuthenticationTokenIDBatch row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	return item, nil
}

const updateUserSiteAdminsSQL = `UPDATE users
SET site_admin = true
WHERE username = ANY($1::text[])
RETURNING username
;`

// UpdateUserSiteAdmins implements Querier.UpdateUserSiteAdmins.
func (q *DBQuerier) UpdateUserSiteAdmins(ctx context.Context, usernames []string) ([]pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateUserSiteAdmins")
	rows, err := q.conn.Query(ctx, updateUserSiteAdminsSQL, usernames)
	if err != nil {
		return nil, fmt.Errorf("query UpdateUserSiteAdmins: %w", err)
	}
	defer rows.Close()
	items := []pgtype.Text{}
	for rows.Next() {
		var item pgtype.Text
		if err := rows.Scan(&item); err != nil {
			return nil, fmt.Errorf("scan UpdateUserSiteAdmins row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close UpdateUserSiteAdmins rows: %w", err)
	}
	return items, err
}

// UpdateUserSiteAdminsBatch implements Querier.UpdateUserSiteAdminsBatch.
func (q *DBQuerier) UpdateUserSiteAdminsBatch(batch genericBatch, usernames []string) {
	batch.Queue(updateUserSiteAdminsSQL, usernames)
}

// UpdateUserSiteAdminsScan implements Querier.UpdateUserSiteAdminsScan.
func (q *DBQuerier) UpdateUserSiteAdminsScan(results pgx.BatchResults) ([]pgtype.Text, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query UpdateUserSiteAdminsBatch: %w", err)
	}
	defer rows.Close()
	items := []pgtype.Text{}
	for rows.Next() {
		var item pgtype.Text
		if err := rows.Scan(&item); err != nil {
			return nil, fmt.Errorf("scan UpdateUserSiteAdminsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close UpdateUserSiteAdminsBatch rows: %w", err)
	}
	return items, err
}

const resetUserSiteAdminsSQL = `UPDATE users
SET site_admin = false
WHERE site_admin = true
RETURNING username
;`

// ResetUserSiteAdmins implements Querier.ResetUserSiteAdmins.
func (q *DBQuerier) ResetUserSiteAdmins(ctx context.Context) ([]pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ResetUserSiteAdmins")
	rows, err := q.conn.Query(ctx, resetUserSiteAdminsSQL)
	if err != nil {
		return nil, fmt.Errorf("query ResetUserSiteAdmins: %w", err)
	}
	defer rows.Close()
	items := []pgtype.Text{}
	for rows.Next() {
		var item pgtype.Text
		if err := rows.Scan(&item); err != nil {
			return nil, fmt.Errorf("scan ResetUserSiteAdmins row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ResetUserSiteAdmins rows: %w", err)
	}
	return items, err
}

// ResetUserSiteAdminsBatch implements Querier.ResetUserSiteAdminsBatch.
func (q *DBQuerier) ResetUserSiteAdminsBatch(batch genericBatch) {
	batch.Queue(resetUserSiteAdminsSQL)
}

// ResetUserSiteAdminsScan implements Querier.ResetUserSiteAdminsScan.
func (q *DBQuerier) ResetUserSiteAdminsScan(results pgx.BatchResults) ([]pgtype.Text, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query ResetUserSiteAdminsBatch: %w", err)
	}
	defer rows.Close()
	items := []pgtype.Text{}
	for rows.Next() {
		var item pgtype.Text
		if err := rows.Scan(&item); err != nil {
			return nil, fmt.Errorf("scan ResetUserSiteAdminsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ResetUserSiteAdminsBatch rows: %w", err)
	}
	return items, err
}

const deleteUserByIDSQL = `DELETE
FROM users
WHERE user_id = $1
RETURNING user_id
;`

// DeleteUserByID implements Querier.DeleteUserByID.
func (q *DBQuerier) DeleteUserByID(ctx context.Context, userID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteUserByID")
	row := q.conn.QueryRow(ctx, deleteUserByIDSQL, userID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteUserByID: %w", err)
	}
	return item, nil
}

// DeleteUserByIDBatch implements Querier.DeleteUserByIDBatch.
func (q *DBQuerier) DeleteUserByIDBatch(batch genericBatch, userID pgtype.Text) {
	batch.Queue(deleteUserByIDSQL, userID)
}

// DeleteUserByIDScan implements Querier.DeleteUserByIDScan.
func (q *DBQuerier) DeleteUserByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteUserByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteUserByUsernameSQL = `DELETE
FROM users
WHERE username = $1
RETURNING user_id
;`

// DeleteUserByUsername implements Querier.DeleteUserByUsername.
func (q *DBQuerier) DeleteUserByUsername(ctx context.Context, username pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteUserByUsername")
	row := q.conn.QueryRow(ctx, deleteUserByUsernameSQL, username)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteUserByUsername: %w", err)
	}
	return item, nil
}

// DeleteUserByUsernameBatch implements Querier.DeleteUserByUsernameBatch.
func (q *DBQuerier) DeleteUserByUsernameBatch(batch genericBatch, username pgtype.Text) {
	batch.Queue(deleteUserByUsernameSQL, username)
}

// DeleteUserByUsernameScan implements Querier.DeleteUserByUsernameScan.
func (q *DBQuerier) DeleteUserByUsernameScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteUserByUsernameBatch row: %w", err)
	}
	return item, nil
}
