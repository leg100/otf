// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertNotificationConfigurationSQL = `INSERT INTO notification_configurations (
    notification_configuration_id,
    created_at,
    updated_at,
    name,
    url,
    triggers,
    destination_type,
    enabled,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9
)
;`

type InsertNotificationConfigurationParams struct {
	NotificationConfigurationID pgtype.Text
	CreatedAt                   pgtype.Timestamptz
	UpdatedAt                   pgtype.Timestamptz
	Name                        pgtype.Text
	URL                         pgtype.Text
	Triggers                    []string
	DestinationType             pgtype.Text
	Enabled                     bool
	WorkspaceID                 pgtype.Text
}

// InsertNotificationConfiguration implements Querier.InsertNotificationConfiguration.
func (q *DBQuerier) InsertNotificationConfiguration(ctx context.Context, params InsertNotificationConfigurationParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertNotificationConfiguration")
	cmdTag, err := q.conn.Exec(ctx, insertNotificationConfigurationSQL, params.NotificationConfigurationID, params.CreatedAt, params.UpdatedAt, params.Name, params.URL, params.Triggers, params.DestinationType, params.Enabled, params.WorkspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertNotificationConfiguration: %w", err)
	}
	return cmdTag, err
}

// InsertNotificationConfigurationBatch implements Querier.InsertNotificationConfigurationBatch.
func (q *DBQuerier) InsertNotificationConfigurationBatch(batch genericBatch, params InsertNotificationConfigurationParams) {
	batch.Queue(insertNotificationConfigurationSQL, params.NotificationConfigurationID, params.CreatedAt, params.UpdatedAt, params.Name, params.URL, params.Triggers, params.DestinationType, params.Enabled, params.WorkspaceID)
}

// InsertNotificationConfigurationScan implements Querier.InsertNotificationConfigurationScan.
func (q *DBQuerier) InsertNotificationConfigurationScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertNotificationConfigurationBatch: %w", err)
	}
	return cmdTag, err
}

const findNotificationConfigurationsSQL = `SELECT *
FROM notification_configurations
WHERE workspace_id = $1
;`

type FindNotificationConfigurationsRow struct {
	NotificationConfigurationID pgtype.Text        `json:"notification_configuration_id"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                   pgtype.Timestamptz `json:"updated_at"`
	Name                        pgtype.Text        `json:"name"`
	URL                         pgtype.Text        `json:"url"`
	Triggers                    []string           `json:"triggers"`
	DestinationType             pgtype.Text        `json:"destination_type"`
	WorkspaceID                 pgtype.Text        `json:"workspace_id"`
	Enabled                     bool               `json:"enabled"`
}

// FindNotificationConfigurations implements Querier.FindNotificationConfigurations.
func (q *DBQuerier) FindNotificationConfigurations(ctx context.Context, workspaceID pgtype.Text) ([]FindNotificationConfigurationsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindNotificationConfigurations")
	rows, err := q.conn.Query(ctx, findNotificationConfigurationsSQL, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("query FindNotificationConfigurations: %w", err)
	}
	defer rows.Close()
	items := []FindNotificationConfigurationsRow{}
	for rows.Next() {
		var item FindNotificationConfigurationsRow
		if err := rows.Scan(&item.NotificationConfigurationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.URL, &item.Triggers, &item.DestinationType, &item.WorkspaceID, &item.Enabled); err != nil {
			return nil, fmt.Errorf("scan FindNotificationConfigurations row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindNotificationConfigurations rows: %w", err)
	}
	return items, err
}

// FindNotificationConfigurationsBatch implements Querier.FindNotificationConfigurationsBatch.
func (q *DBQuerier) FindNotificationConfigurationsBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(findNotificationConfigurationsSQL, workspaceID)
}

// FindNotificationConfigurationsScan implements Querier.FindNotificationConfigurationsScan.
func (q *DBQuerier) FindNotificationConfigurationsScan(results pgx.BatchResults) ([]FindNotificationConfigurationsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindNotificationConfigurationsBatch: %w", err)
	}
	defer rows.Close()
	items := []FindNotificationConfigurationsRow{}
	for rows.Next() {
		var item FindNotificationConfigurationsRow
		if err := rows.Scan(&item.NotificationConfigurationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.URL, &item.Triggers, &item.DestinationType, &item.WorkspaceID, &item.Enabled); err != nil {
			return nil, fmt.Errorf("scan FindNotificationConfigurationsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindNotificationConfigurationsBatch rows: %w", err)
	}
	return items, err
}

const findNotificationConfigurationSQL = `SELECT *
FROM notification_configurations
WHERE notification_configuration_id = $1
;`

type FindNotificationConfigurationRow struct {
	NotificationConfigurationID pgtype.Text        `json:"notification_configuration_id"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                   pgtype.Timestamptz `json:"updated_at"`
	Name                        pgtype.Text        `json:"name"`
	URL                         pgtype.Text        `json:"url"`
	Triggers                    []string           `json:"triggers"`
	DestinationType             pgtype.Text        `json:"destination_type"`
	WorkspaceID                 pgtype.Text        `json:"workspace_id"`
	Enabled                     bool               `json:"enabled"`
}

// FindNotificationConfiguration implements Querier.FindNotificationConfiguration.
func (q *DBQuerier) FindNotificationConfiguration(ctx context.Context, notificationConfigurationID pgtype.Text) (FindNotificationConfigurationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindNotificationConfiguration")
	row := q.conn.QueryRow(ctx, findNotificationConfigurationSQL, notificationConfigurationID)
	var item FindNotificationConfigurationRow
	if err := row.Scan(&item.NotificationConfigurationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.URL, &item.Triggers, &item.DestinationType, &item.WorkspaceID, &item.Enabled); err != nil {
		return item, fmt.Errorf("query FindNotificationConfiguration: %w", err)
	}
	return item, nil
}

// FindNotificationConfigurationBatch implements Querier.FindNotificationConfigurationBatch.
func (q *DBQuerier) FindNotificationConfigurationBatch(batch genericBatch, notificationConfigurationID pgtype.Text) {
	batch.Queue(findNotificationConfigurationSQL, notificationConfigurationID)
}

// FindNotificationConfigurationScan implements Querier.FindNotificationConfigurationScan.
func (q *DBQuerier) FindNotificationConfigurationScan(results pgx.BatchResults) (FindNotificationConfigurationRow, error) {
	row := results.QueryRow()
	var item FindNotificationConfigurationRow
	if err := row.Scan(&item.NotificationConfigurationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.URL, &item.Triggers, &item.DestinationType, &item.WorkspaceID, &item.Enabled); err != nil {
		return item, fmt.Errorf("scan FindNotificationConfigurationBatch row: %w", err)
	}
	return item, nil
}

const findNotificationConfigurationForUpdateSQL = `SELECT *
FROM notification_configurations
WHERE notification_configuration_id = $1
FOR UPDATE
;`

type FindNotificationConfigurationForUpdateRow struct {
	NotificationConfigurationID pgtype.Text        `json:"notification_configuration_id"`
	CreatedAt                   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                   pgtype.Timestamptz `json:"updated_at"`
	Name                        pgtype.Text        `json:"name"`
	URL                         pgtype.Text        `json:"url"`
	Triggers                    []string           `json:"triggers"`
	DestinationType             pgtype.Text        `json:"destination_type"`
	WorkspaceID                 pgtype.Text        `json:"workspace_id"`
	Enabled                     bool               `json:"enabled"`
}

// FindNotificationConfigurationForUpdate implements Querier.FindNotificationConfigurationForUpdate.
func (q *DBQuerier) FindNotificationConfigurationForUpdate(ctx context.Context, notificationConfigurationID pgtype.Text) (FindNotificationConfigurationForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindNotificationConfigurationForUpdate")
	row := q.conn.QueryRow(ctx, findNotificationConfigurationForUpdateSQL, notificationConfigurationID)
	var item FindNotificationConfigurationForUpdateRow
	if err := row.Scan(&item.NotificationConfigurationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.URL, &item.Triggers, &item.DestinationType, &item.WorkspaceID, &item.Enabled); err != nil {
		return item, fmt.Errorf("query FindNotificationConfigurationForUpdate: %w", err)
	}
	return item, nil
}

// FindNotificationConfigurationForUpdateBatch implements Querier.FindNotificationConfigurationForUpdateBatch.
func (q *DBQuerier) FindNotificationConfigurationForUpdateBatch(batch genericBatch, notificationConfigurationID pgtype.Text) {
	batch.Queue(findNotificationConfigurationForUpdateSQL, notificationConfigurationID)
}

// FindNotificationConfigurationForUpdateScan implements Querier.FindNotificationConfigurationForUpdateScan.
func (q *DBQuerier) FindNotificationConfigurationForUpdateScan(results pgx.BatchResults) (FindNotificationConfigurationForUpdateRow, error) {
	row := results.QueryRow()
	var item FindNotificationConfigurationForUpdateRow
	if err := row.Scan(&item.NotificationConfigurationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.URL, &item.Triggers, &item.DestinationType, &item.WorkspaceID, &item.Enabled); err != nil {
		return item, fmt.Errorf("scan FindNotificationConfigurationForUpdateBatch row: %w", err)
	}
	return item, nil
}

const updateNotificationConfigurationByIDSQL = `UPDATE notification_configurations
SET
    updated_at = $1,
    enabled    = $2,
    name       = $3,
    triggers   = $4,
    url        = $5
WHERE notification_configuration_id = $6
RETURNING notification_configuration_id
;`

type UpdateNotificationConfigurationByIDParams struct {
	UpdatedAt                   pgtype.Timestamptz
	Enabled                     bool
	Name                        pgtype.Text
	Triggers                    []string
	URL                         pgtype.Text
	NotificationConfigurationID pgtype.Text
}

// UpdateNotificationConfigurationByID implements Querier.UpdateNotificationConfigurationByID.
func (q *DBQuerier) UpdateNotificationConfigurationByID(ctx context.Context, params UpdateNotificationConfigurationByIDParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateNotificationConfigurationByID")
	row := q.conn.QueryRow(ctx, updateNotificationConfigurationByIDSQL, params.UpdatedAt, params.Enabled, params.Name, params.Triggers, params.URL, params.NotificationConfigurationID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateNotificationConfigurationByID: %w", err)
	}
	return item, nil
}

// UpdateNotificationConfigurationByIDBatch implements Querier.UpdateNotificationConfigurationByIDBatch.
func (q *DBQuerier) UpdateNotificationConfigurationByIDBatch(batch genericBatch, params UpdateNotificationConfigurationByIDParams) {
	batch.Queue(updateNotificationConfigurationByIDSQL, params.UpdatedAt, params.Enabled, params.Name, params.Triggers, params.URL, params.NotificationConfigurationID)
}

// UpdateNotificationConfigurationByIDScan implements Querier.UpdateNotificationConfigurationByIDScan.
func (q *DBQuerier) UpdateNotificationConfigurationByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateNotificationConfigurationByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteNotificationConfigurationByIDSQL = `DELETE FROM notification_configurations
WHERE notification_configuration_id = $1
RETURNING notification_configuration_id
;`

// DeleteNotificationConfigurationByID implements Querier.DeleteNotificationConfigurationByID.
func (q *DBQuerier) DeleteNotificationConfigurationByID(ctx context.Context, notificationConfigurationID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteNotificationConfigurationByID")
	row := q.conn.QueryRow(ctx, deleteNotificationConfigurationByIDSQL, notificationConfigurationID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteNotificationConfigurationByID: %w", err)
	}
	return item, nil
}

// DeleteNotificationConfigurationByIDBatch implements Querier.DeleteNotificationConfigurationByIDBatch.
func (q *DBQuerier) DeleteNotificationConfigurationByIDBatch(batch genericBatch, notificationConfigurationID pgtype.Text) {
	batch.Queue(deleteNotificationConfigurationByIDSQL, notificationConfigurationID)
}

// DeleteNotificationConfigurationByIDScan implements Querier.DeleteNotificationConfigurationByIDScan.
func (q *DBQuerier) DeleteNotificationConfigurationByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteNotificationConfigurationByIDBatch row: %w", err)
	}
	return item, nil
}
