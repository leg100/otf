// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertGithubAppSQL = `INSERT INTO github_apps (
    github_app_id,
    app_id,
    webhook_secret,
    private_key,
    organization_name
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
);`

type InsertGithubAppParams struct {
	GithubAppID      pgtype.Text
	AppID            pgtype.Int8
	WebhookSecret    pgtype.Text
	PrivateKey       pgtype.Text
	OrganizationName pgtype.Text
}

// InsertGithubApp implements Querier.InsertGithubApp.
func (q *DBQuerier) InsertGithubApp(ctx context.Context, params InsertGithubAppParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertGithubApp")
	cmdTag, err := q.conn.Exec(ctx, insertGithubAppSQL, params.GithubAppID, params.AppID, params.WebhookSecret, params.PrivateKey, params.OrganizationName)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertGithubApp: %w", err)
	}
	return cmdTag, err
}

// InsertGithubAppBatch implements Querier.InsertGithubAppBatch.
func (q *DBQuerier) InsertGithubAppBatch(batch genericBatch, params InsertGithubAppParams) {
	batch.Queue(insertGithubAppSQL, params.GithubAppID, params.AppID, params.WebhookSecret, params.PrivateKey, params.OrganizationName)
}

// InsertGithubAppScan implements Querier.InsertGithubAppScan.
func (q *DBQuerier) InsertGithubAppScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertGithubAppBatch: %w", err)
	}
	return cmdTag, err
}

const findGithubAppsByOrganizationSQL = `SELECT *
FROM github_apps
WHERE organization_name = $1;`

type FindGithubAppsByOrganizationRow struct {
	GithubAppID      pgtype.Text `json:"github_app_id"`
	AppID            pgtype.Int8 `json:"app_id"`
	WebhookSecret    pgtype.Text `json:"webhook_secret"`
	PrivateKey       pgtype.Text `json:"private_key"`
	OrganizationName pgtype.Text `json:"organization_name"`
}

// FindGithubAppsByOrganization implements Querier.FindGithubAppsByOrganization.
func (q *DBQuerier) FindGithubAppsByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindGithubAppsByOrganizationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindGithubAppsByOrganization")
	rows, err := q.conn.Query(ctx, findGithubAppsByOrganizationSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindGithubAppsByOrganization: %w", err)
	}
	defer rows.Close()
	items := []FindGithubAppsByOrganizationRow{}
	for rows.Next() {
		var item FindGithubAppsByOrganizationRow
		if err := rows.Scan(&item.GithubAppID, &item.AppID, &item.WebhookSecret, &item.PrivateKey, &item.OrganizationName); err != nil {
			return nil, fmt.Errorf("scan FindGithubAppsByOrganization row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindGithubAppsByOrganization rows: %w", err)
	}
	return items, err
}

// FindGithubAppsByOrganizationBatch implements Querier.FindGithubAppsByOrganizationBatch.
func (q *DBQuerier) FindGithubAppsByOrganizationBatch(batch genericBatch, organizationName pgtype.Text) {
	batch.Queue(findGithubAppsByOrganizationSQL, organizationName)
}

// FindGithubAppsByOrganizationScan implements Querier.FindGithubAppsByOrganizationScan.
func (q *DBQuerier) FindGithubAppsByOrganizationScan(results pgx.BatchResults) ([]FindGithubAppsByOrganizationRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindGithubAppsByOrganizationBatch: %w", err)
	}
	defer rows.Close()
	items := []FindGithubAppsByOrganizationRow{}
	for rows.Next() {
		var item FindGithubAppsByOrganizationRow
		if err := rows.Scan(&item.GithubAppID, &item.AppID, &item.WebhookSecret, &item.PrivateKey, &item.OrganizationName); err != nil {
			return nil, fmt.Errorf("scan FindGithubAppsByOrganizationBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindGithubAppsByOrganizationBatch rows: %w", err)
	}
	return items, err
}

const findGithubAppByIDSQL = `SELECT *
FROM github_apps
WHERE github_app_id = $1;`

type FindGithubAppByIDRow struct {
	GithubAppID      pgtype.Text `json:"github_app_id"`
	AppID            pgtype.Int8 `json:"app_id"`
	WebhookSecret    pgtype.Text `json:"webhook_secret"`
	PrivateKey       pgtype.Text `json:"private_key"`
	OrganizationName pgtype.Text `json:"organization_name"`
}

// FindGithubAppByID implements Querier.FindGithubAppByID.
func (q *DBQuerier) FindGithubAppByID(ctx context.Context, githubAppID pgtype.Text) (FindGithubAppByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindGithubAppByID")
	row := q.conn.QueryRow(ctx, findGithubAppByIDSQL, githubAppID)
	var item FindGithubAppByIDRow
	if err := row.Scan(&item.GithubAppID, &item.AppID, &item.WebhookSecret, &item.PrivateKey, &item.OrganizationName); err != nil {
		return item, fmt.Errorf("query FindGithubAppByID: %w", err)
	}
	return item, nil
}

// FindGithubAppByIDBatch implements Querier.FindGithubAppByIDBatch.
func (q *DBQuerier) FindGithubAppByIDBatch(batch genericBatch, githubAppID pgtype.Text) {
	batch.Queue(findGithubAppByIDSQL, githubAppID)
}

// FindGithubAppByIDScan implements Querier.FindGithubAppByIDScan.
func (q *DBQuerier) FindGithubAppByIDScan(results pgx.BatchResults) (FindGithubAppByIDRow, error) {
	row := results.QueryRow()
	var item FindGithubAppByIDRow
	if err := row.Scan(&item.GithubAppID, &item.AppID, &item.WebhookSecret, &item.PrivateKey, &item.OrganizationName); err != nil {
		return item, fmt.Errorf("scan FindGithubAppByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteGithubAppByIDSQL = `DELETE
FROM github_apps
WHERE github_app_id = $1
RETURNING *;`

type DeleteGithubAppByIDRow struct {
	GithubAppID      pgtype.Text `json:"github_app_id"`
	AppID            pgtype.Int8 `json:"app_id"`
	WebhookSecret    pgtype.Text `json:"webhook_secret"`
	PrivateKey       pgtype.Text `json:"private_key"`
	OrganizationName pgtype.Text `json:"organization_name"`
}

// DeleteGithubAppByID implements Querier.DeleteGithubAppByID.
func (q *DBQuerier) DeleteGithubAppByID(ctx context.Context, githubAppID pgtype.Text) (DeleteGithubAppByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteGithubAppByID")
	row := q.conn.QueryRow(ctx, deleteGithubAppByIDSQL, githubAppID)
	var item DeleteGithubAppByIDRow
	if err := row.Scan(&item.GithubAppID, &item.AppID, &item.WebhookSecret, &item.PrivateKey, &item.OrganizationName); err != nil {
		return item, fmt.Errorf("query DeleteGithubAppByID: %w", err)
	}
	return item, nil
}

// DeleteGithubAppByIDBatch implements Querier.DeleteGithubAppByIDBatch.
func (q *DBQuerier) DeleteGithubAppByIDBatch(batch genericBatch, githubAppID pgtype.Text) {
	batch.Queue(deleteGithubAppByIDSQL, githubAppID)
}

// DeleteGithubAppByIDScan implements Querier.DeleteGithubAppByIDScan.
func (q *DBQuerier) DeleteGithubAppByIDScan(results pgx.BatchResults) (DeleteGithubAppByIDRow, error) {
	row := results.QueryRow()
	var item DeleteGithubAppByIDRow
	if err := row.Scan(&item.GithubAppID, &item.AppID, &item.WebhookSecret, &item.PrivateKey, &item.OrganizationName); err != nil {
		return item, fmt.Errorf("scan DeleteGithubAppByIDBatch row: %w", err)
	}
	return item, nil
}

const insertGithubAppInstallSQL = `INSERT INTO github_app_installs (
    github_app_install_id,
    install_id,
    github_app_id
) VALUES (
    $1,
    $2,
    $3
);`

type InsertGithubAppInstallParams struct {
	GithubAppInstallID pgtype.Text
	InstallID          pgtype.Int8
	GithubAppID        pgtype.Text
}

// InsertGithubAppInstall implements Querier.InsertGithubAppInstall.
func (q *DBQuerier) InsertGithubAppInstall(ctx context.Context, params InsertGithubAppInstallParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertGithubAppInstall")
	cmdTag, err := q.conn.Exec(ctx, insertGithubAppInstallSQL, params.GithubAppInstallID, params.InstallID, params.GithubAppID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertGithubAppInstall: %w", err)
	}
	return cmdTag, err
}

// InsertGithubAppInstallBatch implements Querier.InsertGithubAppInstallBatch.
func (q *DBQuerier) InsertGithubAppInstallBatch(batch genericBatch, params InsertGithubAppInstallParams) {
	batch.Queue(insertGithubAppInstallSQL, params.GithubAppInstallID, params.InstallID, params.GithubAppID)
}

// InsertGithubAppInstallScan implements Querier.InsertGithubAppInstallScan.
func (q *DBQuerier) InsertGithubAppInstallScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertGithubAppInstallBatch: %w", err)
	}
	return cmdTag, err
}

const findGithubAppInstallByIDSQL = `SELECT *
FROM github_app_installs
JOIN github_apps USING (github_app_id)
WHERE github_app_install_id = $1;`

type FindGithubAppInstallByIDRow struct {
	GithubAppID        pgtype.Text `json:"github_app_id"`
	GithubAppInstallID pgtype.Text `json:"github_app_install_id"`
	InstallID          pgtype.Int8 `json:"install_id"`
	AppID              pgtype.Int8 `json:"app_id"`
	WebhookSecret      pgtype.Text `json:"webhook_secret"`
	PrivateKey         pgtype.Text `json:"private_key"`
	OrganizationName   pgtype.Text `json:"organization_name"`
}

// FindGithubAppInstallByID implements Querier.FindGithubAppInstallByID.
func (q *DBQuerier) FindGithubAppInstallByID(ctx context.Context, githubAppInstallID pgtype.Text) (FindGithubAppInstallByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindGithubAppInstallByID")
	row := q.conn.QueryRow(ctx, findGithubAppInstallByIDSQL, githubAppInstallID)
	var item FindGithubAppInstallByIDRow
	if err := row.Scan(&item.GithubAppID, &item.GithubAppInstallID, &item.InstallID, &item.AppID, &item.WebhookSecret, &item.PrivateKey, &item.OrganizationName); err != nil {
		return item, fmt.Errorf("query FindGithubAppInstallByID: %w", err)
	}
	return item, nil
}

// FindGithubAppInstallByIDBatch implements Querier.FindGithubAppInstallByIDBatch.
func (q *DBQuerier) FindGithubAppInstallByIDBatch(batch genericBatch, githubAppInstallID pgtype.Text) {
	batch.Queue(findGithubAppInstallByIDSQL, githubAppInstallID)
}

// FindGithubAppInstallByIDScan implements Querier.FindGithubAppInstallByIDScan.
func (q *DBQuerier) FindGithubAppInstallByIDScan(results pgx.BatchResults) (FindGithubAppInstallByIDRow, error) {
	row := results.QueryRow()
	var item FindGithubAppInstallByIDRow
	if err := row.Scan(&item.GithubAppID, &item.GithubAppInstallID, &item.InstallID, &item.AppID, &item.WebhookSecret, &item.PrivateKey, &item.OrganizationName); err != nil {
		return item, fmt.Errorf("scan FindGithubAppInstallByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteGithubAppInstallByIDSQL = `DELETE
FROM github_app_installs
WHERE github_app_install_id = $1
RETURNING *;`

type DeleteGithubAppInstallByIDRow struct {
	GithubAppInstallID pgtype.Text `json:"github_app_install_id"`
	InstallID          pgtype.Int8 `json:"install_id"`
	GithubAppID        pgtype.Text `json:"github_app_id"`
}

// DeleteGithubAppInstallByID implements Querier.DeleteGithubAppInstallByID.
func (q *DBQuerier) DeleteGithubAppInstallByID(ctx context.Context, githubAppInstallID pgtype.Text) (DeleteGithubAppInstallByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteGithubAppInstallByID")
	row := q.conn.QueryRow(ctx, deleteGithubAppInstallByIDSQL, githubAppInstallID)
	var item DeleteGithubAppInstallByIDRow
	if err := row.Scan(&item.GithubAppInstallID, &item.InstallID, &item.GithubAppID); err != nil {
		return item, fmt.Errorf("query DeleteGithubAppInstallByID: %w", err)
	}
	return item, nil
}

// DeleteGithubAppInstallByIDBatch implements Querier.DeleteGithubAppInstallByIDBatch.
func (q *DBQuerier) DeleteGithubAppInstallByIDBatch(batch genericBatch, githubAppInstallID pgtype.Text) {
	batch.Queue(deleteGithubAppInstallByIDSQL, githubAppInstallID)
}

// DeleteGithubAppInstallByIDScan implements Querier.DeleteGithubAppInstallByIDScan.
func (q *DBQuerier) DeleteGithubAppInstallByIDScan(results pgx.BatchResults) (DeleteGithubAppInstallByIDRow, error) {
	row := results.QueryRow()
	var item DeleteGithubAppInstallByIDRow
	if err := row.Scan(&item.GithubAppInstallID, &item.InstallID, &item.GithubAppID); err != nil {
		return item, fmt.Errorf("scan DeleteGithubAppInstallByIDBatch row: %w", err)
	}
	return item, nil
}
