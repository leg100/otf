// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertGithubAppSQL = `INSERT INTO github_apps (
    github_app_id,
    webhook_secret,
    private_key,
    slug,
    organization
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
);`

type InsertGithubAppParams struct {
	GithubAppID   pgtype.Int8
	WebhookSecret pgtype.Text
	PrivateKey    pgtype.Text
	Slug          pgtype.Text
	Organization  pgtype.Text
}

// InsertGithubApp implements Querier.InsertGithubApp.
func (q *DBQuerier) InsertGithubApp(ctx context.Context, params InsertGithubAppParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertGithubApp")
	cmdTag, err := q.conn.Exec(ctx, insertGithubAppSQL, params.GithubAppID, params.WebhookSecret, params.PrivateKey, params.Slug, params.Organization)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertGithubApp: %w", err)
	}
	return cmdTag, err
}

// InsertGithubAppBatch implements Querier.InsertGithubAppBatch.
func (q *DBQuerier) InsertGithubAppBatch(batch genericBatch, params InsertGithubAppParams) {
	batch.Queue(insertGithubAppSQL, params.GithubAppID, params.WebhookSecret, params.PrivateKey, params.Slug, params.Organization)
}

// InsertGithubAppScan implements Querier.InsertGithubAppScan.
func (q *DBQuerier) InsertGithubAppScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertGithubAppBatch: %w", err)
	}
	return cmdTag, err
}

const findGithubAppSQL = `SELECT *
FROM github_apps;`

type FindGithubAppRow struct {
	GithubAppID   pgtype.Int8 `json:"github_app_id"`
	WebhookSecret pgtype.Text `json:"webhook_secret"`
	PrivateKey    pgtype.Text `json:"private_key"`
	Slug          pgtype.Text `json:"slug"`
	Organization  pgtype.Text `json:"organization"`
}

// FindGithubApp implements Querier.FindGithubApp.
func (q *DBQuerier) FindGithubApp(ctx context.Context) (FindGithubAppRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindGithubApp")
	row := q.conn.QueryRow(ctx, findGithubAppSQL)
	var item FindGithubAppRow
	if err := row.Scan(&item.GithubAppID, &item.WebhookSecret, &item.PrivateKey, &item.Slug, &item.Organization); err != nil {
		return item, fmt.Errorf("query FindGithubApp: %w", err)
	}
	return item, nil
}

// FindGithubAppBatch implements Querier.FindGithubAppBatch.
func (q *DBQuerier) FindGithubAppBatch(batch genericBatch) {
	batch.Queue(findGithubAppSQL)
}

// FindGithubAppScan implements Querier.FindGithubAppScan.
func (q *DBQuerier) FindGithubAppScan(results pgx.BatchResults) (FindGithubAppRow, error) {
	row := results.QueryRow()
	var item FindGithubAppRow
	if err := row.Scan(&item.GithubAppID, &item.WebhookSecret, &item.PrivateKey, &item.Slug, &item.Organization); err != nil {
		return item, fmt.Errorf("scan FindGithubAppBatch row: %w", err)
	}
	return item, nil
}

const deleteGithubAppSQL = `DELETE
FROM github_apps
WHERE github_app_id = $1
RETURNING *;`

type DeleteGithubAppRow struct {
	GithubAppID   pgtype.Int8 `json:"github_app_id"`
	WebhookSecret pgtype.Text `json:"webhook_secret"`
	PrivateKey    pgtype.Text `json:"private_key"`
	Slug          pgtype.Text `json:"slug"`
	Organization  pgtype.Text `json:"organization"`
}

// DeleteGithubApp implements Querier.DeleteGithubApp.
func (q *DBQuerier) DeleteGithubApp(ctx context.Context, githubAppID pgtype.Int8) (DeleteGithubAppRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteGithubApp")
	row := q.conn.QueryRow(ctx, deleteGithubAppSQL, githubAppID)
	var item DeleteGithubAppRow
	if err := row.Scan(&item.GithubAppID, &item.WebhookSecret, &item.PrivateKey, &item.Slug, &item.Organization); err != nil {
		return item, fmt.Errorf("query DeleteGithubApp: %w", err)
	}
	return item, nil
}

// DeleteGithubAppBatch implements Querier.DeleteGithubAppBatch.
func (q *DBQuerier) DeleteGithubAppBatch(batch genericBatch, githubAppID pgtype.Int8) {
	batch.Queue(deleteGithubAppSQL, githubAppID)
}

// DeleteGithubAppScan implements Querier.DeleteGithubAppScan.
func (q *DBQuerier) DeleteGithubAppScan(results pgx.BatchResults) (DeleteGithubAppRow, error) {
	row := results.QueryRow()
	var item DeleteGithubAppRow
	if err := row.Scan(&item.GithubAppID, &item.WebhookSecret, &item.PrivateKey, &item.Slug, &item.Organization); err != nil {
		return item, fmt.Errorf("scan DeleteGithubAppBatch row: %w", err)
	}
	return item, nil
}

const insertGithubAppInstallSQL = `INSERT INTO github_app_installs (
    github_app_id,
    install_id,
    username,
    organization,
    vcs_provider_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
);`

type InsertGithubAppInstallParams struct {
	GithubAppID   pgtype.Int8
	InstallID     pgtype.Int8
	Username      pgtype.Text
	Organization  pgtype.Text
	VCSProviderID pgtype.Text
}

// InsertGithubAppInstall implements Querier.InsertGithubAppInstall.
func (q *DBQuerier) InsertGithubAppInstall(ctx context.Context, params InsertGithubAppInstallParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertGithubAppInstall")
	cmdTag, err := q.conn.Exec(ctx, insertGithubAppInstallSQL, params.GithubAppID, params.InstallID, params.Username, params.Organization, params.VCSProviderID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertGithubAppInstall: %w", err)
	}
	return cmdTag, err
}

// InsertGithubAppInstallBatch implements Querier.InsertGithubAppInstallBatch.
func (q *DBQuerier) InsertGithubAppInstallBatch(batch genericBatch, params InsertGithubAppInstallParams) {
	batch.Queue(insertGithubAppInstallSQL, params.GithubAppID, params.InstallID, params.Username, params.Organization, params.VCSProviderID)
}

// InsertGithubAppInstallScan implements Querier.InsertGithubAppInstallScan.
func (q *DBQuerier) InsertGithubAppInstallScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertGithubAppInstallBatch: %w", err)
	}
	return cmdTag, err
}
