// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: state_version.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countStateVersionsByWorkspaceID = `-- name: CountStateVersionsByWorkspaceID :one
SELECT count(*)
FROM state_versions
WHERE workspace_id = $1
AND status = 'finalized'
`

func (q *Queries) CountStateVersionsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countStateVersionsByWorkspaceID, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteStateVersionByID = `-- name: DeleteStateVersionByID :one
DELETE
FROM state_versions
WHERE state_version_id = $1
RETURNING state_version_id
`

func (q *Queries) DeleteStateVersionByID(ctx context.Context, stateVersionID string) (string, error) {
	row := q.db.QueryRow(ctx, deleteStateVersionByID, stateVersionID)
	var state_version_id string
	err := row.Scan(&state_version_id)
	return state_version_id, err
}

const discardPendingStateVersionsByWorkspaceID = `-- name: DiscardPendingStateVersionsByWorkspaceID :exec
UPDATE state_versions
SET status = 'discarded'
WHERE workspace_id = $1
AND status = 'pending'
`

func (q *Queries) DiscardPendingStateVersionsByWorkspaceID(ctx context.Context, workspaceID pgtype.Text) error {
	_, err := q.db.Exec(ctx, discardPendingStateVersionsByWorkspaceID, workspaceID)
	return err
}

const findCurrentStateVersionByWorkspaceID = `-- name: FindCurrentStateVersionByWorkspaceID :one
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.state_version_output_id)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_ids,
    (
        SELECT array_agg(svo.sensitive)::bool[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_sensitives,
    (
        SELECT array_agg(svo.type)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_types,
    (
        SELECT array_agg(svo.value)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_values,
    (
        SELECT array_agg(svo.name)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_names
FROM state_versions sv
JOIN workspaces w ON w.current_state_version_id = sv.state_version_id
WHERE w.workspace_id = $1
GROUP BY sv.state_version_id
`

type FindCurrentStateVersionByWorkspaceIDRow struct {
	StateVersionID               string
	CreatedAt                    pgtype.Timestamptz
	Serial                       int32
	State                        []byte
	WorkspaceID                  pgtype.Text
	Status                       string
	StateVersionOutputIds        []string
	StateVersionOutputSensitives []bool
	StateVersionOutputTypes      []string
	StateVersionOutputValues     []string
	StateVersionOutputNames      []string
}

func (q *Queries) FindCurrentStateVersionByWorkspaceID(ctx context.Context, workspaceID string) (FindCurrentStateVersionByWorkspaceIDRow, error) {
	row := q.db.QueryRow(ctx, findCurrentStateVersionByWorkspaceID, workspaceID)
	var i FindCurrentStateVersionByWorkspaceIDRow
	err := row.Scan(
		&i.StateVersionID,
		&i.CreatedAt,
		&i.Serial,
		&i.State,
		&i.WorkspaceID,
		&i.Status,
		&i.StateVersionOutputIds,
		&i.StateVersionOutputSensitives,
		&i.StateVersionOutputTypes,
		&i.StateVersionOutputValues,
		&i.StateVersionOutputNames,
	)
	return i, err
}

const findStateVersionByID = `-- name: FindStateVersionByID :one
SELECT
    state_versions.state_version_id, state_versions.created_at, state_versions.serial, state_versions.state, state_versions.workspace_id, state_versions.status,
    (
        SELECT array_agg(svo.state_version_output_id)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_ids,
    (
        SELECT array_agg(svo.sensitive)::bool[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_sensitives,
    (
        SELECT array_agg(svo.type)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_types,
    (
        SELECT array_agg(svo.value)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_values,
    (
        SELECT array_agg(svo.name)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_names
FROM state_versions
WHERE state_versions.state_version_id = $1
GROUP BY state_versions.state_version_id
`

type FindStateVersionByIDRow struct {
	StateVersionID               string
	CreatedAt                    pgtype.Timestamptz
	Serial                       int32
	State                        []byte
	WorkspaceID                  pgtype.Text
	Status                       string
	StateVersionOutputIds        []string
	StateVersionOutputSensitives []bool
	StateVersionOutputTypes      []string
	StateVersionOutputValues     []string
	StateVersionOutputNames      []string
}

func (q *Queries) FindStateVersionByID(ctx context.Context, id string) (FindStateVersionByIDRow, error) {
	row := q.db.QueryRow(ctx, findStateVersionByID, id)
	var i FindStateVersionByIDRow
	err := row.Scan(
		&i.StateVersionID,
		&i.CreatedAt,
		&i.Serial,
		&i.State,
		&i.WorkspaceID,
		&i.Status,
		&i.StateVersionOutputIds,
		&i.StateVersionOutputSensitives,
		&i.StateVersionOutputTypes,
		&i.StateVersionOutputValues,
		&i.StateVersionOutputNames,
	)
	return i, err
}

const findStateVersionByIDForUpdate = `-- name: FindStateVersionByIDForUpdate :one
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.state_version_output_id)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_ids,
    (
        SELECT array_agg(svo.sensitive)::bool[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_sensitives,
    (
        SELECT array_agg(svo.type)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_types,
    (
        SELECT array_agg(svo.value)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_values,
    (
        SELECT array_agg(svo.name)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_names
FROM state_versions sv
WHERE sv.state_version_id = $1
FOR UPDATE OF sv
`

type FindStateVersionByIDForUpdateRow struct {
	StateVersionID               string
	CreatedAt                    pgtype.Timestamptz
	Serial                       int32
	State                        []byte
	WorkspaceID                  pgtype.Text
	Status                       string
	StateVersionOutputIds        []string
	StateVersionOutputSensitives []bool
	StateVersionOutputTypes      []string
	StateVersionOutputValues     []string
	StateVersionOutputNames      []string
}

func (q *Queries) FindStateVersionByIDForUpdate(ctx context.Context, id string) (FindStateVersionByIDForUpdateRow, error) {
	row := q.db.QueryRow(ctx, findStateVersionByIDForUpdate, id)
	var i FindStateVersionByIDForUpdateRow
	err := row.Scan(
		&i.StateVersionID,
		&i.CreatedAt,
		&i.Serial,
		&i.State,
		&i.WorkspaceID,
		&i.Status,
		&i.StateVersionOutputIds,
		&i.StateVersionOutputSensitives,
		&i.StateVersionOutputTypes,
		&i.StateVersionOutputValues,
		&i.StateVersionOutputNames,
	)
	return i, err
}

const findStateVersionStateByID = `-- name: FindStateVersionStateByID :one
SELECT state
FROM state_versions
WHERE state_version_id = $1
`

func (q *Queries) FindStateVersionStateByID(ctx context.Context, id string) ([]byte, error) {
	row := q.db.QueryRow(ctx, findStateVersionStateByID, id)
	var state []byte
	err := row.Scan(&state)
	return state, err
}

const findStateVersionsByWorkspaceID = `-- name: FindStateVersionsByWorkspaceID :many
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.state_version_output_id)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_ids,
    (
        SELECT array_agg(svo.sensitive)::bool[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_sensitives,
    (
        SELECT array_agg(svo.type)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_types,
    (
        SELECT array_agg(svo.value)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_values,
    (
        SELECT array_agg(svo.name)::text[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
    ) AS state_version_output_names
FROM state_versions sv
WHERE sv.workspace_id = $1
AND   sv.status = 'finalized'
GROUP BY sv.state_version_id
ORDER BY created_at DESC
LIMIT $3
OFFSET $2
`

type FindStateVersionsByWorkspaceIDParams struct {
	WorkspaceID pgtype.Text
	Offset      int32
	Limit       int32
}

type FindStateVersionsByWorkspaceIDRow struct {
	StateVersionID               string
	CreatedAt                    pgtype.Timestamptz
	Serial                       int32
	State                        []byte
	WorkspaceID                  pgtype.Text
	Status                       string
	StateVersionOutputIds        []string
	StateVersionOutputSensitives []bool
	StateVersionOutputTypes      []string
	StateVersionOutputValues     []string
	StateVersionOutputNames      []string
}

func (q *Queries) FindStateVersionsByWorkspaceID(ctx context.Context, arg FindStateVersionsByWorkspaceIDParams) ([]FindStateVersionsByWorkspaceIDRow, error) {
	rows, err := q.db.Query(ctx, findStateVersionsByWorkspaceID, arg.WorkspaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindStateVersionsByWorkspaceIDRow
	for rows.Next() {
		var i FindStateVersionsByWorkspaceIDRow
		if err := rows.Scan(
			&i.StateVersionID,
			&i.CreatedAt,
			&i.Serial,
			&i.State,
			&i.WorkspaceID,
			&i.Status,
			&i.StateVersionOutputIds,
			&i.StateVersionOutputSensitives,
			&i.StateVersionOutputTypes,
			&i.StateVersionOutputValues,
			&i.StateVersionOutputNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertStateVersion = `-- name: InsertStateVersion :exec
INSERT INTO state_versions (
    state_version_id,
    created_at,
    serial,
    state,
    status,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
`

type InsertStateVersionParams struct {
	ID          string
	CreatedAt   pgtype.Timestamptz
	Serial      int32
	State       []byte
	Status      string
	WorkspaceID pgtype.Text
}

func (q *Queries) InsertStateVersion(ctx context.Context, arg InsertStateVersionParams) error {
	_, err := q.db.Exec(ctx, insertStateVersion,
		arg.ID,
		arg.CreatedAt,
		arg.Serial,
		arg.State,
		arg.Status,
		arg.WorkspaceID,
	)
	return err
}

const updateState = `-- name: UpdateState :exec
UPDATE state_versions
SET state = $1, status = 'finalized'
WHERE state_version_id = $2
`

type UpdateStateParams struct {
	State          []byte
	StateVersionID string
}

func (q *Queries) UpdateState(ctx context.Context, arg UpdateStateParams) error {
	_, err := q.db.Exec(ctx, updateState, arg.State, arg.StateVersionID)
	return err
}
