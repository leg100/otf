// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: state_version.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/leg100/otf/internal/resource"
)

const countStateVersionsByWorkspaceID = `-- name: CountStateVersionsByWorkspaceID :one
SELECT count(*)
FROM state_versions
WHERE workspace_id = $1
AND status = 'finalized'
`

func (q *Queries) CountStateVersionsByWorkspaceID(ctx context.Context, workspaceID resource.ID) (int64, error) {
	row := q.db.QueryRow(ctx, countStateVersionsByWorkspaceID, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteStateVersionByID = `-- name: DeleteStateVersionByID :one
DELETE
FROM state_versions
WHERE state_version_id = $1
RETURNING state_version_id
`

func (q *Queries) DeleteStateVersionByID(ctx context.Context, stateVersionID resource.ID) (resource.ID, error) {
	row := q.db.QueryRow(ctx, deleteStateVersionByID, stateVersionID)
	var state_version_id resource.ID
	err := row.Scan(&state_version_id)
	return state_version_id, err
}

const discardPendingStateVersionsByWorkspaceID = `-- name: DiscardPendingStateVersionsByWorkspaceID :exec
UPDATE state_versions
SET status = 'discarded'
WHERE workspace_id = $1
AND status = 'pending'
`

func (q *Queries) DiscardPendingStateVersionsByWorkspaceID(ctx context.Context, workspaceID resource.ID) error {
	_, err := q.db.Exec(ctx, discardPendingStateVersionsByWorkspaceID, workspaceID)
	return err
}

const findCurrentStateVersionByWorkspaceID = `-- name: FindCurrentStateVersionByWorkspaceID :one
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.*)::state_version_outputs[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
        GROUP BY svo.state_version_id
    ) AS state_version_outputs
FROM state_versions sv
JOIN workspaces w ON w.current_state_version_id = sv.state_version_id
WHERE w.workspace_id = $1
`

type FindCurrentStateVersionByWorkspaceIDRow struct {
	StateVersionID      resource.ID
	CreatedAt           pgtype.Timestamptz
	Serial              pgtype.Int4
	State               []byte
	WorkspaceID         resource.ID
	Status              pgtype.Text
	StateVersionOutputs []StateVersionOutput
}

func (q *Queries) FindCurrentStateVersionByWorkspaceID(ctx context.Context, workspaceID resource.ID) (FindCurrentStateVersionByWorkspaceIDRow, error) {
	row := q.db.QueryRow(ctx, findCurrentStateVersionByWorkspaceID, workspaceID)
	var i FindCurrentStateVersionByWorkspaceIDRow
	err := row.Scan(
		&i.StateVersionID,
		&i.CreatedAt,
		&i.Serial,
		&i.State,
		&i.WorkspaceID,
		&i.Status,
		&i.StateVersionOutputs,
	)
	return i, err
}

const findStateVersionByID = `-- name: FindStateVersionByID :one
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.*)::state_version_outputs[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
        GROUP BY svo.state_version_id
    ) AS state_version_outputs
FROM state_versions sv
WHERE sv.state_version_id = $1
`

type FindStateVersionByIDRow struct {
	StateVersionID      resource.ID
	CreatedAt           pgtype.Timestamptz
	Serial              pgtype.Int4
	State               []byte
	WorkspaceID         resource.ID
	Status              pgtype.Text
	StateVersionOutputs []StateVersionOutput
}

func (q *Queries) FindStateVersionByID(ctx context.Context, id resource.ID) (FindStateVersionByIDRow, error) {
	row := q.db.QueryRow(ctx, findStateVersionByID, id)
	var i FindStateVersionByIDRow
	err := row.Scan(
		&i.StateVersionID,
		&i.CreatedAt,
		&i.Serial,
		&i.State,
		&i.WorkspaceID,
		&i.Status,
		&i.StateVersionOutputs,
	)
	return i, err
}

const findStateVersionByIDForUpdate = `-- name: FindStateVersionByIDForUpdate :one
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.*)::state_version_outputs[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
        GROUP BY svo.state_version_id
    ) AS state_version_outputs
FROM state_versions sv
WHERE sv.state_version_id = $1
FOR UPDATE OF sv
`

type FindStateVersionByIDForUpdateRow struct {
	StateVersionID      resource.ID
	CreatedAt           pgtype.Timestamptz
	Serial              pgtype.Int4
	State               []byte
	WorkspaceID         resource.ID
	Status              pgtype.Text
	StateVersionOutputs []StateVersionOutput
}

func (q *Queries) FindStateVersionByIDForUpdate(ctx context.Context, id resource.ID) (FindStateVersionByIDForUpdateRow, error) {
	row := q.db.QueryRow(ctx, findStateVersionByIDForUpdate, id)
	var i FindStateVersionByIDForUpdateRow
	err := row.Scan(
		&i.StateVersionID,
		&i.CreatedAt,
		&i.Serial,
		&i.State,
		&i.WorkspaceID,
		&i.Status,
		&i.StateVersionOutputs,
	)
	return i, err
}

const findStateVersionStateByID = `-- name: FindStateVersionStateByID :one
SELECT state
FROM state_versions
WHERE state_version_id = $1
`

func (q *Queries) FindStateVersionStateByID(ctx context.Context, id resource.ID) ([]byte, error) {
	row := q.db.QueryRow(ctx, findStateVersionStateByID, id)
	var state []byte
	err := row.Scan(&state)
	return state, err
}

const findStateVersionsByWorkspaceID = `-- name: FindStateVersionsByWorkspaceID :many
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.*)::state_version_outputs[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
        GROUP BY svo.state_version_id
    ) AS state_version_outputs
FROM state_versions sv
WHERE sv.workspace_id = $1
AND   sv.status = 'finalized'
ORDER BY created_at DESC
LIMIT $3::int
OFFSET $2::int
`

type FindStateVersionsByWorkspaceIDParams struct {
	WorkspaceID resource.ID
	Offset      pgtype.Int4
	Limit       pgtype.Int4
}

type FindStateVersionsByWorkspaceIDRow struct {
	StateVersionID      resource.ID
	CreatedAt           pgtype.Timestamptz
	Serial              pgtype.Int4
	State               []byte
	WorkspaceID         resource.ID
	Status              pgtype.Text
	StateVersionOutputs []StateVersionOutput
}

func (q *Queries) FindStateVersionsByWorkspaceID(ctx context.Context, arg FindStateVersionsByWorkspaceIDParams) ([]FindStateVersionsByWorkspaceIDRow, error) {
	rows, err := q.db.Query(ctx, findStateVersionsByWorkspaceID, arg.WorkspaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindStateVersionsByWorkspaceIDRow
	for rows.Next() {
		var i FindStateVersionsByWorkspaceIDRow
		if err := rows.Scan(
			&i.StateVersionID,
			&i.CreatedAt,
			&i.Serial,
			&i.State,
			&i.WorkspaceID,
			&i.Status,
			&i.StateVersionOutputs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertStateVersion = `-- name: InsertStateVersion :exec
INSERT INTO state_versions (
    state_version_id,
    created_at,
    serial,
    state,
    status,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
`

type InsertStateVersionParams struct {
	ID          resource.ID
	CreatedAt   pgtype.Timestamptz
	Serial      pgtype.Int4
	State       []byte
	Status      pgtype.Text
	WorkspaceID resource.ID
}

func (q *Queries) InsertStateVersion(ctx context.Context, arg InsertStateVersionParams) error {
	_, err := q.db.Exec(ctx, insertStateVersion,
		arg.ID,
		arg.CreatedAt,
		arg.Serial,
		arg.State,
		arg.Status,
		arg.WorkspaceID,
	)
	return err
}

const updateState = `-- name: UpdateState :exec
UPDATE state_versions
SET state = $1, status = 'finalized'
WHERE state_version_id = $2
`

type UpdateStateParams struct {
	State          []byte
	StateVersionID resource.ID
}

func (q *Queries) UpdateState(ctx context.Context, arg UpdateStateParams) error {
	_, err := q.db.Exec(ctx, updateState, arg.State, arg.StateVersionID)
	return err
}
