// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: phase.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/leg100/otf/internal/resource"
)

const findLogChunkByID = `-- name: FindLogChunkByID :one
SELECT
    chunk_id,
    run_id,
    phase,
    chunk,
    _offset AS offset
FROM logs
WHERE chunk_id = $1
`

type FindLogChunkByIDRow struct {
	ChunkID resource.ID
	RunID   resource.ID
	Phase   pgtype.Text
	Chunk   []byte
	Offset  pgtype.Int4
}

func (q *Queries) FindLogChunkByID(ctx context.Context, chunkID resource.ID) (FindLogChunkByIDRow, error) {
	row := q.db.QueryRow(ctx, findLogChunkByID, chunkID)
	var i FindLogChunkByIDRow
	err := row.Scan(
		&i.ChunkID,
		&i.RunID,
		&i.Phase,
		&i.Chunk,
		&i.Offset,
	)
	return i, err
}

const findLogs = `-- name: FindLogs :one
SELECT
    string_agg(chunk, '')
FROM (
    SELECT run_id, phase, chunk
    FROM logs
    WHERE run_id = $1
    AND   phase  = $2
    ORDER BY _offset
) c
GROUP BY run_id, phase
`

type FindLogsParams struct {
	RunID resource.ID
	Phase pgtype.Text
}

// FindLogs retrieves all the logs for the given run and phase.
func (q *Queries) FindLogs(ctx context.Context, arg FindLogsParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, findLogs, arg.RunID, arg.Phase)
	var string_agg []byte
	err := row.Scan(&string_agg)
	return string_agg, err
}

const insertLogChunk = `-- name: InsertLogChunk :exec
INSERT INTO logs (
    chunk_id,
    run_id,
    phase,
    chunk,
    _offset
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type InsertLogChunkParams struct {
	ChunkID resource.ID
	RunID   resource.ID
	Phase   pgtype.Text
	Chunk   []byte
	Offset  pgtype.Int4
}

func (q *Queries) InsertLogChunk(ctx context.Context, arg InsertLogChunkParams) error {
	_, err := q.db.Exec(ctx, insertLogChunk,
		arg.ChunkID,
		arg.RunID,
		arg.Phase,
		arg.Chunk,
		arg.Offset,
	)
	return err
}

const insertPhaseStatusTimestamp = `-- name: InsertPhaseStatusTimestamp :exec
INSERT INTO phase_status_timestamps (
    run_id,
    phase,
    status,
    timestamp
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertPhaseStatusTimestampParams struct {
	RunID     resource.ID
	Phase     pgtype.Text
	Status    pgtype.Text
	Timestamp pgtype.Timestamptz
}

func (q *Queries) InsertPhaseStatusTimestamp(ctx context.Context, arg InsertPhaseStatusTimestampParams) error {
	_, err := q.db.Exec(ctx, insertPhaseStatusTimestamp,
		arg.RunID,
		arg.Phase,
		arg.Status,
		arg.Timestamp,
	)
	return err
}
