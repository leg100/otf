// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: run.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"internal/run/run"
	"internal/sql/sqlc/sqlc"
)

const countRuns = `-- name: CountRuns :one
SELECT count(*)
FROM runs
JOIN workspaces USING(workspace_id)
JOIN (configuration_versions LEFT JOIN ingress_attributes ia USING (configuration_version_id)) USING (configuration_version_id)
WHERE
    workspaces.organization_name LIKE ANY($1)
AND workspaces.workspace_id      LIKE ANY($2)
AND workspaces.name              LIKE ANY($3)
AND runs.source                  LIKE ANY($4)
AND runs.status                  LIKE ANY($5)
AND runs.plan_only::text         LIKE ANY($6)
AND (($7::text IS NULL) OR ia.commit_sha = $7)
AND (($8::text IS NULL) OR ia.sender_username = $8)
`

type CountRunsParams struct {
	OrganizationNames string
	WorkspaceIds      string
	WorkspaceNames    string
	Sources           string
	Statuses          string
	PlanOnly          bool
	CommitSha         string
	VcsUsername       string
}

func (q *Queries) CountRuns(ctx context.Context, arg CountRunsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRuns,
		arg.OrganizationNames,
		arg.WorkspaceIds,
		arg.WorkspaceNames,
		arg.Sources,
		arg.Statuses,
		arg.PlanOnly,
		arg.CommitSha,
		arg.VcsUsername,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteRunByID = `-- name: DeleteRunByID :one
DELETE
FROM runs
WHERE run_id = $1
RETURNING run_id
`

func (q *Queries) DeleteRunByID(ctx context.Context, runID string) (string, error) {
	row := q.db.QueryRow(ctx, deleteRunByID, runID)
	var run_id string
	err := row.Scan(&run_id)
	return run_id, err
}

const findRunByID = `-- name: FindRunByID :one
SELECT
    runs.run_id,
    runs.created_at,
    runs.cancel_signaled_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.source,
    runs.status,
    plans.status      AS plan_status,
    applies.status      AS apply_status,
    runs.replace_addrs,
    runs.target_addrs,
    runs.auto_apply,
    plans.resource_report AS plan_resource_report,
    plans.output_report AS plan_output_report,
    applies.resource_report AS apply_resource_report,
    runs.configuration_version_id,
    runs.workspace_id,
    runs.plan_only,
    runs.created_by,
    runs.terraform_version,
    runs.allow_empty_apply,
    workspaces.execution_mode AS execution_mode,
    CASE WHEN workspaces.latest_run_id = runs.run_id THEN true
         ELSE false
    END AS latest,
    workspaces.organization_name,
    organizations.cost_estimation_enabled,
    (
        SELECT array_agg(rst.status)::text[]
        FROM run_status_timestamps rst
        WHERE st.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamp_statuses,
    (
        SELECT array_agg(st.timestamp)::timestamptz[]
        FROM run_status_timestamps st
        WHERE st.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamp_timestamps,
    (
        SELECT array_agg(st.status)::text[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'plan'
        GROUP BY run_id, phase
    ) AS plan_status_timestamp_statuses,
    (
        SELECT array_agg(st.timestamp)::timestamptz[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'plan'
        GROUP BY run_id, phase
    ) AS plan_status_timestamp_timestamps,
    (
        SELECT array_agg(st.status)::text[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'apply'
        GROUP BY run_id, phase
    ) AS apply_status_timestamp_statuses,
    (
        SELECT array_agg(st.timestamp)::timestamptz[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'apply'
        GROUP BY run_id, phase
    ) AS apply_status_timestamp_timestamps,
    (
        SELECT array_agg(rv.key)::text[]
        FROM run_variables rv
        WHERE rv.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_variable_keys,
    (
        SELECT array_agg(rv.value)::text[]
        FROM run_variables rv
        WHERE rv.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_variable_values,
    configuration_version_ingress_attributes.branch, configuration_version_ingress_attributes.commit_sha, configuration_version_ingress_attributes.identifier, configuration_version_ingress_attributes.is_pull_request, configuration_version_ingress_attributes.on_default_branch, configuration_version_ingress_attributes.configuration_version_id, configuration_version_ingress_attributes.commit_url, configuration_version_ingress_attributes.pull_request_number, configuration_version_ingress_attributes.pull_request_url, configuration_version_ingress_attributes.pull_request_title, configuration_version_ingress_attributes.tag, configuration_version_ingress_attributes.sender_username, configuration_version_ingress_attributes.sender_avatar_url, configuration_version_ingress_attributes.sender_html_url
FROM runs
JOIN plans USING (run_id)
JOIN applies USING (run_id)
JOIN configuration_version_ingress_attributes USING (configuration_version_id)
JOIN workspaces ON runs.workspace_id = workspaces.workspace_id
JOIN organizations ON workspaces.organization_name = organizations.name
WHERE runs.run_id = $1
`

type FindRunByIDRow struct {
	RunID                                string
	CreatedAt                            pgtype.Timestamptz
	CancelSignaledAt                     pgtype.Timestamptz
	IsDestroy                            bool
	PositionInQueue                      int32
	Refresh                              bool
	RefreshOnly                          bool
	Source                               string
	Status                               string
	PlanStatus                           string
	ApplyStatus                          string
	ReplaceAddrs                         []string
	TargetAddrs                          []string
	AutoApply                            bool
	PlanResourceReport                   run.Report
	PlanOutputReport                     run.Report
	ApplyResourceReport                  run.Report
	ConfigurationVersionID               string
	WorkspaceID                          string
	PlanOnly                             bool
	CreatedBy                            pgtype.Text
	TerraformVersion                     string
	AllowEmptyApply                      bool
	ExecutionMode                        string
	Latest                               bool
	OrganizationName                     string
	CostEstimationEnabled                bool
	RunStatusTimestampStatuses           []string
	RunStatusTimestampTimestamps         []pgtype.Timestamptz
	PlanStatusTimestampStatuses          []string
	PlanStatusTimestampTimestamps        []pgtype.Timestamptz
	ApplyStatusTimestampStatuses         []string
	ApplyStatusTimestampTimestamps       []pgtype.Timestamptz
	RunVariableKeys                      []string
	RunVariableValues                    []string
	ConfigurationVersionIngressAttribute ConfigurationVersionIngressAttribute
}

func (q *Queries) FindRunByID(ctx context.Context, runID string) (FindRunByIDRow, error) {
	row := q.db.QueryRow(ctx, findRunByID, runID)
	var i FindRunByIDRow
	err := row.Scan(
		&i.RunID,
		&i.CreatedAt,
		&i.CancelSignaledAt,
		&i.IsDestroy,
		&i.PositionInQueue,
		&i.Refresh,
		&i.RefreshOnly,
		&i.Source,
		&i.Status,
		&i.PlanStatus,
		&i.ApplyStatus,
		&i.ReplaceAddrs,
		&i.TargetAddrs,
		&i.AutoApply,
		&i.PlanResourceReport,
		&i.PlanOutputReport,
		&i.ApplyResourceReport,
		&i.ConfigurationVersionID,
		&i.WorkspaceID,
		&i.PlanOnly,
		&i.CreatedBy,
		&i.TerraformVersion,
		&i.AllowEmptyApply,
		&i.ExecutionMode,
		&i.Latest,
		&i.OrganizationName,
		&i.CostEstimationEnabled,
		&i.RunStatusTimestampStatuses,
		&i.RunStatusTimestampTimestamps,
		&i.PlanStatusTimestampStatuses,
		&i.PlanStatusTimestampTimestamps,
		&i.ApplyStatusTimestampStatuses,
		&i.ApplyStatusTimestampTimestamps,
		&i.RunVariableKeys,
		&i.RunVariableValues,
		&i.ConfigurationVersionIngressAttribute.Branch,
		&i.ConfigurationVersionIngressAttribute.CommitSha,
		&i.ConfigurationVersionIngressAttribute.Identifier,
		&i.ConfigurationVersionIngressAttribute.IsPullRequest,
		&i.ConfigurationVersionIngressAttribute.OnDefaultBranch,
		&i.ConfigurationVersionIngressAttribute.ConfigurationVersionID,
		&i.ConfigurationVersionIngressAttribute.CommitUrl,
		&i.ConfigurationVersionIngressAttribute.PullRequestNumber,
		&i.ConfigurationVersionIngressAttribute.PullRequestUrl,
		&i.ConfigurationVersionIngressAttribute.PullRequestTitle,
		&i.ConfigurationVersionIngressAttribute.Tag,
		&i.ConfigurationVersionIngressAttribute.SenderUsername,
		&i.ConfigurationVersionIngressAttribute.SenderAvatarUrl,
		&i.ConfigurationVersionIngressAttribute.SenderHtmlUrl,
	)
	return i, err
}

const findRunByIDForUpdate = `-- name: FindRunByIDForUpdate :one
SELECT
    runs.run_id,
    runs.created_at,
    runs.cancel_signaled_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.source,
    runs.status,
    plans.status        AS plan_status,
    applies.status      AS apply_status,
    runs.replace_addrs,
    runs.target_addrs,
    runs.auto_apply,
    plans.resource_report AS plan_resource_report,
    plans.output_report AS plan_output_report,
    applies.resource_report AS apply_resource_report,
    runs.configuration_version_id,
    runs.workspace_id,
    runs.plan_only,
    runs.created_by,
    runs.terraform_version,
    runs.allow_empty_apply,
    workspaces.execution_mode AS execution_mode,
    CASE WHEN workspaces.latest_run_id = runs.run_id THEN true
         ELSE false
    END AS latest,
    workspaces.organization_name,
    organizations.cost_estimation_enabled,
    (
        SELECT array_agg(rst.status)::text[]
        FROM run_status_timestamps rst
        WHERE st.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamp_statuses,
    (
        SELECT array_agg(st.timestamp)::timestamptz[]
        FROM run_status_timestamps st
        WHERE st.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamp_timestamps,
    (
        SELECT array_agg(st.status)::text[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'plan'
        GROUP BY run_id, phase
    ) AS plan_status_timestamp_statuses,
    (
        SELECT array_agg(st.timestamp)::timestamptz[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'plan'
        GROUP BY run_id, phase
    ) AS plan_status_timestamp_timestamps,
    (
        SELECT array_agg(st.status)::text[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'apply'
        GROUP BY run_id, phase
    ) AS apply_status_timestamp_statuses,
    (
        SELECT array_agg(st.timestamp)::timestamptz[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'apply'
        GROUP BY run_id, phase
    ) AS apply_status_timestamp_timestamps,
    (
        SELECT array_agg(rv.key)::text[]
        FROM run_variables rv
        WHERE rv.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_variable_keys,
    (
        SELECT array_agg(rv.value)::text[]
        FROM run_variables rv
        WHERE rv.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_variable_values,
    configuration_version_ingress_attributes.branch, configuration_version_ingress_attributes.commit_sha, configuration_version_ingress_attributes.identifier, configuration_version_ingress_attributes.is_pull_request, configuration_version_ingress_attributes.on_default_branch, configuration_version_ingress_attributes.configuration_version_id, configuration_version_ingress_attributes.commit_url, configuration_version_ingress_attributes.pull_request_number, configuration_version_ingress_attributes.pull_request_url, configuration_version_ingress_attributes.pull_request_title, configuration_version_ingress_attributes.tag, configuration_version_ingress_attributes.sender_username, configuration_version_ingress_attributes.sender_avatar_url, configuration_version_ingress_attributes.sender_html_url
FROM runs
JOIN plans USING (run_id)
JOIN applies USING (run_id)
JOIN configuration_version_ingress_attributes USING (configuration_version_id)
JOIN workspaces ON runs.workspace_id = workspaces.workspace_id
JOIN organizations ON workspaces.organization_name = organizations.name
WHERE runs.run_id = $1
FOR UPDATE OF runs, plans, applies
`

type FindRunByIDForUpdateRow struct {
	RunID                                string
	CreatedAt                            pgtype.Timestamptz
	CancelSignaledAt                     pgtype.Timestamptz
	IsDestroy                            bool
	PositionInQueue                      int32
	Refresh                              bool
	RefreshOnly                          bool
	Source                               string
	Status                               string
	PlanStatus                           string
	ApplyStatus                          string
	ReplaceAddrs                         []string
	TargetAddrs                          []string
	AutoApply                            bool
	PlanResourceReport                   run.Report
	PlanOutputReport                     run.Report
	ApplyResourceReport                  run.Report
	ConfigurationVersionID               string
	WorkspaceID                          string
	PlanOnly                             bool
	CreatedBy                            pgtype.Text
	TerraformVersion                     string
	AllowEmptyApply                      bool
	ExecutionMode                        string
	Latest                               bool
	OrganizationName                     string
	CostEstimationEnabled                bool
	RunStatusTimestampStatuses           []string
	RunStatusTimestampTimestamps         []pgtype.Timestamptz
	PlanStatusTimestampStatuses          []string
	PlanStatusTimestampTimestamps        []pgtype.Timestamptz
	ApplyStatusTimestampStatuses         []string
	ApplyStatusTimestampTimestamps       []pgtype.Timestamptz
	RunVariableKeys                      []string
	RunVariableValues                    []string
	ConfigurationVersionIngressAttribute ConfigurationVersionIngressAttribute
}

func (q *Queries) FindRunByIDForUpdate(ctx context.Context, runID string) (FindRunByIDForUpdateRow, error) {
	row := q.db.QueryRow(ctx, findRunByIDForUpdate, runID)
	var i FindRunByIDForUpdateRow
	err := row.Scan(
		&i.RunID,
		&i.CreatedAt,
		&i.CancelSignaledAt,
		&i.IsDestroy,
		&i.PositionInQueue,
		&i.Refresh,
		&i.RefreshOnly,
		&i.Source,
		&i.Status,
		&i.PlanStatus,
		&i.ApplyStatus,
		&i.ReplaceAddrs,
		&i.TargetAddrs,
		&i.AutoApply,
		&i.PlanResourceReport,
		&i.PlanOutputReport,
		&i.ApplyResourceReport,
		&i.ConfigurationVersionID,
		&i.WorkspaceID,
		&i.PlanOnly,
		&i.CreatedBy,
		&i.TerraformVersion,
		&i.AllowEmptyApply,
		&i.ExecutionMode,
		&i.Latest,
		&i.OrganizationName,
		&i.CostEstimationEnabled,
		&i.RunStatusTimestampStatuses,
		&i.RunStatusTimestampTimestamps,
		&i.PlanStatusTimestampStatuses,
		&i.PlanStatusTimestampTimestamps,
		&i.ApplyStatusTimestampStatuses,
		&i.ApplyStatusTimestampTimestamps,
		&i.RunVariableKeys,
		&i.RunVariableValues,
		&i.ConfigurationVersionIngressAttribute.Branch,
		&i.ConfigurationVersionIngressAttribute.CommitSha,
		&i.ConfigurationVersionIngressAttribute.Identifier,
		&i.ConfigurationVersionIngressAttribute.IsPullRequest,
		&i.ConfigurationVersionIngressAttribute.OnDefaultBranch,
		&i.ConfigurationVersionIngressAttribute.ConfigurationVersionID,
		&i.ConfigurationVersionIngressAttribute.CommitUrl,
		&i.ConfigurationVersionIngressAttribute.PullRequestNumber,
		&i.ConfigurationVersionIngressAttribute.PullRequestUrl,
		&i.ConfigurationVersionIngressAttribute.PullRequestTitle,
		&i.ConfigurationVersionIngressAttribute.Tag,
		&i.ConfigurationVersionIngressAttribute.SenderUsername,
		&i.ConfigurationVersionIngressAttribute.SenderAvatarUrl,
		&i.ConfigurationVersionIngressAttribute.SenderHtmlUrl,
	)
	return i, err
}

const findRuns = `-- name: FindRuns :many
SELECT
    runs.run_id,
    runs.created_at,
    runs.cancel_signaled_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.source,
    runs.status,
    plans.status      AS plan_status,
    applies.status      AS apply_status,
    runs.replace_addrs,
    runs.target_addrs,
    runs.auto_apply,
    plans.resource_report AS plan_resource_report,
    plans.output_report AS plan_output_report,
    applies.resource_report AS apply_resource_report,
    runs.configuration_version_id,
    runs.workspace_id,
    runs.plan_only,
    runs.created_by,
    runs.terraform_version,
    runs.allow_empty_apply,
    workspaces.execution_mode AS execution_mode,
    CASE WHEN workspaces.latest_run_id = runs.run_id THEN true
         ELSE false
    END AS latest,
    workspaces.organization_name,
    organizations.cost_estimation_enabled,
    (
        SELECT array_agg(st.status)::text[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'plan'
        GROUP BY run_id, phase
    ) AS plan_status_timestamp_statuses,
    (
        SELECT array_agg(st.timestamp)::timestamptz[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'plan'
        GROUP BY run_id, phase
    ) AS plan_status_timestamp_timestamps,
    (
        SELECT array_agg(st.status)::text[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'apply'
        GROUP BY run_id, phase
    ) AS apply_status_timestamp_statuses,
    (
        SELECT array_agg(st.timestamp)::timestamptz[]
        FROM phase_status_timestamps st
        WHERE st.run_id = applies.run_id
        AND   st.phase = 'apply'
        GROUP BY run_id, phase
    ) AS apply_status_timestamp_timestamps,
    array_agg(rst.*)::"run_status_timestamps" AS run_status_timestamps,
    array_agg(v.*)::"run_variables" AS run_variables,
    configuration_version_ingress_attributes.branch, configuration_version_ingress_attributes.commit_sha, configuration_version_ingress_attributes.identifier, configuration_version_ingress_attributes.is_pull_request, configuration_version_ingress_attributes.on_default_branch, configuration_version_ingress_attributes.configuration_version_id, configuration_version_ingress_attributes.commit_url, configuration_version_ingress_attributes.pull_request_number, configuration_version_ingress_attributes.pull_request_url, configuration_version_ingress_attributes.pull_request_title, configuration_version_ingress_attributes.tag, configuration_version_ingress_attributes.sender_username, configuration_version_ingress_attributes.sender_avatar_url, configuration_version_ingress_attributes.sender_html_url
FROM runs
JOIN plans USING (run_id)
JOIN applies USING (run_id)
JOIN configuration_version_ingress_attributes USING (configuration_version_id)
JOIN workspaces ON runs.workspace_id = workspaces.workspace_id
JOIN organizations ON workspaces.organization_name = organizations.name
LEFT JOIN run_variables v USING (run_id)
LEFT JOIN run_status_timestamps rst USING (run_id)
WHERE
    workspaces.organization_name LIKE ANY($1)
AND workspaces.workspace_id      LIKE ANY($2)
AND workspaces.name              LIKE ANY($3)
AND runs.source                  LIKE ANY($4)
AND runs.status                  LIKE ANY($5)
AND runs.plan_only::text         LIKE ANY($6)
AND (($7::text IS NULL) OR ia.commit_sha = $7)
AND (($8::text IS NULL) OR ia.sender_username = $8)
ORDER BY runs.created_at DESC
LIMIT $10 OFFSET $9
`

type FindRunsParams struct {
	OrganizationNames string
	WorkspaceIds      string
	WorkspaceNames    string
	Sources           string
	Statuses          string
	PlanOnly          bool
	CommitSha         string
	VcsUsername       string
	Offset            int32
	Limit             int32
}

type FindRunsRow struct {
	RunID                                string
	CreatedAt                            pgtype.Timestamptz
	CancelSignaledAt                     pgtype.Timestamptz
	IsDestroy                            bool
	PositionInQueue                      int32
	Refresh                              bool
	RefreshOnly                          bool
	Source                               string
	Status                               string
	PlanStatus                           string
	ApplyStatus                          string
	ReplaceAddrs                         []string
	TargetAddrs                          []string
	AutoApply                            bool
	PlanResourceReport                   run.Report
	PlanOutputReport                     run.Report
	ApplyResourceReport                  run.Report
	ConfigurationVersionID               string
	WorkspaceID                          string
	PlanOnly                             bool
	CreatedBy                            pgtype.Text
	TerraformVersion                     string
	AllowEmptyApply                      bool
	ExecutionMode                        string
	Latest                               bool
	OrganizationName                     string
	CostEstimationEnabled                bool
	PlanStatusTimestampStatuses          []string
	PlanStatusTimestampTimestamps        []pgtype.Timestamptz
	ApplyStatusTimestampStatuses         []string
	ApplyStatusTimestampTimestamps       []pgtype.Timestamptz
	RunStatusTimestamps                  sqlc.RunStatusTimestamp
	RunVariables                         run.Variable
	ConfigurationVersionIngressAttribute ConfigurationVersionIngressAttribute
}

func (q *Queries) FindRuns(ctx context.Context, arg FindRunsParams) ([]FindRunsRow, error) {
	rows, err := q.db.Query(ctx, findRuns,
		arg.OrganizationNames,
		arg.WorkspaceIds,
		arg.WorkspaceNames,
		arg.Sources,
		arg.Statuses,
		arg.PlanOnly,
		arg.CommitSha,
		arg.VcsUsername,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindRunsRow
	for rows.Next() {
		var i FindRunsRow
		if err := rows.Scan(
			&i.RunID,
			&i.CreatedAt,
			&i.CancelSignaledAt,
			&i.IsDestroy,
			&i.PositionInQueue,
			&i.Refresh,
			&i.RefreshOnly,
			&i.Source,
			&i.Status,
			&i.PlanStatus,
			&i.ApplyStatus,
			&i.ReplaceAddrs,
			&i.TargetAddrs,
			&i.AutoApply,
			&i.PlanResourceReport,
			&i.PlanOutputReport,
			&i.ApplyResourceReport,
			&i.ConfigurationVersionID,
			&i.WorkspaceID,
			&i.PlanOnly,
			&i.CreatedBy,
			&i.TerraformVersion,
			&i.AllowEmptyApply,
			&i.ExecutionMode,
			&i.Latest,
			&i.OrganizationName,
			&i.CostEstimationEnabled,
			&i.PlanStatusTimestampStatuses,
			&i.PlanStatusTimestampTimestamps,
			&i.ApplyStatusTimestampStatuses,
			&i.ApplyStatusTimestampTimestamps,
			&i.RunStatusTimestamps,
			&i.RunVariables,
			&i.ConfigurationVersionIngressAttribute.Branch,
			&i.ConfigurationVersionIngressAttribute.CommitSha,
			&i.ConfigurationVersionIngressAttribute.Identifier,
			&i.ConfigurationVersionIngressAttribute.IsPullRequest,
			&i.ConfigurationVersionIngressAttribute.OnDefaultBranch,
			&i.ConfigurationVersionIngressAttribute.ConfigurationVersionID,
			&i.ConfigurationVersionIngressAttribute.CommitUrl,
			&i.ConfigurationVersionIngressAttribute.PullRequestNumber,
			&i.ConfigurationVersionIngressAttribute.PullRequestUrl,
			&i.ConfigurationVersionIngressAttribute.PullRequestTitle,
			&i.ConfigurationVersionIngressAttribute.Tag,
			&i.ConfigurationVersionIngressAttribute.SenderUsername,
			&i.ConfigurationVersionIngressAttribute.SenderAvatarUrl,
			&i.ConfigurationVersionIngressAttribute.SenderHtmlUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLockFileByID = `-- name: GetLockFileByID :one
SELECT lock_file
FROM runs
WHERE run_id = $1
`

func (q *Queries) GetLockFileByID(ctx context.Context, runID string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getLockFileByID, runID)
	var lock_file []byte
	err := row.Scan(&lock_file)
	return lock_file, err
}

const insertRun = `-- name: InsertRun :exec
INSERT INTO runs (
    run_id,
    created_at,
    is_destroy,
    position_in_queue,
    refresh,
    refresh_only,
    source,
    status,
    replace_addrs,
    target_addrs,
    auto_apply,
    plan_only,
    configuration_version_id,
    workspace_id,
    created_by,
    terraform_version,
    allow_empty_apply
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17
)
`

type InsertRunParams struct {
	ID                     string
	CreatedAt              pgtype.Timestamptz
	IsDestroy              bool
	PositionInQueue        int32
	Refresh                bool
	RefreshOnly            bool
	Source                 string
	Status                 string
	ReplaceAddrs           []string
	TargetAddrs            []string
	AutoApply              bool
	PlanOnly               bool
	ConfigurationVersionID string
	WorkspaceID            string
	CreatedBy              pgtype.Text
	TerraformVersion       string
	AllowEmptyApply        bool
}

func (q *Queries) InsertRun(ctx context.Context, arg InsertRunParams) error {
	_, err := q.db.Exec(ctx, insertRun,
		arg.ID,
		arg.CreatedAt,
		arg.IsDestroy,
		arg.PositionInQueue,
		arg.Refresh,
		arg.RefreshOnly,
		arg.Source,
		arg.Status,
		arg.ReplaceAddrs,
		arg.TargetAddrs,
		arg.AutoApply,
		arg.PlanOnly,
		arg.ConfigurationVersionID,
		arg.WorkspaceID,
		arg.CreatedBy,
		arg.TerraformVersion,
		arg.AllowEmptyApply,
	)
	return err
}

const insertRunStatusTimestamp = `-- name: InsertRunStatusTimestamp :exec
INSERT INTO run_status_timestamps (
    run_id,
    status,
    timestamp
) VALUES (
    $1,
    $2,
    $3
)
`

type InsertRunStatusTimestampParams struct {
	ID        string
	Status    string
	Timestamp pgtype.Timestamptz
}

func (q *Queries) InsertRunStatusTimestamp(ctx context.Context, arg InsertRunStatusTimestampParams) error {
	_, err := q.db.Exec(ctx, insertRunStatusTimestamp, arg.ID, arg.Status, arg.Timestamp)
	return err
}

const insertRunVariable = `-- name: InsertRunVariable :exec
INSERT INTO run_variables (
    run_id,
    key,
    value
) VALUES (
    $1,
    $2,
    $3
)
`

type InsertRunVariableParams struct {
	RunID string
	Key   string
	Value string
}

func (q *Queries) InsertRunVariable(ctx context.Context, arg InsertRunVariableParams) error {
	_, err := q.db.Exec(ctx, insertRunVariable, arg.RunID, arg.Key, arg.Value)
	return err
}

const putLockFile = `-- name: PutLockFile :one
UPDATE runs
SET lock_file = $1
WHERE run_id = $2
RETURNING run_id
`

type PutLockFileParams struct {
	LockFile []byte
	RunID    string
}

func (q *Queries) PutLockFile(ctx context.Context, arg PutLockFileParams) (string, error) {
	row := q.db.QueryRow(ctx, putLockFile, arg.LockFile, arg.RunID)
	var run_id string
	err := row.Scan(&run_id)
	return run_id, err
}

const updateCancelSignaledAt = `-- name: UpdateCancelSignaledAt :one
UPDATE runs
SET
    cancel_signaled_at = $1
WHERE run_id = $2
RETURNING run_id
`

type UpdateCancelSignaledAtParams struct {
	CancelSignaledAt pgtype.Timestamptz
	ID               string
}

func (q *Queries) UpdateCancelSignaledAt(ctx context.Context, arg UpdateCancelSignaledAtParams) (string, error) {
	row := q.db.QueryRow(ctx, updateCancelSignaledAt, arg.CancelSignaledAt, arg.ID)
	var run_id string
	err := row.Scan(&run_id)
	return run_id, err
}

const updateRunStatus = `-- name: UpdateRunStatus :one
UPDATE runs
SET
    status = $1
WHERE run_id = $2
RETURNING run_id
`

type UpdateRunStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateRunStatus(ctx context.Context, arg UpdateRunStatusParams) (string, error) {
	row := q.db.QueryRow(ctx, updateRunStatus, arg.Status, arg.ID)
	var run_id string
	err := row.Scan(&run_id)
	return run_id, err
}
