// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: agent_pool.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/leg100/otf/internal/resource"
)

const deleteAgentPool = `-- name: DeleteAgentPool :one
DELETE
FROM agent_pools
WHERE agent_pool_id = $1
RETURNING agent_pool_id, name, created_at, organization_name, organization_scoped
`

func (q *Queries) DeleteAgentPool(ctx context.Context, poolID resource.ID) (AgentPool, error) {
	row := q.db.QueryRow(ctx, deleteAgentPool, poolID)
	var i AgentPool
	err := row.Scan(
		&i.AgentPoolID,
		&i.Name,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.OrganizationScoped,
	)
	return i, err
}

const deleteAgentPoolAllowedWorkspace = `-- name: DeleteAgentPoolAllowedWorkspace :exec
DELETE
FROM agent_pool_allowed_workspaces
WHERE agent_pool_id = $1
AND workspace_id = $2
`

type DeleteAgentPoolAllowedWorkspaceParams struct {
	PoolID      resource.ID
	WorkspaceID resource.ID
}

func (q *Queries) DeleteAgentPoolAllowedWorkspace(ctx context.Context, arg DeleteAgentPoolAllowedWorkspaceParams) error {
	_, err := q.db.Exec(ctx, deleteAgentPoolAllowedWorkspace, arg.PoolID, arg.WorkspaceID)
	return err
}

const findAgentPool = `-- name: FindAgentPool :one
SELECT ap.agent_pool_id, ap.name, ap.created_at, ap.organization_name, ap.organization_scoped,
    (
        SELECT array_agg(w.workspace_id)::text[]
        FROM workspaces w
        WHERE w.agent_pool_id = ap.agent_pool_id
    ) AS workspace_ids,
    (
        SELECT array_agg(aw.workspace_id)::text[]
        FROM agent_pool_allowed_workspaces aw
        WHERE aw.agent_pool_id = ap.agent_pool_id
    ) AS allowed_workspace_ids
FROM agent_pools ap
WHERE ap.agent_pool_id = $1
GROUP BY ap.agent_pool_id
`

type FindAgentPoolRow struct {
	AgentPoolID         resource.ID
	Name                pgtype.Text
	CreatedAt           pgtype.Timestamptz
	OrganizationName    pgtype.Text
	OrganizationScoped  pgtype.Bool
	WorkspaceIds        []pgtype.Text
	AllowedWorkspaceIds []pgtype.Text
}

func (q *Queries) FindAgentPool(ctx context.Context, poolID resource.ID) (FindAgentPoolRow, error) {
	row := q.db.QueryRow(ctx, findAgentPool, poolID)
	var i FindAgentPoolRow
	err := row.Scan(
		&i.AgentPoolID,
		&i.Name,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.OrganizationScoped,
		&i.WorkspaceIds,
		&i.AllowedWorkspaceIds,
	)
	return i, err
}

const findAgentPoolByAgentTokenID = `-- name: FindAgentPoolByAgentTokenID :one
SELECT ap.agent_pool_id, ap.name, ap.created_at, ap.organization_name, ap.organization_scoped,
    (
        SELECT array_agg(w.workspace_id)::text[]
        FROM workspaces w
        WHERE w.agent_pool_id = ap.agent_pool_id
    ) AS workspace_ids,
    (
        SELECT array_agg(aw.workspace_id)::text[]
        FROM agent_pool_allowed_workspaces aw
        WHERE aw.agent_pool_id = ap.agent_pool_id
    ) AS allowed_workspace_ids
FROM agent_pools ap
JOIN agent_tokens at USING (agent_pool_id)
WHERE at.agent_token_id = $1
GROUP BY ap.agent_pool_id
`

type FindAgentPoolByAgentTokenIDRow struct {
	AgentPoolID         resource.ID
	Name                pgtype.Text
	CreatedAt           pgtype.Timestamptz
	OrganizationName    pgtype.Text
	OrganizationScoped  pgtype.Bool
	WorkspaceIds        []pgtype.Text
	AllowedWorkspaceIds []pgtype.Text
}

func (q *Queries) FindAgentPoolByAgentTokenID(ctx context.Context, agentTokenID resource.ID) (FindAgentPoolByAgentTokenIDRow, error) {
	row := q.db.QueryRow(ctx, findAgentPoolByAgentTokenID, agentTokenID)
	var i FindAgentPoolByAgentTokenIDRow
	err := row.Scan(
		&i.AgentPoolID,
		&i.Name,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.OrganizationScoped,
		&i.WorkspaceIds,
		&i.AllowedWorkspaceIds,
	)
	return i, err
}

const findAgentPools = `-- name: FindAgentPools :many
SELECT ap.agent_pool_id, ap.name, ap.created_at, ap.organization_name, ap.organization_scoped,
    (
        SELECT array_agg(w.workspace_id)::text[]
        FROM workspaces w
        WHERE w.agent_pool_id = ap.agent_pool_id
    ) AS workspace_ids,
    (
        SELECT array_agg(aw.workspace_id)::text[]
        FROM agent_pool_allowed_workspaces aw
        WHERE aw.agent_pool_id = ap.agent_pool_id
    ) AS allowed_workspace_ids
FROM agent_pools ap
ORDER BY ap.created_at DESC
`

type FindAgentPoolsRow struct {
	AgentPoolID         resource.ID
	Name                pgtype.Text
	CreatedAt           pgtype.Timestamptz
	OrganizationName    pgtype.Text
	OrganizationScoped  pgtype.Bool
	WorkspaceIds        []pgtype.Text
	AllowedWorkspaceIds []pgtype.Text
}

func (q *Queries) FindAgentPools(ctx context.Context) ([]FindAgentPoolsRow, error) {
	rows, err := q.db.Query(ctx, findAgentPools)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAgentPoolsRow
	for rows.Next() {
		var i FindAgentPoolsRow
		if err := rows.Scan(
			&i.AgentPoolID,
			&i.Name,
			&i.CreatedAt,
			&i.OrganizationName,
			&i.OrganizationScoped,
			&i.WorkspaceIds,
			&i.AllowedWorkspaceIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAgentPoolsByOrganization = `-- name: FindAgentPoolsByOrganization :many
SELECT ap.agent_pool_id, ap.name, ap.created_at, ap.organization_name, ap.organization_scoped,
    (
        SELECT array_agg(w.workspace_id)::text[]
        FROM workspaces w
        WHERE w.agent_pool_id = ap.agent_pool_id
    ) AS workspace_ids,
    (
        SELECT array_agg(aw.workspace_id)::text[]
        FROM agent_pool_allowed_workspaces aw
        WHERE aw.agent_pool_id = ap.agent_pool_id
    ) AS allowed_workspace_ids
FROM agent_pools ap
LEFT JOIN (agent_pool_allowed_workspaces aw JOIN workspaces w USING (workspace_id)) ON ap.agent_pool_id = aw.agent_pool_id
WHERE ap.organization_name = $1
AND   (($2::text IS NULL) OR ap.name LIKE '%' || $2 || '%')
AND   (($3::text IS NULL) OR
       ap.organization_scoped OR
       w.name = $3
      )
AND   (($4::text IS NULL) OR
       ap.organization_scoped OR
       w.workspace_id = $4
      )
GROUP BY ap.agent_pool_id
ORDER BY ap.created_at DESC
`

type FindAgentPoolsByOrganizationParams struct {
	OrganizationName     pgtype.Text
	NameSubstring        pgtype.Text
	AllowedWorkspaceName pgtype.Text
	AllowedWorkspaceID   pgtype.Text
}

type FindAgentPoolsByOrganizationRow struct {
	AgentPoolID         resource.ID
	Name                pgtype.Text
	CreatedAt           pgtype.Timestamptz
	OrganizationName    pgtype.Text
	OrganizationScoped  pgtype.Bool
	WorkspaceIds        []pgtype.Text
	AllowedWorkspaceIds []pgtype.Text
}

// Find agent pools in an organization, optionally filtering by any combination of:
// (a) name_substring: pool name contains substring
// (b) allowed_workspace_name: workspace with name is allowed to use pool
// (c) allowed_workspace_id: workspace with ID is allowed to use pool
func (q *Queries) FindAgentPoolsByOrganization(ctx context.Context, arg FindAgentPoolsByOrganizationParams) ([]FindAgentPoolsByOrganizationRow, error) {
	rows, err := q.db.Query(ctx, findAgentPoolsByOrganization,
		arg.OrganizationName,
		arg.NameSubstring,
		arg.AllowedWorkspaceName,
		arg.AllowedWorkspaceID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAgentPoolsByOrganizationRow
	for rows.Next() {
		var i FindAgentPoolsByOrganizationRow
		if err := rows.Scan(
			&i.AgentPoolID,
			&i.Name,
			&i.CreatedAt,
			&i.OrganizationName,
			&i.OrganizationScoped,
			&i.WorkspaceIds,
			&i.AllowedWorkspaceIds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAgentPool = `-- name: InsertAgentPool :exec
INSERT INTO agent_pools (
    agent_pool_id,
    name,
    created_at,
    organization_name,
    organization_scoped
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
`

type InsertAgentPoolParams struct {
	AgentPoolID        resource.ID
	Name               pgtype.Text
	CreatedAt          pgtype.Timestamptz
	OrganizationName   pgtype.Text
	OrganizationScoped pgtype.Bool
}

func (q *Queries) InsertAgentPool(ctx context.Context, arg InsertAgentPoolParams) error {
	_, err := q.db.Exec(ctx, insertAgentPool,
		arg.AgentPoolID,
		arg.Name,
		arg.CreatedAt,
		arg.OrganizationName,
		arg.OrganizationScoped,
	)
	return err
}

const insertAgentPoolAllowedWorkspace = `-- name: InsertAgentPoolAllowedWorkspace :exec
INSERT INTO agent_pool_allowed_workspaces (
    agent_pool_id,
    workspace_id
) VALUES (
    $1,
    $2
)
`

type InsertAgentPoolAllowedWorkspaceParams struct {
	PoolID      resource.ID
	WorkspaceID resource.ID
}

func (q *Queries) InsertAgentPoolAllowedWorkspace(ctx context.Context, arg InsertAgentPoolAllowedWorkspaceParams) error {
	_, err := q.db.Exec(ctx, insertAgentPoolAllowedWorkspace, arg.PoolID, arg.WorkspaceID)
	return err
}

const updateAgentPool = `-- name: UpdateAgentPool :one
UPDATE agent_pools
SET name = $1,
    organization_scoped = $2
WHERE agent_pool_id = $3
RETURNING agent_pool_id, name, created_at, organization_name, organization_scoped
`

type UpdateAgentPoolParams struct {
	Name               pgtype.Text
	OrganizationScoped pgtype.Bool
	PoolID             resource.ID
}

func (q *Queries) UpdateAgentPool(ctx context.Context, arg UpdateAgentPoolParams) (AgentPool, error) {
	row := q.db.QueryRow(ctx, updateAgentPool, arg.Name, arg.OrganizationScoped, arg.PoolID)
	var i AgentPool
	err := row.Scan(
		&i.AgentPoolID,
		&i.Name,
		&i.CreatedAt,
		&i.OrganizationName,
		&i.OrganizationScoped,
	)
	return i, err
}
