// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: job.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/leg100/otf/internal/organization"
	"github.com/leg100/otf/internal/resource"
)

const findAllocatedJobs = `-- name: FindAllocatedJobs :many
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.runner_id = $1
AND   j.status = 'allocated'
`

type FindAllocatedJobsRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName organization.Name
}

func (q *Queries) FindAllocatedJobs(ctx context.Context, runnerID *resource.ID) ([]FindAllocatedJobsRow, error) {
	rows, err := q.db.Query(ctx, findAllocatedJobs, runnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllocatedJobsRow
	for rows.Next() {
		var i FindAllocatedJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.RunID,
			&i.Phase,
			&i.Status,
			&i.Signaled,
			&i.RunnerID,
			&i.AgentPoolID,
			&i.WorkspaceID,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAndUpdateSignaledJobs = `-- name: FindAndUpdateSignaledJobs :many
UPDATE jobs AS j
SET signaled = NULL
FROM runs r, workspaces w
WHERE j.run_id = r.run_id
AND   r.workspace_id = w.workspace_id
AND   j.runner_id = $1
AND   j.status = 'running'
AND   j.signaled IS NOT NULL
RETURNING
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
`

type FindAndUpdateSignaledJobsRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName organization.Name
}

// Find signaled jobs and then immediately update signal with null.
func (q *Queries) FindAndUpdateSignaledJobs(ctx context.Context, runnerID *resource.ID) ([]FindAndUpdateSignaledJobsRow, error) {
	rows, err := q.db.Query(ctx, findAndUpdateSignaledJobs, runnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAndUpdateSignaledJobsRow
	for rows.Next() {
		var i FindAndUpdateSignaledJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.RunID,
			&i.Phase,
			&i.Status,
			&i.Signaled,
			&i.RunnerID,
			&i.AgentPoolID,
			&i.WorkspaceID,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findJob = `-- name: FindJob :one
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.job_id = $1
`

type FindJobRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName organization.Name
}

func (q *Queries) FindJob(ctx context.Context, jobID resource.ID) (FindJobRow, error) {
	row := q.db.QueryRow(ctx, findJob, jobID)
	var i FindJobRow
	err := row.Scan(
		&i.JobID,
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.Signaled,
		&i.RunnerID,
		&i.AgentPoolID,
		&i.WorkspaceID,
		&i.OrganizationName,
	)
	return i, err
}

const findJobForUpdate = `-- name: FindJobForUpdate :one
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.job_id = $1
FOR UPDATE OF j
`

type FindJobForUpdateRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName organization.Name
}

func (q *Queries) FindJobForUpdate(ctx context.Context, jobID resource.ID) (FindJobForUpdateRow, error) {
	row := q.db.QueryRow(ctx, findJobForUpdate, jobID)
	var i FindJobForUpdateRow
	err := row.Scan(
		&i.JobID,
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.Signaled,
		&i.RunnerID,
		&i.AgentPoolID,
		&i.WorkspaceID,
		&i.OrganizationName,
	)
	return i, err
}

const findJobs = `-- name: FindJobs :many
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
`

type FindJobsRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName organization.Name
}

func (q *Queries) FindJobs(ctx context.Context) ([]FindJobsRow, error) {
	rows, err := q.db.Query(ctx, findJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindJobsRow
	for rows.Next() {
		var i FindJobsRow
		if err := rows.Scan(
			&i.JobID,
			&i.RunID,
			&i.Phase,
			&i.Status,
			&i.Signaled,
			&i.RunnerID,
			&i.AgentPoolID,
			&i.WorkspaceID,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUnfinishedJobForUpdateByRunID = `-- name: FindUnfinishedJobForUpdateByRunID :one
SELECT
    j.job_id,
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.runner_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.run_id = $1
AND   j.status IN ('unallocated', 'allocated', 'running')
FOR UPDATE OF j
`

type FindUnfinishedJobForUpdateByRunIDRow struct {
	JobID            resource.ID
	RunID            resource.ID
	Phase            pgtype.Text
	Status           pgtype.Text
	Signaled         pgtype.Bool
	RunnerID         *resource.ID
	AgentPoolID      *resource.ID
	WorkspaceID      resource.ID
	OrganizationName organization.Name
}

// FindUnfinishedJobForUpdateByRunID finds an unfinished job belonging to a run.
// (There should only be one such job for a run).
func (q *Queries) FindUnfinishedJobForUpdateByRunID(ctx context.Context, runID resource.ID) (FindUnfinishedJobForUpdateByRunIDRow, error) {
	row := q.db.QueryRow(ctx, findUnfinishedJobForUpdateByRunID, runID)
	var i FindUnfinishedJobForUpdateByRunIDRow
	err := row.Scan(
		&i.JobID,
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.Signaled,
		&i.RunnerID,
		&i.AgentPoolID,
		&i.WorkspaceID,
		&i.OrganizationName,
	)
	return i, err
}

const insertJob = `-- name: InsertJob :exec
INSERT INTO jobs (
    job_id,
    run_id,
    phase,
    status
) VALUES (
    $1,
    $2,
    $3,
    $4
)
`

type InsertJobParams struct {
	JobID  resource.ID
	RunID  resource.ID
	Phase  pgtype.Text
	Status pgtype.Text
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) error {
	_, err := q.db.Exec(ctx, insertJob,
		arg.JobID,
		arg.RunID,
		arg.Phase,
		arg.Status,
	)
	return err
}

const updateJob = `-- name: UpdateJob :one
UPDATE jobs
SET status   = $1,
    signaled = $2,
    runner_id = $3
WHERE job_id = $4
RETURNING run_id, phase, status, runner_id, signaled, job_id
`

type UpdateJobParams struct {
	Status   pgtype.Text
	Signaled pgtype.Bool
	RunnerID *resource.ID
	JobID    resource.ID
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.Status,
		arg.Signaled,
		arg.RunnerID,
		arg.JobID,
	)
	var i Job
	err := row.Scan(
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.RunnerID,
		&i.Signaled,
		&i.JobID,
	)
	return i, err
}
