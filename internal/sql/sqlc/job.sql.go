// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: job.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const findAllocatedJobs = `-- name: FindAllocatedJobs :many
SELECT
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.agent_id = $1
AND   j.status = 'allocated'
`

type FindAllocatedJobsRow struct {
	RunID            string
	Phase            string
	Status           string
	Signaled         pgtype.Bool
	AgentID          pgtype.Text
	AgentPoolID      pgtype.Text
	WorkspaceID      string
	OrganizationName string
}

func (q *Queries) FindAllocatedJobs(ctx context.Context, agentID pgtype.Text) ([]FindAllocatedJobsRow, error) {
	rows, err := q.db.Query(ctx, findAllocatedJobs, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAllocatedJobsRow
	for rows.Next() {
		var i FindAllocatedJobsRow
		if err := rows.Scan(
			&i.RunID,
			&i.Phase,
			&i.Status,
			&i.Signaled,
			&i.AgentID,
			&i.AgentPoolID,
			&i.WorkspaceID,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAndUpdateSignaledJobs = `-- name: FindAndUpdateSignaledJobs :many
UPDATE jobs AS j
SET signaled = NULL
FROM runs r, workspaces w
WHERE j.run_id = r.run_id
AND   r.workspace_id = w.workspace_id
AND   j.agent_id = $1
AND   j.status = 'running'
AND   j.signaled IS NOT NULL
RETURNING
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
`

type FindAndUpdateSignaledJobsRow struct {
	RunID            string
	Phase            string
	Status           string
	Signaled         pgtype.Bool
	AgentID          pgtype.Text
	AgentPoolID      pgtype.Text
	WorkspaceID      string
	OrganizationName string
}

// Find signaled jobs and then immediately update signal with null.
func (q *Queries) FindAndUpdateSignaledJobs(ctx context.Context, agentID pgtype.Text) ([]FindAndUpdateSignaledJobsRow, error) {
	rows, err := q.db.Query(ctx, findAndUpdateSignaledJobs, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindAndUpdateSignaledJobsRow
	for rows.Next() {
		var i FindAndUpdateSignaledJobsRow
		if err := rows.Scan(
			&i.RunID,
			&i.Phase,
			&i.Status,
			&i.Signaled,
			&i.AgentID,
			&i.AgentPoolID,
			&i.WorkspaceID,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findJob = `-- name: FindJob :one
SELECT
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.run_id = $1
AND   phase = $2
`

type FindJobParams struct {
	RunID string
	Phase string
}

type FindJobRow struct {
	RunID            string
	Phase            string
	Status           string
	Signaled         pgtype.Bool
	AgentID          pgtype.Text
	AgentPoolID      pgtype.Text
	WorkspaceID      string
	OrganizationName string
}

func (q *Queries) FindJob(ctx context.Context, arg FindJobParams) (FindJobRow, error) {
	row := q.db.QueryRow(ctx, findJob, arg.RunID, arg.Phase)
	var i FindJobRow
	err := row.Scan(
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.Signaled,
		&i.AgentID,
		&i.AgentPoolID,
		&i.WorkspaceID,
		&i.OrganizationName,
	)
	return i, err
}

const findJobForUpdate = `-- name: FindJobForUpdate :one
SELECT
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
WHERE j.run_id = $1
AND   phase = $2
FOR UPDATE OF j
`

type FindJobForUpdateParams struct {
	RunID string
	Phase string
}

type FindJobForUpdateRow struct {
	RunID            string
	Phase            string
	Status           string
	Signaled         pgtype.Bool
	AgentID          pgtype.Text
	AgentPoolID      pgtype.Text
	WorkspaceID      string
	OrganizationName string
}

func (q *Queries) FindJobForUpdate(ctx context.Context, arg FindJobForUpdateParams) (FindJobForUpdateRow, error) {
	row := q.db.QueryRow(ctx, findJobForUpdate, arg.RunID, arg.Phase)
	var i FindJobForUpdateRow
	err := row.Scan(
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.Signaled,
		&i.AgentID,
		&i.AgentPoolID,
		&i.WorkspaceID,
		&i.OrganizationName,
	)
	return i, err
}

const findJobs = `-- name: FindJobs :many
SELECT
    j.run_id,
    j.phase,
    j.status,
    j.signaled,
    j.agent_id,
    w.agent_pool_id,
    r.workspace_id,
    w.organization_name
FROM jobs j
JOIN runs r USING (run_id)
JOIN workspaces w USING (workspace_id)
`

type FindJobsRow struct {
	RunID            string
	Phase            string
	Status           string
	Signaled         pgtype.Bool
	AgentID          pgtype.Text
	AgentPoolID      pgtype.Text
	WorkspaceID      string
	OrganizationName string
}

func (q *Queries) FindJobs(ctx context.Context) ([]FindJobsRow, error) {
	rows, err := q.db.Query(ctx, findJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindJobsRow
	for rows.Next() {
		var i FindJobsRow
		if err := rows.Scan(
			&i.RunID,
			&i.Phase,
			&i.Status,
			&i.Signaled,
			&i.AgentID,
			&i.AgentPoolID,
			&i.WorkspaceID,
			&i.OrganizationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertJob = `-- name: InsertJob :exec
INSERT INTO jobs (
    run_id,
    phase,
    status
) VALUES (
    $1,
    $2,
    $3
)
`

type InsertJobParams struct {
	RunID  string
	Phase  string
	Status string
}

func (q *Queries) InsertJob(ctx context.Context, arg InsertJobParams) error {
	_, err := q.db.Exec(ctx, insertJob, arg.RunID, arg.Phase, arg.Status)
	return err
}

const updateJob = `-- name: UpdateJob :one
UPDATE jobs
SET status   = $1,
    signaled = $2,
    agent_id = $3
WHERE run_id = $4
AND   phase = $5
RETURNING run_id, phase, status, agent_id, signaled
`

type UpdateJobParams struct {
	Status   string
	Signaled pgtype.Bool
	AgentID  pgtype.Text
	RunID    string
	Phase    string
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJob,
		arg.Status,
		arg.Signaled,
		arg.AgentID,
		arg.RunID,
		arg.Phase,
	)
	var i Job
	err := row.Scan(
		&i.RunID,
		&i.Phase,
		&i.Status,
		&i.AgentID,
		&i.Signaled,
	)
	return i, err
}
