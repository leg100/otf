// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package state

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/leg100/otf/internal/resource"
)

const countStateVersionsByWorkspaceID = `-- name: CountStateVersionsByWorkspaceID :one
SELECT count(*)
FROM state_versions
WHERE workspace_id = $1
AND status = 'finalized'
`

func (q *Queries) CountStateVersionsByWorkspaceID(ctx context.Context, db DBTX, workspaceID resource.TfeID) (int64, error) {
	row := db.QueryRow(ctx, countStateVersionsByWorkspaceID, workspaceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteStateVersionByID = `-- name: DeleteStateVersionByID :one
DELETE
FROM state_versions
WHERE state_version_id = $1
RETURNING state_version_id
`

func (q *Queries) DeleteStateVersionByID(ctx context.Context, db DBTX, stateVersionID resource.TfeID) (resource.TfeID, error) {
	row := db.QueryRow(ctx, deleteStateVersionByID, stateVersionID)
	var state_version_id resource.TfeID
	err := row.Scan(&state_version_id)
	return state_version_id, err
}

const discardPendingStateVersionsByWorkspaceID = `-- name: DiscardPendingStateVersionsByWorkspaceID :exec
UPDATE state_versions
SET status = 'discarded'
WHERE workspace_id = $1
AND status = 'pending'
`

func (q *Queries) DiscardPendingStateVersionsByWorkspaceID(ctx context.Context, db DBTX, workspaceID resource.TfeID) error {
	_, err := db.Exec(ctx, discardPendingStateVersionsByWorkspaceID, workspaceID)
	return err
}

const findCurrentStateVersionByWorkspaceID = `-- name: FindCurrentStateVersionByWorkspaceID :one
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.*)::state_version_outputs[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
        GROUP BY svo.state_version_id
    ) AS state_version_outputs
FROM state_versions sv
JOIN workspaces w ON w.current_state_version_id = sv.state_version_id
WHERE w.workspace_id = $1
`

type FindCurrentStateVersionByWorkspaceIDRow struct {
	StateVersionID      resource.TfeID
	CreatedAt           pgtype.Timestamptz
	Serial              pgtype.Int4
	State               []byte
	WorkspaceID         resource.TfeID
	Status              pgtype.Text
	StateVersionOutputs []StateVersionOutput
}

func (q *Queries) FindCurrentStateVersionByWorkspaceID(ctx context.Context, db DBTX, workspaceID resource.TfeID) (FindCurrentStateVersionByWorkspaceIDRow, error) {
	row := db.QueryRow(ctx, findCurrentStateVersionByWorkspaceID, workspaceID)
	var i FindCurrentStateVersionByWorkspaceIDRow
	err := row.Scan(
		&i.StateVersionID,
		&i.CreatedAt,
		&i.Serial,
		&i.State,
		&i.WorkspaceID,
		&i.Status,
		&i.StateVersionOutputs,
	)
	return i, err
}

const findStateVersionByID = `-- name: FindStateVersionByID :one
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.*)::state_version_outputs[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
        GROUP BY svo.state_version_id
    ) AS state_version_outputs
FROM state_versions sv
WHERE sv.state_version_id = $1
`

type FindStateVersionByIDRow struct {
	StateVersionID      resource.TfeID
	CreatedAt           pgtype.Timestamptz
	Serial              pgtype.Int4
	State               []byte
	WorkspaceID         resource.TfeID
	Status              pgtype.Text
	StateVersionOutputs []StateVersionOutput
}

func (q *Queries) FindStateVersionByID(ctx context.Context, db DBTX, id resource.TfeID) (FindStateVersionByIDRow, error) {
	row := db.QueryRow(ctx, findStateVersionByID, id)
	var i FindStateVersionByIDRow
	err := row.Scan(
		&i.StateVersionID,
		&i.CreatedAt,
		&i.Serial,
		&i.State,
		&i.WorkspaceID,
		&i.Status,
		&i.StateVersionOutputs,
	)
	return i, err
}

const findStateVersionByIDForUpdate = `-- name: FindStateVersionByIDForUpdate :one
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.*)::state_version_outputs[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
        GROUP BY svo.state_version_id
    ) AS state_version_outputs
FROM state_versions sv
WHERE sv.state_version_id = $1
FOR UPDATE OF sv
`

type FindStateVersionByIDForUpdateRow struct {
	StateVersionID      resource.TfeID
	CreatedAt           pgtype.Timestamptz
	Serial              pgtype.Int4
	State               []byte
	WorkspaceID         resource.TfeID
	Status              pgtype.Text
	StateVersionOutputs []StateVersionOutput
}

func (q *Queries) FindStateVersionByIDForUpdate(ctx context.Context, db DBTX, id resource.TfeID) (FindStateVersionByIDForUpdateRow, error) {
	row := db.QueryRow(ctx, findStateVersionByIDForUpdate, id)
	var i FindStateVersionByIDForUpdateRow
	err := row.Scan(
		&i.StateVersionID,
		&i.CreatedAt,
		&i.Serial,
		&i.State,
		&i.WorkspaceID,
		&i.Status,
		&i.StateVersionOutputs,
	)
	return i, err
}

const findStateVersionOutputByID = `-- name: FindStateVersionOutputByID :one
SELECT state_version_output_id, name, sensitive, type, value, state_version_id
FROM state_version_outputs
WHERE state_version_output_id = $1
`

func (q *Queries) FindStateVersionOutputByID(ctx context.Context, db DBTX, id resource.TfeID) (StateVersionOutput, error) {
	row := db.QueryRow(ctx, findStateVersionOutputByID, id)
	var i StateVersionOutput
	err := row.Scan(
		&i.StateVersionOutputID,
		&i.Name,
		&i.Sensitive,
		&i.Type,
		&i.Value,
		&i.StateVersionID,
	)
	return i, err
}

const findStateVersionStateByID = `-- name: FindStateVersionStateByID :one
SELECT state
FROM state_versions
WHERE state_version_id = $1
`

func (q *Queries) FindStateVersionStateByID(ctx context.Context, db DBTX, id resource.TfeID) ([]byte, error) {
	row := db.QueryRow(ctx, findStateVersionStateByID, id)
	var state []byte
	err := row.Scan(&state)
	return state, err
}

const findStateVersionsByWorkspaceID = `-- name: FindStateVersionsByWorkspaceID :many
SELECT
    sv.state_version_id, sv.created_at, sv.serial, sv.state, sv.workspace_id, sv.status,
    (
        SELECT array_agg(svo.*)::state_version_outputs[]
        FROM state_version_outputs svo
        WHERE svo.state_version_id = sv.state_version_id
        GROUP BY svo.state_version_id
    ) AS state_version_outputs
FROM state_versions sv
WHERE sv.workspace_id = $1
AND   sv.status = 'finalized'
ORDER BY created_at DESC
LIMIT $3::int
OFFSET $2::int
`

type FindStateVersionsByWorkspaceIDParams struct {
	WorkspaceID resource.TfeID
	Offset      pgtype.Int4
	Limit       pgtype.Int4
}

type FindStateVersionsByWorkspaceIDRow struct {
	StateVersionID      resource.TfeID
	CreatedAt           pgtype.Timestamptz
	Serial              pgtype.Int4
	State               []byte
	WorkspaceID         resource.TfeID
	Status              pgtype.Text
	StateVersionOutputs []StateVersionOutput
}

func (q *Queries) FindStateVersionsByWorkspaceID(ctx context.Context, db DBTX, arg FindStateVersionsByWorkspaceIDParams) ([]FindStateVersionsByWorkspaceIDRow, error) {
	rows, err := db.Query(ctx, findStateVersionsByWorkspaceID, arg.WorkspaceID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindStateVersionsByWorkspaceIDRow
	for rows.Next() {
		var i FindStateVersionsByWorkspaceIDRow
		if err := rows.Scan(
			&i.StateVersionID,
			&i.CreatedAt,
			&i.Serial,
			&i.State,
			&i.WorkspaceID,
			&i.Status,
			&i.StateVersionOutputs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertStateVersion = `-- name: InsertStateVersion :exec
INSERT INTO state_versions (
    state_version_id,
    created_at,
    serial,
    state,
    status,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
`

type InsertStateVersionParams struct {
	ID          resource.TfeID
	CreatedAt   pgtype.Timestamptz
	Serial      pgtype.Int4
	State       []byte
	Status      pgtype.Text
	WorkspaceID resource.TfeID
}

func (q *Queries) InsertStateVersion(ctx context.Context, db DBTX, arg InsertStateVersionParams) error {
	_, err := db.Exec(ctx, insertStateVersion,
		arg.ID,
		arg.CreatedAt,
		arg.Serial,
		arg.State,
		arg.Status,
		arg.WorkspaceID,
	)
	return err
}

const insertStateVersionOutput = `-- name: InsertStateVersionOutput :exec
INSERT INTO state_version_outputs (
    state_version_output_id,
    name,
    sensitive,
    type,
    value,
    state_version_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
`

type InsertStateVersionOutputParams struct {
	ID             resource.TfeID
	Name           pgtype.Text
	Sensitive      pgtype.Bool
	Type           pgtype.Text
	Value          []byte
	StateVersionID resource.TfeID
}

func (q *Queries) InsertStateVersionOutput(ctx context.Context, db DBTX, arg InsertStateVersionOutputParams) error {
	_, err := db.Exec(ctx, insertStateVersionOutput,
		arg.ID,
		arg.Name,
		arg.Sensitive,
		arg.Type,
		arg.Value,
		arg.StateVersionID,
	)
	return err
}

const updateState = `-- name: UpdateState :exec
UPDATE state_versions
SET state = $1, status = 'finalized'
WHERE state_version_id = $2
`

type UpdateStateParams struct {
	State          []byte
	StateVersionID resource.TfeID
}

func (q *Queries) UpdateState(ctx context.Context, db DBTX, arg UpdateStateParams) error {
	_, err := db.Exec(ctx, updateState, arg.State, arg.StateVersionID)
	return err
}
