// Code generated by pggen. DO NOT EDIT.

package sql

import (
	"context"
	"fmt"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
	"time"
)

const insertConfigurationVersionSQL = `INSERT INTO configuration_versions (
    configuration_version_id,
    created_at,
    updated_at,
    auto_queue_runs,
    source,
    speculative,
    status
) VALUES (
    $1,
    NOW(),
    NOW(),
    $2,
    $3,
    $4,
    $5
)
RETURNING *;`

type InsertConfigurationVersionParams struct {
	ID            *string
	AutoQueueRuns *bool
	Source        *string
	Speculative   *bool
	Status        *string
}

type InsertConfigurationVersionRow struct {
	ConfigurationVersionID *string      `json:"configuration_version_id"`
	CreatedAt              time.Time    `json:"created_at"`
	UpdatedAt              time.Time    `json:"updated_at"`
	AutoQueueRuns          *bool        `json:"auto_queue_runs"`
	Source                 *string      `json:"source"`
	Speculative            *bool        `json:"speculative"`
	Status                 *string      `json:"status"`
	Config                 pgtype.Bytea `json:"config"`
	WorkspaceID            *string      `json:"workspace_id"`
}

func (s InsertConfigurationVersionRow) GetConfigurationVersionID() *string { return s.ConfigurationVersionID }
func (s InsertConfigurationVersionRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s InsertConfigurationVersionRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s InsertConfigurationVersionRow) GetAutoQueueRuns() *bool { return s.AutoQueueRuns }
func (s InsertConfigurationVersionRow) GetSource() *string { return s.Source }
func (s InsertConfigurationVersionRow) GetSpeculative() *bool { return s.Speculative }
func (s InsertConfigurationVersionRow) GetStatus() *string { return s.Status }
func (s InsertConfigurationVersionRow) GetConfig() pgtype.Bytea { return s.Config }
func (s InsertConfigurationVersionRow) GetWorkspaceID() *string { return s.WorkspaceID }


// InsertConfigurationVersion implements Querier.InsertConfigurationVersion.
func (q *DBQuerier) InsertConfigurationVersion(ctx context.Context, params InsertConfigurationVersionParams) (InsertConfigurationVersionRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertConfigurationVersion")
	row := q.conn.QueryRow(ctx, insertConfigurationVersionSQL, params.ID, params.AutoQueueRuns, params.Source, params.Speculative, params.Status)
	var item InsertConfigurationVersionRow
	if err := row.Scan(&item.ConfigurationVersionID, &item.CreatedAt, &item.UpdatedAt, &item.AutoQueueRuns, &item.Source, &item.Speculative, &item.Status, &item.Config, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("query InsertConfigurationVersion: %w", err)
	}
	return item, nil
}

// InsertConfigurationVersionBatch implements Querier.InsertConfigurationVersionBatch.
func (q *DBQuerier) InsertConfigurationVersionBatch(batch genericBatch, params InsertConfigurationVersionParams) {
	batch.Queue(insertConfigurationVersionSQL, params.ID, params.AutoQueueRuns, params.Source, params.Speculative, params.Status)
}

// InsertConfigurationVersionScan implements Querier.InsertConfigurationVersionScan.
func (q *DBQuerier) InsertConfigurationVersionScan(results pgx.BatchResults) (InsertConfigurationVersionRow, error) {
	row := results.QueryRow()
	var item InsertConfigurationVersionRow
	if err := row.Scan(&item.ConfigurationVersionID, &item.CreatedAt, &item.UpdatedAt, &item.AutoQueueRuns, &item.Source, &item.Speculative, &item.Status, &item.Config, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("scan InsertConfigurationVersionBatch row: %w", err)
	}
	return item, nil
}

const insertConfigurationVersionStatusTimestampSQL = `INSERT INTO configuration_version_status_timestamps (
    configuration_version_id,
    status,
    timestamp
) VALUES (
    $1,
    $2,
    NOW()
)
RETURNING *;`

type InsertConfigurationVersionStatusTimestampRow struct {
	ConfigurationVersionID *string   `json:"configuration_version_id"`
	Status                 *string   `json:"status"`
	Timestamp              time.Time `json:"timestamp"`
}

func (s InsertConfigurationVersionStatusTimestampRow) GetConfigurationVersionID() *string { return s.ConfigurationVersionID }
func (s InsertConfigurationVersionStatusTimestampRow) GetStatus() *string { return s.Status }
func (s InsertConfigurationVersionStatusTimestampRow) GetTimestamp() time.Time { return s.Timestamp }


// InsertConfigurationVersionStatusTimestamp implements Querier.InsertConfigurationVersionStatusTimestamp.
func (q *DBQuerier) InsertConfigurationVersionStatusTimestamp(ctx context.Context, id *string, status *string) (InsertConfigurationVersionStatusTimestampRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertConfigurationVersionStatusTimestamp")
	row := q.conn.QueryRow(ctx, insertConfigurationVersionStatusTimestampSQL, id, status)
	var item InsertConfigurationVersionStatusTimestampRow
	if err := row.Scan(&item.ConfigurationVersionID, &item.Status, &item.Timestamp); err != nil {
		return item, fmt.Errorf("query InsertConfigurationVersionStatusTimestamp: %w", err)
	}
	return item, nil
}

// InsertConfigurationVersionStatusTimestampBatch implements Querier.InsertConfigurationVersionStatusTimestampBatch.
func (q *DBQuerier) InsertConfigurationVersionStatusTimestampBatch(batch genericBatch, id *string, status *string) {
	batch.Queue(insertConfigurationVersionStatusTimestampSQL, id, status)
}

// InsertConfigurationVersionStatusTimestampScan implements Querier.InsertConfigurationVersionStatusTimestampScan.
func (q *DBQuerier) InsertConfigurationVersionStatusTimestampScan(results pgx.BatchResults) (InsertConfigurationVersionStatusTimestampRow, error) {
	row := results.QueryRow()
	var item InsertConfigurationVersionStatusTimestampRow
	if err := row.Scan(&item.ConfigurationVersionID, &item.Status, &item.Timestamp); err != nil {
		return item, fmt.Errorf("scan InsertConfigurationVersionStatusTimestampBatch row: %w", err)
	}
	return item, nil
}

const findConfigurationVersionsSQL = `SELECT configuration_versions.*, (workspaces.*)::"workspaces" AS workspace, count(*) OVER() AS full_count
FROM configuration_versions
JOIN workspaces USING (workspace_id)
WHERE workspaces.workspace_id = $1
LIMIT $2
OFFSET $3;`

type FindConfigurationVersionsParams struct {
	WorkspaceID *string
	Limit       int
	Offset      int
}

type FindConfigurationVersionsRow struct {
	ConfigurationVersionID *string      `json:"configuration_version_id"`
	CreatedAt              time.Time    `json:"created_at"`
	UpdatedAt              time.Time    `json:"updated_at"`
	AutoQueueRuns          *bool        `json:"auto_queue_runs"`
	Source                 *string      `json:"source"`
	Speculative            *bool        `json:"speculative"`
	Status                 *string      `json:"status"`
	Config                 pgtype.Bytea `json:"config"`
	WorkspaceID            *string      `json:"workspace_id"`
	Workspace              Workspaces   `json:"workspace"`
	FullCount              *int         `json:"full_count"`
}

func (s FindConfigurationVersionsRow) GetConfigurationVersionID() *string { return s.ConfigurationVersionID }
func (s FindConfigurationVersionsRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindConfigurationVersionsRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindConfigurationVersionsRow) GetAutoQueueRuns() *bool { return s.AutoQueueRuns }
func (s FindConfigurationVersionsRow) GetSource() *string { return s.Source }
func (s FindConfigurationVersionsRow) GetSpeculative() *bool { return s.Speculative }
func (s FindConfigurationVersionsRow) GetStatus() *string { return s.Status }
func (s FindConfigurationVersionsRow) GetConfig() pgtype.Bytea { return s.Config }
func (s FindConfigurationVersionsRow) GetWorkspaceID() *string { return s.WorkspaceID }
func (s FindConfigurationVersionsRow) GetWorkspace() Workspaces { return s.Workspace }
func (s FindConfigurationVersionsRow) GetFullCount() *int { return s.FullCount }


// FindConfigurationVersions implements Querier.FindConfigurationVersions.
func (q *DBQuerier) FindConfigurationVersions(ctx context.Context, params FindConfigurationVersionsParams) ([]FindConfigurationVersionsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindConfigurationVersions")
	rows, err := q.conn.Query(ctx, findConfigurationVersionsSQL, params.WorkspaceID, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindConfigurationVersions: %w", err)
	}
	defer rows.Close()
	items := []FindConfigurationVersionsRow{}
	workspaceRow := q.types.newWorkspaces()
	for rows.Next() {
		var item FindConfigurationVersionsRow
		if err := rows.Scan(&item.ConfigurationVersionID, &item.CreatedAt, &item.UpdatedAt, &item.AutoQueueRuns, &item.Source, &item.Speculative, &item.Status, &item.Config, &item.WorkspaceID, workspaceRow, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindConfigurationVersions row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindConfigurationVersions row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindConfigurationVersions rows: %w", err)
	}
	return items, err
}

// FindConfigurationVersionsBatch implements Querier.FindConfigurationVersionsBatch.
func (q *DBQuerier) FindConfigurationVersionsBatch(batch genericBatch, params FindConfigurationVersionsParams) {
	batch.Queue(findConfigurationVersionsSQL, params.WorkspaceID, params.Limit, params.Offset)
}

// FindConfigurationVersionsScan implements Querier.FindConfigurationVersionsScan.
func (q *DBQuerier) FindConfigurationVersionsScan(results pgx.BatchResults) ([]FindConfigurationVersionsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindConfigurationVersionsBatch: %w", err)
	}
	defer rows.Close()
	items := []FindConfigurationVersionsRow{}
	workspaceRow := q.types.newWorkspaces()
	for rows.Next() {
		var item FindConfigurationVersionsRow
		if err := rows.Scan(&item.ConfigurationVersionID, &item.CreatedAt, &item.UpdatedAt, &item.AutoQueueRuns, &item.Source, &item.Speculative, &item.Status, &item.Config, &item.WorkspaceID, workspaceRow, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindConfigurationVersionsBatch row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindConfigurationVersions row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindConfigurationVersionsBatch rows: %w", err)
	}
	return items, err
}

const findConfigurationVersionByIDSQL = `SELECT
    configuration_versions.configuration_version_id,
    configuration_versions.created_at,
    configuration_versions.updated_at,
    configuration_versions.auto_queue_runs,
    configuration_versions.source,
    configuration_versions.speculative,
    configuration_versions.status,
    (workspaces.*)::"workspaces" AS workspace
FROM configuration_versions
JOIN workspaces USING (workspace_id)
WHERE configuration_version_id = $1;`

type FindConfigurationVersionByIDRow struct {
	ConfigurationVersionID *string    `json:"configuration_version_id"`
	CreatedAt              time.Time  `json:"created_at"`
	UpdatedAt              time.Time  `json:"updated_at"`
	AutoQueueRuns          *bool      `json:"auto_queue_runs"`
	Source                 *string    `json:"source"`
	Speculative            *bool      `json:"speculative"`
	Status                 *string    `json:"status"`
	Workspace              Workspaces `json:"workspace"`
}

func (s FindConfigurationVersionByIDRow) GetConfigurationVersionID() *string { return s.ConfigurationVersionID }
func (s FindConfigurationVersionByIDRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindConfigurationVersionByIDRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindConfigurationVersionByIDRow) GetAutoQueueRuns() *bool { return s.AutoQueueRuns }
func (s FindConfigurationVersionByIDRow) GetSource() *string { return s.Source }
func (s FindConfigurationVersionByIDRow) GetSpeculative() *bool { return s.Speculative }
func (s FindConfigurationVersionByIDRow) GetStatus() *string { return s.Status }
func (s FindConfigurationVersionByIDRow) GetWorkspace() Workspaces { return s.Workspace }


// FindConfigurationVersionByID implements Querier.FindConfigurationVersionByID.
func (q *DBQuerier) FindConfigurationVersionByID(ctx context.Context, configurationVersionID *string) (FindConfigurationVersionByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindConfigurationVersionByID")
	row := q.conn.QueryRow(ctx, findConfigurationVersionByIDSQL, configurationVersionID)
	var item FindConfigurationVersionByIDRow
	workspaceRow := q.types.newWorkspaces()
	if err := row.Scan(&item.ConfigurationVersionID, &item.CreatedAt, &item.UpdatedAt, &item.AutoQueueRuns, &item.Source, &item.Speculative, &item.Status, workspaceRow); err != nil {
		return item, fmt.Errorf("query FindConfigurationVersionByID: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindConfigurationVersionByID row: %w", err)
	}
	return item, nil
}

// FindConfigurationVersionByIDBatch implements Querier.FindConfigurationVersionByIDBatch.
func (q *DBQuerier) FindConfigurationVersionByIDBatch(batch genericBatch, configurationVersionID *string) {
	batch.Queue(findConfigurationVersionByIDSQL, configurationVersionID)
}

// FindConfigurationVersionByIDScan implements Querier.FindConfigurationVersionByIDScan.
func (q *DBQuerier) FindConfigurationVersionByIDScan(results pgx.BatchResults) (FindConfigurationVersionByIDRow, error) {
	row := results.QueryRow()
	var item FindConfigurationVersionByIDRow
	workspaceRow := q.types.newWorkspaces()
	if err := row.Scan(&item.ConfigurationVersionID, &item.CreatedAt, &item.UpdatedAt, &item.AutoQueueRuns, &item.Source, &item.Speculative, &item.Status, workspaceRow); err != nil {
		return item, fmt.Errorf("scan FindConfigurationVersionByIDBatch row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindConfigurationVersionByID row: %w", err)
	}
	return item, nil
}

const downloadConfigurationVersionSQL = `SELECT config
FROM configuration_versions
WHERE configuration_version_id = $1;`

// DownloadConfigurationVersion implements Querier.DownloadConfigurationVersion.
func (q *DBQuerier) DownloadConfigurationVersion(ctx context.Context, configurationVersionID *string) (pgtype.Bytea, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DownloadConfigurationVersion")
	row := q.conn.QueryRow(ctx, downloadConfigurationVersionSQL, configurationVersionID)
	var item pgtype.Bytea
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DownloadConfigurationVersion: %w", err)
	}
	return item, nil
}

// DownloadConfigurationVersionBatch implements Querier.DownloadConfigurationVersionBatch.
func (q *DBQuerier) DownloadConfigurationVersionBatch(batch genericBatch, configurationVersionID *string) {
	batch.Queue(downloadConfigurationVersionSQL, configurationVersionID)
}

// DownloadConfigurationVersionScan implements Querier.DownloadConfigurationVersionScan.
func (q *DBQuerier) DownloadConfigurationVersionScan(results pgx.BatchResults) (pgtype.Bytea, error) {
	row := results.QueryRow()
	var item pgtype.Bytea
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DownloadConfigurationVersionBatch row: %w", err)
	}
	return item, nil
}

const uploadConfigurationVersionSQL = `UPDATE configuration_versions
SET
    config = $1,
    status = 'uploaded',
    updated_at = NOW()
WHERE configuration_version_id = $2
RETURNING *;`

type UploadConfigurationVersionRow struct {
	ConfigurationVersionID *string      `json:"configuration_version_id"`
	CreatedAt              time.Time    `json:"created_at"`
	UpdatedAt              time.Time    `json:"updated_at"`
	AutoQueueRuns          *bool        `json:"auto_queue_runs"`
	Source                 *string      `json:"source"`
	Speculative            *bool        `json:"speculative"`
	Status                 *string      `json:"status"`
	Config                 pgtype.Bytea `json:"config"`
	WorkspaceID            *string      `json:"workspace_id"`
}

func (s UploadConfigurationVersionRow) GetConfigurationVersionID() *string { return s.ConfigurationVersionID }
func (s UploadConfigurationVersionRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s UploadConfigurationVersionRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s UploadConfigurationVersionRow) GetAutoQueueRuns() *bool { return s.AutoQueueRuns }
func (s UploadConfigurationVersionRow) GetSource() *string { return s.Source }
func (s UploadConfigurationVersionRow) GetSpeculative() *bool { return s.Speculative }
func (s UploadConfigurationVersionRow) GetStatus() *string { return s.Status }
func (s UploadConfigurationVersionRow) GetConfig() pgtype.Bytea { return s.Config }
func (s UploadConfigurationVersionRow) GetWorkspaceID() *string { return s.WorkspaceID }


// UploadConfigurationVersion implements Querier.UploadConfigurationVersion.
func (q *DBQuerier) UploadConfigurationVersion(ctx context.Context, config []byte, id *string) (UploadConfigurationVersionRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UploadConfigurationVersion")
	row := q.conn.QueryRow(ctx, uploadConfigurationVersionSQL, config, id)
	var item UploadConfigurationVersionRow
	if err := row.Scan(&item.ConfigurationVersionID, &item.CreatedAt, &item.UpdatedAt, &item.AutoQueueRuns, &item.Source, &item.Speculative, &item.Status, &item.Config, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("query UploadConfigurationVersion: %w", err)
	}
	return item, nil
}

// UploadConfigurationVersionBatch implements Querier.UploadConfigurationVersionBatch.
func (q *DBQuerier) UploadConfigurationVersionBatch(batch genericBatch, config []byte, id *string) {
	batch.Queue(uploadConfigurationVersionSQL, config, id)
}

// UploadConfigurationVersionScan implements Querier.UploadConfigurationVersionScan.
func (q *DBQuerier) UploadConfigurationVersionScan(results pgx.BatchResults) (UploadConfigurationVersionRow, error) {
	row := results.QueryRow()
	var item UploadConfigurationVersionRow
	if err := row.Scan(&item.ConfigurationVersionID, &item.CreatedAt, &item.UpdatedAt, &item.AutoQueueRuns, &item.Source, &item.Speculative, &item.Status, &item.Config, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("scan UploadConfigurationVersionBatch row: %w", err)
	}
	return item, nil
}
