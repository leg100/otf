// Code generated by pggen. DO NOT EDIT.

package sql

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
	"time"
)

// Querier is a typesafe Go interface backed by SQL queries.
//
// Methods ending with Batch enqueue a query to run later in a pgx.Batch. After
// calling SendBatch on pgx.Conn, pgxpool.Pool, or pgx.Tx, use the Scan methods
// to parse the results.
type Querier interface {
	InsertApply(ctx context.Context, params InsertApplyParams) (InsertApplyRow, error)
	// InsertApplyBatch enqueues a InsertApply query into batch to be executed
	// later by the batch.
	InsertApplyBatch(batch genericBatch, params InsertApplyParams)
	// InsertApplyScan scans the result of an executed InsertApplyBatch query.
	InsertApplyScan(results pgx.BatchResults) (InsertApplyRow, error)

	InsertApplyStatusTimestamp(ctx context.Context, id *string, status *string) (InsertApplyStatusTimestampRow, error)
	// InsertApplyStatusTimestampBatch enqueues a InsertApplyStatusTimestamp query into batch to be executed
	// later by the batch.
	InsertApplyStatusTimestampBatch(batch genericBatch, id *string, status *string)
	// InsertApplyStatusTimestampScan scans the result of an executed InsertApplyStatusTimestampBatch query.
	InsertApplyStatusTimestampScan(results pgx.BatchResults) (InsertApplyStatusTimestampRow, error)

	UpdateApplyStatus(ctx context.Context, status *string, id *string) (UpdateApplyStatusRow, error)
	// UpdateApplyStatusBatch enqueues a UpdateApplyStatus query into batch to be executed
	// later by the batch.
	UpdateApplyStatusBatch(batch genericBatch, status *string, id *string)
	// UpdateApplyStatusScan scans the result of an executed UpdateApplyStatusBatch query.
	UpdateApplyStatusScan(results pgx.BatchResults) (UpdateApplyStatusRow, error)

	UpdateApplyResources(ctx context.Context, params UpdateApplyResourcesParams) (pgconn.CommandTag, error)
	// UpdateApplyResourcesBatch enqueues a UpdateApplyResources query into batch to be executed
	// later by the batch.
	UpdateApplyResourcesBatch(batch genericBatch, params UpdateApplyResourcesParams)
	// UpdateApplyResourcesScan scans the result of an executed UpdateApplyResourcesBatch query.
	UpdateApplyResourcesScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	InsertApplyLogChunk(ctx context.Context, applyID *string, chunk []byte) (InsertApplyLogChunkRow, error)
	// InsertApplyLogChunkBatch enqueues a InsertApplyLogChunk query into batch to be executed
	// later by the batch.
	InsertApplyLogChunkBatch(batch genericBatch, applyID *string, chunk []byte)
	// InsertApplyLogChunkScan scans the result of an executed InsertApplyLogChunkBatch query.
	InsertApplyLogChunkScan(results pgx.BatchResults) (InsertApplyLogChunkRow, error)

	FindApplyLogChunks(ctx context.Context, params FindApplyLogChunksParams) ([]byte, error)
	// FindApplyLogChunksBatch enqueues a FindApplyLogChunks query into batch to be executed
	// later by the batch.
	FindApplyLogChunksBatch(batch genericBatch, params FindApplyLogChunksParams)
	// FindApplyLogChunksScan scans the result of an executed FindApplyLogChunksBatch query.
	FindApplyLogChunksScan(results pgx.BatchResults) ([]byte, error)

	// InsertConfigurationVersion inserts a configuration version and
	// returns the entire row.
	// 
	InsertConfigurationVersion(ctx context.Context, params InsertConfigurationVersionParams) (InsertConfigurationVersionRow, error)
	// InsertConfigurationVersionBatch enqueues a InsertConfigurationVersion query into batch to be executed
	// later by the batch.
	InsertConfigurationVersionBatch(batch genericBatch, params InsertConfigurationVersionParams)
	// InsertConfigurationVersionScan scans the result of an executed InsertConfigurationVersionBatch query.
	InsertConfigurationVersionScan(results pgx.BatchResults) (InsertConfigurationVersionRow, error)

	InsertConfigurationVersionStatusTimestamp(ctx context.Context, id *string, status *string) (InsertConfigurationVersionStatusTimestampRow, error)
	// InsertConfigurationVersionStatusTimestampBatch enqueues a InsertConfigurationVersionStatusTimestamp query into batch to be executed
	// later by the batch.
	InsertConfigurationVersionStatusTimestampBatch(batch genericBatch, id *string, status *string)
	// InsertConfigurationVersionStatusTimestampScan scans the result of an executed InsertConfigurationVersionStatusTimestampBatch query.
	InsertConfigurationVersionStatusTimestampScan(results pgx.BatchResults) (InsertConfigurationVersionStatusTimestampRow, error)

	// FindConfigurationVersions finds configuration_versions for a given workspace.
	// Results are paginated with limit and offset, and total count is returned.
	// 
	FindConfigurationVersionsByWorkspaceID(ctx context.Context, params FindConfigurationVersionsByWorkspaceIDParams) ([]FindConfigurationVersionsByWorkspaceIDRow, error)
	// FindConfigurationVersionsByWorkspaceIDBatch enqueues a FindConfigurationVersionsByWorkspaceID query into batch to be executed
	// later by the batch.
	FindConfigurationVersionsByWorkspaceIDBatch(batch genericBatch, params FindConfigurationVersionsByWorkspaceIDParams)
	// FindConfigurationVersionsByWorkspaceIDScan scans the result of an executed FindConfigurationVersionsByWorkspaceIDBatch query.
	FindConfigurationVersionsByWorkspaceIDScan(results pgx.BatchResults) ([]FindConfigurationVersionsByWorkspaceIDRow, error)

	// FindConfigurationVersionByID finds a configuration_version by its id.
	// 
	FindConfigurationVersionByID(ctx context.Context, configurationVersionID *string) (FindConfigurationVersionByIDRow, error)
	// FindConfigurationVersionByIDBatch enqueues a FindConfigurationVersionByID query into batch to be executed
	// later by the batch.
	FindConfigurationVersionByIDBatch(batch genericBatch, configurationVersionID *string)
	// FindConfigurationVersionByIDScan scans the result of an executed FindConfigurationVersionByIDBatch query.
	FindConfigurationVersionByIDScan(results pgx.BatchResults) (FindConfigurationVersionByIDRow, error)

	FindConfigurationVersionLatestByWorkspaceID(ctx context.Context, workspaceID *string) (FindConfigurationVersionLatestByWorkspaceIDRow, error)
	// FindConfigurationVersionLatestByWorkspaceIDBatch enqueues a FindConfigurationVersionLatestByWorkspaceID query into batch to be executed
	// later by the batch.
	FindConfigurationVersionLatestByWorkspaceIDBatch(batch genericBatch, workspaceID *string)
	// FindConfigurationVersionLatestByWorkspaceIDScan scans the result of an executed FindConfigurationVersionLatestByWorkspaceIDBatch query.
	FindConfigurationVersionLatestByWorkspaceIDScan(results pgx.BatchResults) (FindConfigurationVersionLatestByWorkspaceIDRow, error)

	FindConfigurationVersionByIDForUpdate(ctx context.Context, configurationVersionID *string) (FindConfigurationVersionByIDForUpdateRow, error)
	// FindConfigurationVersionByIDForUpdateBatch enqueues a FindConfigurationVersionByIDForUpdate query into batch to be executed
	// later by the batch.
	FindConfigurationVersionByIDForUpdateBatch(batch genericBatch, configurationVersionID *string)
	// FindConfigurationVersionByIDForUpdateScan scans the result of an executed FindConfigurationVersionByIDForUpdateBatch query.
	FindConfigurationVersionByIDForUpdateScan(results pgx.BatchResults) (FindConfigurationVersionByIDForUpdateRow, error)

	// DownloadConfigurationVersion gets a configuration_version config
	// tarball.
	// 
	DownloadConfigurationVersion(ctx context.Context, configurationVersionID *string) ([]byte, error)
	// DownloadConfigurationVersionBatch enqueues a DownloadConfigurationVersion query into batch to be executed
	// later by the batch.
	DownloadConfigurationVersionBatch(batch genericBatch, configurationVersionID *string)
	// DownloadConfigurationVersionScan scans the result of an executed DownloadConfigurationVersionBatch query.
	DownloadConfigurationVersionScan(results pgx.BatchResults) ([]byte, error)

	UpdateConfigurationVersionStatus(ctx context.Context, status *string, id *string) (pgconn.CommandTag, error)
	// UpdateConfigurationVersionStatusBatch enqueues a UpdateConfigurationVersionStatus query into batch to be executed
	// later by the batch.
	UpdateConfigurationVersionStatusBatch(batch genericBatch, status *string, id *string)
	// UpdateConfigurationVersionStatusScan scans the result of an executed UpdateConfigurationVersionStatusBatch query.
	UpdateConfigurationVersionStatusScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	UpdateConfigurationVersionConfig(ctx context.Context, config []byte, id *string) (pgconn.CommandTag, error)
	// UpdateConfigurationVersionConfigBatch enqueues a UpdateConfigurationVersionConfig query into batch to be executed
	// later by the batch.
	UpdateConfigurationVersionConfigBatch(batch genericBatch, config []byte, id *string)
	// UpdateConfigurationVersionConfigScan scans the result of an executed UpdateConfigurationVersionConfigBatch query.
	UpdateConfigurationVersionConfigScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	DeleteConfigurationVersionByID(ctx context.Context, id *string) (pgconn.CommandTag, error)
	// DeleteConfigurationVersionByIDBatch enqueues a DeleteConfigurationVersionByID query into batch to be executed
	// later by the batch.
	DeleteConfigurationVersionByIDBatch(batch genericBatch, id *string)
	// DeleteConfigurationVersionByIDScan scans the result of an executed DeleteConfigurationVersionByIDBatch query.
	DeleteConfigurationVersionByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	// FindOrganizationByName finds an organization by name.
	// 
	FindOrganizationByName(ctx context.Context, name *string) (FindOrganizationByNameRow, error)
	// FindOrganizationByNameBatch enqueues a FindOrganizationByName query into batch to be executed
	// later by the batch.
	FindOrganizationByNameBatch(batch genericBatch, name *string)
	// FindOrganizationByNameScan scans the result of an executed FindOrganizationByNameBatch query.
	FindOrganizationByNameScan(results pgx.BatchResults) (FindOrganizationByNameRow, error)

	FindOrganizations(ctx context.Context, limit int, offset int) (FindOrganizationsRow, error)
	// FindOrganizationsBatch enqueues a FindOrganizations query into batch to be executed
	// later by the batch.
	FindOrganizationsBatch(batch genericBatch, limit int, offset int)
	// FindOrganizationsScan scans the result of an executed FindOrganizationsBatch query.
	FindOrganizationsScan(results pgx.BatchResults) (FindOrganizationsRow, error)

	// InsertOrganization inserts an organization and returns the entire row.
	// 
	InsertOrganization(ctx context.Context, params InsertOrganizationParams) (InsertOrganizationRow, error)
	// InsertOrganizationBatch enqueues a InsertOrganization query into batch to be executed
	// later by the batch.
	InsertOrganizationBatch(batch genericBatch, params InsertOrganizationParams)
	// InsertOrganizationScan scans the result of an executed InsertOrganizationBatch query.
	InsertOrganizationScan(results pgx.BatchResults) (InsertOrganizationRow, error)

	// UpdateOrganizationNameByName updates an organization with a new name,
	// identifying the organization with its existing name, and returns the
	// updated row.
	// 
	UpdateOrganizationNameByName(ctx context.Context, newName *string, name *string) (UpdateOrganizationNameByNameRow, error)
	// UpdateOrganizationNameByNameBatch enqueues a UpdateOrganizationNameByName query into batch to be executed
	// later by the batch.
	UpdateOrganizationNameByNameBatch(batch genericBatch, newName *string, name *string)
	// UpdateOrganizationNameByNameScan scans the result of an executed UpdateOrganizationNameByNameBatch query.
	UpdateOrganizationNameByNameScan(results pgx.BatchResults) (UpdateOrganizationNameByNameRow, error)

	UpdateOrganizationSessionRememberByName(ctx context.Context, sessionRemember int32, name *string) (UpdateOrganizationSessionRememberByNameRow, error)
	// UpdateOrganizationSessionRememberByNameBatch enqueues a UpdateOrganizationSessionRememberByName query into batch to be executed
	// later by the batch.
	UpdateOrganizationSessionRememberByNameBatch(batch genericBatch, sessionRemember int32, name *string)
	// UpdateOrganizationSessionRememberByNameScan scans the result of an executed UpdateOrganizationSessionRememberByNameBatch query.
	UpdateOrganizationSessionRememberByNameScan(results pgx.BatchResults) (UpdateOrganizationSessionRememberByNameRow, error)

	UpdateOrganizationSessionTimeoutByName(ctx context.Context, sessionTimeout int32, name *string) (UpdateOrganizationSessionTimeoutByNameRow, error)
	// UpdateOrganizationSessionTimeoutByNameBatch enqueues a UpdateOrganizationSessionTimeoutByName query into batch to be executed
	// later by the batch.
	UpdateOrganizationSessionTimeoutByNameBatch(batch genericBatch, sessionTimeout int32, name *string)
	// UpdateOrganizationSessionTimeoutByNameScan scans the result of an executed UpdateOrganizationSessionTimeoutByNameBatch query.
	UpdateOrganizationSessionTimeoutByNameScan(results pgx.BatchResults) (UpdateOrganizationSessionTimeoutByNameRow, error)

	// DeleteOrganization deletes an organization by id.
	// 
	DeleteOrganization(ctx context.Context, name *string) (pgconn.CommandTag, error)
	// DeleteOrganizationBatch enqueues a DeleteOrganization query into batch to be executed
	// later by the batch.
	DeleteOrganizationBatch(batch genericBatch, name *string)
	// DeleteOrganizationScan scans the result of an executed DeleteOrganizationBatch query.
	DeleteOrganizationScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	InsertOrganizationMembership(ctx context.Context, userID *string, organizationID *string) (InsertOrganizationMembershipRow, error)
	// InsertOrganizationMembershipBatch enqueues a InsertOrganizationMembership query into batch to be executed
	// later by the batch.
	InsertOrganizationMembershipBatch(batch genericBatch, userID *string, organizationID *string)
	// InsertOrganizationMembershipScan scans the result of an executed InsertOrganizationMembershipBatch query.
	InsertOrganizationMembershipScan(results pgx.BatchResults) (InsertOrganizationMembershipRow, error)

	DeleteOrganizationMembership(ctx context.Context, userID *string, organizationID *string) (pgconn.CommandTag, error)
	// DeleteOrganizationMembershipBatch enqueues a DeleteOrganizationMembership query into batch to be executed
	// later by the batch.
	DeleteOrganizationMembershipBatch(batch genericBatch, userID *string, organizationID *string)
	// DeleteOrganizationMembershipScan scans the result of an executed DeleteOrganizationMembershipBatch query.
	DeleteOrganizationMembershipScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	InsertPlan(ctx context.Context, params InsertPlanParams) (InsertPlanRow, error)
	// InsertPlanBatch enqueues a InsertPlan query into batch to be executed
	// later by the batch.
	InsertPlanBatch(batch genericBatch, params InsertPlanParams)
	// InsertPlanScan scans the result of an executed InsertPlanBatch query.
	InsertPlanScan(results pgx.BatchResults) (InsertPlanRow, error)

	InsertPlanStatusTimestamp(ctx context.Context, id *string, status *string) (InsertPlanStatusTimestampRow, error)
	// InsertPlanStatusTimestampBatch enqueues a InsertPlanStatusTimestamp query into batch to be executed
	// later by the batch.
	InsertPlanStatusTimestampBatch(batch genericBatch, id *string, status *string)
	// InsertPlanStatusTimestampScan scans the result of an executed InsertPlanStatusTimestampBatch query.
	InsertPlanStatusTimestampScan(results pgx.BatchResults) (InsertPlanStatusTimestampRow, error)

	UpdatePlanStatus(ctx context.Context, status *string, id *string) (UpdatePlanStatusRow, error)
	// UpdatePlanStatusBatch enqueues a UpdatePlanStatus query into batch to be executed
	// later by the batch.
	UpdatePlanStatusBatch(batch genericBatch, status *string, id *string)
	// UpdatePlanStatusScan scans the result of an executed UpdatePlanStatusBatch query.
	UpdatePlanStatusScan(results pgx.BatchResults) (UpdatePlanStatusRow, error)

	GetPlanBinByRunID(ctx context.Context, runID *string) ([]byte, error)
	// GetPlanBinByRunIDBatch enqueues a GetPlanBinByRunID query into batch to be executed
	// later by the batch.
	GetPlanBinByRunIDBatch(batch genericBatch, runID *string)
	// GetPlanBinByRunIDScan scans the result of an executed GetPlanBinByRunIDBatch query.
	GetPlanBinByRunIDScan(results pgx.BatchResults) ([]byte, error)

	GetPlanJSONByRunID(ctx context.Context, runID *string) ([]byte, error)
	// GetPlanJSONByRunIDBatch enqueues a GetPlanJSONByRunID query into batch to be executed
	// later by the batch.
	GetPlanJSONByRunIDBatch(batch genericBatch, runID *string)
	// GetPlanJSONByRunIDScan scans the result of an executed GetPlanJSONByRunIDBatch query.
	GetPlanJSONByRunIDScan(results pgx.BatchResults) ([]byte, error)

	PutPlanBinByRunID(ctx context.Context, planBin []byte, runID *string) (pgconn.CommandTag, error)
	// PutPlanBinByRunIDBatch enqueues a PutPlanBinByRunID query into batch to be executed
	// later by the batch.
	PutPlanBinByRunIDBatch(batch genericBatch, planBin []byte, runID *string)
	// PutPlanBinByRunIDScan scans the result of an executed PutPlanBinByRunIDBatch query.
	PutPlanBinByRunIDScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	PutPlanJSONByRunID(ctx context.Context, planJson []byte, runID *string) (pgconn.CommandTag, error)
	// PutPlanJSONByRunIDBatch enqueues a PutPlanJSONByRunID query into batch to be executed
	// later by the batch.
	PutPlanJSONByRunIDBatch(batch genericBatch, planJson []byte, runID *string)
	// PutPlanJSONByRunIDScan scans the result of an executed PutPlanJSONByRunIDBatch query.
	PutPlanJSONByRunIDScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	UpdatePlanResources(ctx context.Context, params UpdatePlanResourcesParams) (pgconn.CommandTag, error)
	// UpdatePlanResourcesBatch enqueues a UpdatePlanResources query into batch to be executed
	// later by the batch.
	UpdatePlanResourcesBatch(batch genericBatch, params UpdatePlanResourcesParams)
	// UpdatePlanResourcesScan scans the result of an executed UpdatePlanResourcesBatch query.
	UpdatePlanResourcesScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	InsertPlanLogChunk(ctx context.Context, planID *string, chunk []byte) (InsertPlanLogChunkRow, error)
	// InsertPlanLogChunkBatch enqueues a InsertPlanLogChunk query into batch to be executed
	// later by the batch.
	InsertPlanLogChunkBatch(batch genericBatch, planID *string, chunk []byte)
	// InsertPlanLogChunkScan scans the result of an executed InsertPlanLogChunkBatch query.
	InsertPlanLogChunkScan(results pgx.BatchResults) (InsertPlanLogChunkRow, error)

	FindPlanLogChunks(ctx context.Context, params FindPlanLogChunksParams) ([]byte, error)
	// FindPlanLogChunksBatch enqueues a FindPlanLogChunks query into batch to be executed
	// later by the batch.
	FindPlanLogChunksBatch(batch genericBatch, params FindPlanLogChunksParams)
	// FindPlanLogChunksScan scans the result of an executed FindPlanLogChunksBatch query.
	FindPlanLogChunksScan(results pgx.BatchResults) ([]byte, error)

	InsertRun(ctx context.Context, params InsertRunParams) (InsertRunRow, error)
	// InsertRunBatch enqueues a InsertRun query into batch to be executed
	// later by the batch.
	InsertRunBatch(batch genericBatch, params InsertRunParams)
	// InsertRunScan scans the result of an executed InsertRunBatch query.
	InsertRunScan(results pgx.BatchResults) (InsertRunRow, error)

	InsertRunStatusTimestamp(ctx context.Context, id *string, status *string) (InsertRunStatusTimestampRow, error)
	// InsertRunStatusTimestampBatch enqueues a InsertRunStatusTimestamp query into batch to be executed
	// later by the batch.
	InsertRunStatusTimestampBatch(batch genericBatch, id *string, status *string)
	// InsertRunStatusTimestampScan scans the result of an executed InsertRunStatusTimestampBatch query.
	InsertRunStatusTimestampScan(results pgx.BatchResults) (InsertRunStatusTimestampRow, error)

	FindRunsByWorkspaceID(ctx context.Context, params FindRunsByWorkspaceIDParams) ([]FindRunsByWorkspaceIDRow, error)
	// FindRunsByWorkspaceIDBatch enqueues a FindRunsByWorkspaceID query into batch to be executed
	// later by the batch.
	FindRunsByWorkspaceIDBatch(batch genericBatch, params FindRunsByWorkspaceIDParams)
	// FindRunsByWorkspaceIDScan scans the result of an executed FindRunsByWorkspaceIDBatch query.
	FindRunsByWorkspaceIDScan(results pgx.BatchResults) ([]FindRunsByWorkspaceIDRow, error)

	FindRunsByWorkspaceName(ctx context.Context, params FindRunsByWorkspaceNameParams) ([]FindRunsByWorkspaceNameRow, error)
	// FindRunsByWorkspaceNameBatch enqueues a FindRunsByWorkspaceName query into batch to be executed
	// later by the batch.
	FindRunsByWorkspaceNameBatch(batch genericBatch, params FindRunsByWorkspaceNameParams)
	// FindRunsByWorkspaceNameScan scans the result of an executed FindRunsByWorkspaceNameBatch query.
	FindRunsByWorkspaceNameScan(results pgx.BatchResults) ([]FindRunsByWorkspaceNameRow, error)

	FindRunsByStatuses(ctx context.Context, params FindRunsByStatusesParams) ([]FindRunsByStatusesRow, error)
	// FindRunsByStatusesBatch enqueues a FindRunsByStatuses query into batch to be executed
	// later by the batch.
	FindRunsByStatusesBatch(batch genericBatch, params FindRunsByStatusesParams)
	// FindRunsByStatusesScan scans the result of an executed FindRunsByStatusesBatch query.
	FindRunsByStatusesScan(results pgx.BatchResults) ([]FindRunsByStatusesRow, error)

	FindRunByID(ctx context.Context, runID *string) (FindRunByIDRow, error)
	// FindRunByIDBatch enqueues a FindRunByID query into batch to be executed
	// later by the batch.
	FindRunByIDBatch(batch genericBatch, runID *string)
	// FindRunByIDScan scans the result of an executed FindRunByIDBatch query.
	FindRunByIDScan(results pgx.BatchResults) (FindRunByIDRow, error)

	FindRunByPlanID(ctx context.Context, planID *string) (FindRunByPlanIDRow, error)
	// FindRunByPlanIDBatch enqueues a FindRunByPlanID query into batch to be executed
	// later by the batch.
	FindRunByPlanIDBatch(batch genericBatch, planID *string)
	// FindRunByPlanIDScan scans the result of an executed FindRunByPlanIDBatch query.
	FindRunByPlanIDScan(results pgx.BatchResults) (FindRunByPlanIDRow, error)

	FindRunByApplyID(ctx context.Context, applyID *string) (FindRunByApplyIDRow, error)
	// FindRunByApplyIDBatch enqueues a FindRunByApplyID query into batch to be executed
	// later by the batch.
	FindRunByApplyIDBatch(batch genericBatch, applyID *string)
	// FindRunByApplyIDScan scans the result of an executed FindRunByApplyIDBatch query.
	FindRunByApplyIDScan(results pgx.BatchResults) (FindRunByApplyIDRow, error)

	FindRunByIDForUpdate(ctx context.Context, runID *string) (FindRunByIDForUpdateRow, error)
	// FindRunByIDForUpdateBatch enqueues a FindRunByIDForUpdate query into batch to be executed
	// later by the batch.
	FindRunByIDForUpdateBatch(batch genericBatch, runID *string)
	// FindRunByIDForUpdateScan scans the result of an executed FindRunByIDForUpdateBatch query.
	FindRunByIDForUpdateScan(results pgx.BatchResults) (FindRunByIDForUpdateRow, error)

	UpdateRunStatus(ctx context.Context, status *string, id *string) (UpdateRunStatusRow, error)
	// UpdateRunStatusBatch enqueues a UpdateRunStatus query into batch to be executed
	// later by the batch.
	UpdateRunStatusBatch(batch genericBatch, status *string, id *string)
	// UpdateRunStatusScan scans the result of an executed UpdateRunStatusBatch query.
	UpdateRunStatusScan(results pgx.BatchResults) (UpdateRunStatusRow, error)

	DeleteRunByID(ctx context.Context, runID *string) (pgconn.CommandTag, error)
	// DeleteRunByIDBatch enqueues a DeleteRunByID query into batch to be executed
	// later by the batch.
	DeleteRunByIDBatch(batch genericBatch, runID *string)
	// DeleteRunByIDScan scans the result of an executed DeleteRunByIDBatch query.
	DeleteRunByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	InsertSession(ctx context.Context, params InsertSessionParams) (InsertSessionRow, error)
	// InsertSessionBatch enqueues a InsertSession query into batch to be executed
	// later by the batch.
	InsertSessionBatch(batch genericBatch, params InsertSessionParams)
	// InsertSessionScan scans the result of an executed InsertSessionBatch query.
	InsertSessionScan(results pgx.BatchResults) (InsertSessionRow, error)

	FindSessionFlashByToken(ctx context.Context, token *string) ([]byte, error)
	// FindSessionFlashByTokenBatch enqueues a FindSessionFlashByToken query into batch to be executed
	// later by the batch.
	FindSessionFlashByTokenBatch(batch genericBatch, token *string)
	// FindSessionFlashByTokenScan scans the result of an executed FindSessionFlashByTokenBatch query.
	FindSessionFlashByTokenScan(results pgx.BatchResults) ([]byte, error)

	UpdateSessionFlashByToken(ctx context.Context, flash []byte, token *string) (pgconn.CommandTag, error)
	// UpdateSessionFlashByTokenBatch enqueues a UpdateSessionFlashByToken query into batch to be executed
	// later by the batch.
	UpdateSessionFlashByTokenBatch(batch genericBatch, flash []byte, token *string)
	// UpdateSessionFlashByTokenScan scans the result of an executed UpdateSessionFlashByTokenBatch query.
	UpdateSessionFlashByTokenScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	UpdateSessionUserID(ctx context.Context, userID *string, token *string) (UpdateSessionUserIDRow, error)
	// UpdateSessionUserIDBatch enqueues a UpdateSessionUserID query into batch to be executed
	// later by the batch.
	UpdateSessionUserIDBatch(batch genericBatch, userID *string, token *string)
	// UpdateSessionUserIDScan scans the result of an executed UpdateSessionUserIDBatch query.
	UpdateSessionUserIDScan(results pgx.BatchResults) (UpdateSessionUserIDRow, error)

	UpdateSessionExpiry(ctx context.Context, expiry time.Time, token *string) (UpdateSessionExpiryRow, error)
	// UpdateSessionExpiryBatch enqueues a UpdateSessionExpiry query into batch to be executed
	// later by the batch.
	UpdateSessionExpiryBatch(batch genericBatch, expiry time.Time, token *string)
	// UpdateSessionExpiryScan scans the result of an executed UpdateSessionExpiryBatch query.
	UpdateSessionExpiryScan(results pgx.BatchResults) (UpdateSessionExpiryRow, error)

	UpdateSessionFlash(ctx context.Context, flash []byte, token *string) (UpdateSessionFlashRow, error)
	// UpdateSessionFlashBatch enqueues a UpdateSessionFlash query into batch to be executed
	// later by the batch.
	UpdateSessionFlashBatch(batch genericBatch, flash []byte, token *string)
	// UpdateSessionFlashScan scans the result of an executed UpdateSessionFlashBatch query.
	UpdateSessionFlashScan(results pgx.BatchResults) (UpdateSessionFlashRow, error)

	DeleteSessionByToken(ctx context.Context, token *string) (pgconn.CommandTag, error)
	// DeleteSessionByTokenBatch enqueues a DeleteSessionByToken query into batch to be executed
	// later by the batch.
	DeleteSessionByTokenBatch(batch genericBatch, token *string)
	// DeleteSessionByTokenScan scans the result of an executed DeleteSessionByTokenBatch query.
	DeleteSessionByTokenScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	DeleteSessionsExpired(ctx context.Context) (pgconn.CommandTag, error)
	// DeleteSessionsExpiredBatch enqueues a DeleteSessionsExpired query into batch to be executed
	// later by the batch.
	DeleteSessionsExpiredBatch(batch genericBatch)
	// DeleteSessionsExpiredScan scans the result of an executed DeleteSessionsExpiredBatch query.
	DeleteSessionsExpiredScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	InsertStateVersion(ctx context.Context, params InsertStateVersionParams) (InsertStateVersionRow, error)
	// InsertStateVersionBatch enqueues a InsertStateVersion query into batch to be executed
	// later by the batch.
	InsertStateVersionBatch(batch genericBatch, params InsertStateVersionParams)
	// InsertStateVersionScan scans the result of an executed InsertStateVersionBatch query.
	InsertStateVersionScan(results pgx.BatchResults) (InsertStateVersionRow, error)

	FindStateVersionsByWorkspaceName(ctx context.Context, params FindStateVersionsByWorkspaceNameParams) ([]FindStateVersionsByWorkspaceNameRow, error)
	// FindStateVersionsByWorkspaceNameBatch enqueues a FindStateVersionsByWorkspaceName query into batch to be executed
	// later by the batch.
	FindStateVersionsByWorkspaceNameBatch(batch genericBatch, params FindStateVersionsByWorkspaceNameParams)
	// FindStateVersionsByWorkspaceNameScan scans the result of an executed FindStateVersionsByWorkspaceNameBatch query.
	FindStateVersionsByWorkspaceNameScan(results pgx.BatchResults) ([]FindStateVersionsByWorkspaceNameRow, error)

	FindStateVersionByID(ctx context.Context, id *string) (FindStateVersionByIDRow, error)
	// FindStateVersionByIDBatch enqueues a FindStateVersionByID query into batch to be executed
	// later by the batch.
	FindStateVersionByIDBatch(batch genericBatch, id *string)
	// FindStateVersionByIDScan scans the result of an executed FindStateVersionByIDBatch query.
	FindStateVersionByIDScan(results pgx.BatchResults) (FindStateVersionByIDRow, error)

	FindStateVersionLatestByWorkspaceID(ctx context.Context, workspaceID *string) (FindStateVersionLatestByWorkspaceIDRow, error)
	// FindStateVersionLatestByWorkspaceIDBatch enqueues a FindStateVersionLatestByWorkspaceID query into batch to be executed
	// later by the batch.
	FindStateVersionLatestByWorkspaceIDBatch(batch genericBatch, workspaceID *string)
	// FindStateVersionLatestByWorkspaceIDScan scans the result of an executed FindStateVersionLatestByWorkspaceIDBatch query.
	FindStateVersionLatestByWorkspaceIDScan(results pgx.BatchResults) (FindStateVersionLatestByWorkspaceIDRow, error)

	DeleteStateVersionByID(ctx context.Context, stateVersionID *string) (pgconn.CommandTag, error)
	// DeleteStateVersionByIDBatch enqueues a DeleteStateVersionByID query into batch to be executed
	// later by the batch.
	DeleteStateVersionByIDBatch(batch genericBatch, stateVersionID *string)
	// DeleteStateVersionByIDScan scans the result of an executed DeleteStateVersionByIDBatch query.
	DeleteStateVersionByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	// InsertStateVersionOutput inserts a state_version_output and returns the entire row.
	// 
	InsertStateVersionOutput(ctx context.Context, params InsertStateVersionOutputParams) (InsertStateVersionOutputRow, error)
	// InsertStateVersionOutputBatch enqueues a InsertStateVersionOutput query into batch to be executed
	// later by the batch.
	InsertStateVersionOutputBatch(batch genericBatch, params InsertStateVersionOutputParams)
	// InsertStateVersionOutputScan scans the result of an executed InsertStateVersionOutputBatch query.
	InsertStateVersionOutputScan(results pgx.BatchResults) (InsertStateVersionOutputRow, error)

	InsertToken(ctx context.Context, params InsertTokenParams) (InsertTokenRow, error)
	// InsertTokenBatch enqueues a InsertToken query into batch to be executed
	// later by the batch.
	InsertTokenBatch(batch genericBatch, params InsertTokenParams)
	// InsertTokenScan scans the result of an executed InsertTokenBatch query.
	InsertTokenScan(results pgx.BatchResults) (InsertTokenRow, error)

	DeleteTokenByID(ctx context.Context, tokenID *string) (pgconn.CommandTag, error)
	// DeleteTokenByIDBatch enqueues a DeleteTokenByID query into batch to be executed
	// later by the batch.
	DeleteTokenByIDBatch(batch genericBatch, tokenID *string)
	// DeleteTokenByIDScan scans the result of an executed DeleteTokenByIDBatch query.
	DeleteTokenByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	InsertUser(ctx context.Context, params InsertUserParams) (InsertUserRow, error)
	// InsertUserBatch enqueues a InsertUser query into batch to be executed
	// later by the batch.
	InsertUserBatch(batch genericBatch, params InsertUserParams)
	// InsertUserScan scans the result of an executed InsertUserBatch query.
	InsertUserScan(results pgx.BatchResults) (InsertUserRow, error)

	FindUsers(ctx context.Context) ([]FindUsersRow, error)
	// FindUsersBatch enqueues a FindUsers query into batch to be executed
	// later by the batch.
	FindUsersBatch(batch genericBatch)
	// FindUsersScan scans the result of an executed FindUsersBatch query.
	FindUsersScan(results pgx.BatchResults) ([]FindUsersRow, error)

	FindUserByID(ctx context.Context, userID *string) (FindUserByIDRow, error)
	// FindUserByIDBatch enqueues a FindUserByID query into batch to be executed
	// later by the batch.
	FindUserByIDBatch(batch genericBatch, userID *string)
	// FindUserByIDScan scans the result of an executed FindUserByIDBatch query.
	FindUserByIDScan(results pgx.BatchResults) (FindUserByIDRow, error)

	FindUserByUsername(ctx context.Context, username *string) (FindUserByUsernameRow, error)
	// FindUserByUsernameBatch enqueues a FindUserByUsername query into batch to be executed
	// later by the batch.
	FindUserByUsernameBatch(batch genericBatch, username *string)
	// FindUserByUsernameScan scans the result of an executed FindUserByUsernameBatch query.
	FindUserByUsernameScan(results pgx.BatchResults) (FindUserByUsernameRow, error)

	FindUserBySessionToken(ctx context.Context, token *string) (FindUserBySessionTokenRow, error)
	// FindUserBySessionTokenBatch enqueues a FindUserBySessionToken query into batch to be executed
	// later by the batch.
	FindUserBySessionTokenBatch(batch genericBatch, token *string)
	// FindUserBySessionTokenScan scans the result of an executed FindUserBySessionTokenBatch query.
	FindUserBySessionTokenScan(results pgx.BatchResults) (FindUserBySessionTokenRow, error)

	FindUserByAuthenticationToken(ctx context.Context, token *string) (FindUserByAuthenticationTokenRow, error)
	// FindUserByAuthenticationTokenBatch enqueues a FindUserByAuthenticationToken query into batch to be executed
	// later by the batch.
	FindUserByAuthenticationTokenBatch(batch genericBatch, token *string)
	// FindUserByAuthenticationTokenScan scans the result of an executed FindUserByAuthenticationTokenBatch query.
	FindUserByAuthenticationTokenScan(results pgx.BatchResults) (FindUserByAuthenticationTokenRow, error)

	FindUserByAuthenticationTokenID(ctx context.Context, tokenID *string) (FindUserByAuthenticationTokenIDRow, error)
	// FindUserByAuthenticationTokenIDBatch enqueues a FindUserByAuthenticationTokenID query into batch to be executed
	// later by the batch.
	FindUserByAuthenticationTokenIDBatch(batch genericBatch, tokenID *string)
	// FindUserByAuthenticationTokenIDScan scans the result of an executed FindUserByAuthenticationTokenIDBatch query.
	FindUserByAuthenticationTokenIDScan(results pgx.BatchResults) (FindUserByAuthenticationTokenIDRow, error)

	UpdateUserCurrentOrganization(ctx context.Context, currentOrganization *string, id *string) (UpdateUserCurrentOrganizationRow, error)
	// UpdateUserCurrentOrganizationBatch enqueues a UpdateUserCurrentOrganization query into batch to be executed
	// later by the batch.
	UpdateUserCurrentOrganizationBatch(batch genericBatch, currentOrganization *string, id *string)
	// UpdateUserCurrentOrganizationScan scans the result of an executed UpdateUserCurrentOrganizationBatch query.
	UpdateUserCurrentOrganizationScan(results pgx.BatchResults) (UpdateUserCurrentOrganizationRow, error)

	DeleteUserByID(ctx context.Context, userID *string) (pgconn.CommandTag, error)
	// DeleteUserByIDBatch enqueues a DeleteUserByID query into batch to be executed
	// later by the batch.
	DeleteUserByIDBatch(batch genericBatch, userID *string)
	// DeleteUserByIDScan scans the result of an executed DeleteUserByIDBatch query.
	DeleteUserByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	DeleteUserByUsername(ctx context.Context, username *string) (pgconn.CommandTag, error)
	// DeleteUserByUsernameBatch enqueues a DeleteUserByUsername query into batch to be executed
	// later by the batch.
	DeleteUserByUsernameBatch(batch genericBatch, username *string)
	// DeleteUserByUsernameScan scans the result of an executed DeleteUserByUsernameBatch query.
	DeleteUserByUsernameScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	// InsertWorkspace inserts a workspace and returns the entire row.
	// 
	InsertWorkspace(ctx context.Context, params InsertWorkspaceParams) (InsertWorkspaceRow, error)
	// InsertWorkspaceBatch enqueues a InsertWorkspace query into batch to be executed
	// later by the batch.
	InsertWorkspaceBatch(batch genericBatch, params InsertWorkspaceParams)
	// InsertWorkspaceScan scans the result of an executed InsertWorkspaceBatch query.
	InsertWorkspaceScan(results pgx.BatchResults) (InsertWorkspaceRow, error)

	// FindWorkspaces finds workspaces for a given organization.
	// Workspace name can be filtered with a prefix.
	// Results are paginated with limit and offset, and total count is returned.
	// 
	FindWorkspaces(ctx context.Context, params FindWorkspacesParams) ([]FindWorkspacesRow, error)
	// FindWorkspacesBatch enqueues a FindWorkspaces query into batch to be executed
	// later by the batch.
	FindWorkspacesBatch(batch genericBatch, params FindWorkspacesParams)
	// FindWorkspacesScan scans the result of an executed FindWorkspacesBatch query.
	FindWorkspacesScan(results pgx.BatchResults) ([]FindWorkspacesRow, error)

	// FindWorkspaceByName finds a workspace by name and organization name.
	// 
	FindWorkspaceByName(ctx context.Context, name *string, organizationName *string) (FindWorkspaceByNameRow, error)
	// FindWorkspaceByNameBatch enqueues a FindWorkspaceByName query into batch to be executed
	// later by the batch.
	FindWorkspaceByNameBatch(batch genericBatch, name *string, organizationName *string)
	// FindWorkspaceByNameScan scans the result of an executed FindWorkspaceByNameBatch query.
	FindWorkspaceByNameScan(results pgx.BatchResults) (FindWorkspaceByNameRow, error)

	FindWorkspaceByNameForUpdate(ctx context.Context, name *string, organizationName *string) (FindWorkspaceByNameForUpdateRow, error)
	// FindWorkspaceByNameForUpdateBatch enqueues a FindWorkspaceByNameForUpdate query into batch to be executed
	// later by the batch.
	FindWorkspaceByNameForUpdateBatch(batch genericBatch, name *string, organizationName *string)
	// FindWorkspaceByNameForUpdateScan scans the result of an executed FindWorkspaceByNameForUpdateBatch query.
	FindWorkspaceByNameForUpdateScan(results pgx.BatchResults) (FindWorkspaceByNameForUpdateRow, error)

	// FindWorkspaceByID finds a workspace by id.
	// 
	FindWorkspaceByID(ctx context.Context, id *string) (FindWorkspaceByIDRow, error)
	// FindWorkspaceByIDBatch enqueues a FindWorkspaceByID query into batch to be executed
	// later by the batch.
	FindWorkspaceByIDBatch(batch genericBatch, id *string)
	// FindWorkspaceByIDScan scans the result of an executed FindWorkspaceByIDBatch query.
	FindWorkspaceByIDScan(results pgx.BatchResults) (FindWorkspaceByIDRow, error)

	FindWorkspaceByIDForUpdate(ctx context.Context, id *string) (FindWorkspaceByIDForUpdateRow, error)
	// FindWorkspaceByIDForUpdateBatch enqueues a FindWorkspaceByIDForUpdate query into batch to be executed
	// later by the batch.
	FindWorkspaceByIDForUpdateBatch(batch genericBatch, id *string)
	// FindWorkspaceByIDForUpdateScan scans the result of an executed FindWorkspaceByIDForUpdateBatch query.
	FindWorkspaceByIDForUpdateScan(results pgx.BatchResults) (FindWorkspaceByIDForUpdateRow, error)

	// UpdateWorkspaceNameByID updates an workspace with a new name,
	// identifying the workspace with its id, and returns the
	// updated row.
	// 
	UpdateWorkspaceNameByID(ctx context.Context, name *string, id *string) (UpdateWorkspaceNameByIDRow, error)
	// UpdateWorkspaceNameByIDBatch enqueues a UpdateWorkspaceNameByID query into batch to be executed
	// later by the batch.
	UpdateWorkspaceNameByIDBatch(batch genericBatch, name *string, id *string)
	// UpdateWorkspaceNameByIDScan scans the result of an executed UpdateWorkspaceNameByIDBatch query.
	UpdateWorkspaceNameByIDScan(results pgx.BatchResults) (UpdateWorkspaceNameByIDRow, error)

	// UpdateWorkspaceAllowDestroyPlanByID updates the AllowDestroyPlan
	// attribute on a workspace identified by id, and returns the updated row.
	// 
	UpdateWorkspaceAllowDestroyPlanByID(ctx context.Context, allowDestroyPlan *bool, id *string) (UpdateWorkspaceAllowDestroyPlanByIDRow, error)
	// UpdateWorkspaceAllowDestroyPlanByIDBatch enqueues a UpdateWorkspaceAllowDestroyPlanByID query into batch to be executed
	// later by the batch.
	UpdateWorkspaceAllowDestroyPlanByIDBatch(batch genericBatch, allowDestroyPlan *bool, id *string)
	// UpdateWorkspaceAllowDestroyPlanByIDScan scans the result of an executed UpdateWorkspaceAllowDestroyPlanByIDBatch query.
	UpdateWorkspaceAllowDestroyPlanByIDScan(results pgx.BatchResults) (UpdateWorkspaceAllowDestroyPlanByIDRow, error)

	UpdateWorkspaceLockByID(ctx context.Context, lock *bool, id *string) (UpdateWorkspaceLockByIDRow, error)
	// UpdateWorkspaceLockByIDBatch enqueues a UpdateWorkspaceLockByID query into batch to be executed
	// later by the batch.
	UpdateWorkspaceLockByIDBatch(batch genericBatch, lock *bool, id *string)
	// UpdateWorkspaceLockByIDScan scans the result of an executed UpdateWorkspaceLockByIDBatch query.
	UpdateWorkspaceLockByIDScan(results pgx.BatchResults) (UpdateWorkspaceLockByIDRow, error)

	UpdateWorkspaceDescriptionByID(ctx context.Context, description *string, id *string) (UpdateWorkspaceDescriptionByIDRow, error)
	// UpdateWorkspaceDescriptionByIDBatch enqueues a UpdateWorkspaceDescriptionByID query into batch to be executed
	// later by the batch.
	UpdateWorkspaceDescriptionByIDBatch(batch genericBatch, description *string, id *string)
	// UpdateWorkspaceDescriptionByIDScan scans the result of an executed UpdateWorkspaceDescriptionByIDBatch query.
	UpdateWorkspaceDescriptionByIDScan(results pgx.BatchResults) (UpdateWorkspaceDescriptionByIDRow, error)

	// DeleteOrganization deletes an organization by id.
	// DeleteWorkspaceByID deletes a workspace by id.
	// 
	DeleteWorkspaceByID(ctx context.Context, workspaceID *string) (pgconn.CommandTag, error)
	// DeleteWorkspaceByIDBatch enqueues a DeleteWorkspaceByID query into batch to be executed
	// later by the batch.
	DeleteWorkspaceByIDBatch(batch genericBatch, workspaceID *string)
	// DeleteWorkspaceByIDScan scans the result of an executed DeleteWorkspaceByIDBatch query.
	DeleteWorkspaceByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error)

	// DeleteWorkspaceByName deletes a workspace by name and organization name.
	// 
	DeleteWorkspaceByName(ctx context.Context, name *string, organizationName *string) (pgconn.CommandTag, error)
	// DeleteWorkspaceByNameBatch enqueues a DeleteWorkspaceByName query into batch to be executed
	// later by the batch.
	DeleteWorkspaceByNameBatch(batch genericBatch, name *string, organizationName *string)
	// DeleteWorkspaceByNameScan scans the result of an executed DeleteWorkspaceByNameBatch query.
	DeleteWorkspaceByNameScan(results pgx.BatchResults) (pgconn.CommandTag, error)
}

type DBQuerier struct {
	conn  genericConn   // underlying Postgres transport to use
	types *typeResolver // resolve types by name
}

var _ Querier = &DBQuerier{}

// genericConn is a connection to a Postgres database. This is usually backed by
// *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
type genericConn interface {
	// Query executes sql with args. If there is an error the returned Rows will
	// be returned in an error state. So it is allowed to ignore the error
	// returned from Query and handle it in Rows.
	Query(ctx context.Context, sql string, args ...interface{}) (pgx.Rows, error)

	// QueryRow is a convenience wrapper over Query. Any error that occurs while
	// querying is deferred until calling Scan on the returned Row. That Row will
	// error with pgx.ErrNoRows if no rows are returned.
	QueryRow(ctx context.Context, sql string, args ...interface{}) pgx.Row

	// Exec executes sql. sql can be either a prepared statement name or an SQL
	// string. arguments should be referenced positionally from the sql string
	// as $1, $2, etc.
	Exec(ctx context.Context, sql string, arguments ...interface{}) (pgconn.CommandTag, error)
}

// genericBatch batches queries to send in a single network request to a
// Postgres server. This is usually backed by *pgx.Batch.
type genericBatch interface {
	// Queue queues a query to batch b. query can be an SQL query or the name of a
	// prepared statement. See Queue on *pgx.Batch.
	Queue(query string, arguments ...interface{})
}

// NewQuerier creates a DBQuerier that implements Querier. conn is typically
// *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
func NewQuerier(conn genericConn) *DBQuerier {
	return NewQuerierConfig(conn, QuerierConfig{})
}

type QuerierConfig struct {
	// DataTypes contains pgtype.Value to use for encoding and decoding instead
	// of pggen-generated pgtype.ValueTranscoder.
	//
	// If OIDs are available for an input parameter type and all of its
	// transitive dependencies, pggen will use the binary encoding format for
	// the input parameter.
	DataTypes []pgtype.DataType
}

// NewQuerierConfig creates a DBQuerier that implements Querier with the given
// config. conn is typically *pgx.Conn, pgx.Tx, or *pgxpool.Pool.
func NewQuerierConfig(conn genericConn, cfg QuerierConfig) *DBQuerier {
	return &DBQuerier{conn: conn, types: newTypeResolver(cfg.DataTypes)}
}

// WithTx creates a new DBQuerier that uses the transaction to run all queries.
func (q *DBQuerier) WithTx(tx pgx.Tx) (*DBQuerier, error) {
	return &DBQuerier{conn: tx}, nil
}

// preparer is any Postgres connection transport that provides a way to prepare
// a statement, most commonly *pgx.Conn.
type preparer interface {
	Prepare(ctx context.Context, name, sql string) (sd *pgconn.StatementDescription, err error)
}

// PrepareAllQueries executes a PREPARE statement for all pggen generated SQL
// queries in querier files. Typical usage is as the AfterConnect callback
// for pgxpool.Config
//
// pgx will use the prepared statement if available. Calling PrepareAllQueries
// is an optional optimization to avoid a network round-trip the first time pgx
// runs a query if pgx statement caching is enabled.
func PrepareAllQueries(ctx context.Context, p preparer) error {
	if _, err := p.Prepare(ctx, insertApplySQL, insertApplySQL); err != nil {
		return fmt.Errorf("prepare query 'InsertApply': %w", err)
	}
	if _, err := p.Prepare(ctx, insertApplyStatusTimestampSQL, insertApplyStatusTimestampSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertApplyStatusTimestamp': %w", err)
	}
	if _, err := p.Prepare(ctx, updateApplyStatusSQL, updateApplyStatusSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateApplyStatus': %w", err)
	}
	if _, err := p.Prepare(ctx, updateApplyResourcesSQL, updateApplyResourcesSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateApplyResources': %w", err)
	}
	if _, err := p.Prepare(ctx, insertApplyLogChunkSQL, insertApplyLogChunkSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertApplyLogChunk': %w", err)
	}
	if _, err := p.Prepare(ctx, findApplyLogChunksSQL, findApplyLogChunksSQL); err != nil {
		return fmt.Errorf("prepare query 'FindApplyLogChunks': %w", err)
	}
	if _, err := p.Prepare(ctx, insertConfigurationVersionSQL, insertConfigurationVersionSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertConfigurationVersion': %w", err)
	}
	if _, err := p.Prepare(ctx, insertConfigurationVersionStatusTimestampSQL, insertConfigurationVersionStatusTimestampSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertConfigurationVersionStatusTimestamp': %w", err)
	}
	if _, err := p.Prepare(ctx, findConfigurationVersionsByWorkspaceIDSQL, findConfigurationVersionsByWorkspaceIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindConfigurationVersionsByWorkspaceID': %w", err)
	}
	if _, err := p.Prepare(ctx, findConfigurationVersionByIDSQL, findConfigurationVersionByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindConfigurationVersionByID': %w", err)
	}
	if _, err := p.Prepare(ctx, findConfigurationVersionLatestByWorkspaceIDSQL, findConfigurationVersionLatestByWorkspaceIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindConfigurationVersionLatestByWorkspaceID': %w", err)
	}
	if _, err := p.Prepare(ctx, findConfigurationVersionByIDForUpdateSQL, findConfigurationVersionByIDForUpdateSQL); err != nil {
		return fmt.Errorf("prepare query 'FindConfigurationVersionByIDForUpdate': %w", err)
	}
	if _, err := p.Prepare(ctx, downloadConfigurationVersionSQL, downloadConfigurationVersionSQL); err != nil {
		return fmt.Errorf("prepare query 'DownloadConfigurationVersion': %w", err)
	}
	if _, err := p.Prepare(ctx, updateConfigurationVersionStatusSQL, updateConfigurationVersionStatusSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateConfigurationVersionStatus': %w", err)
	}
	if _, err := p.Prepare(ctx, updateConfigurationVersionConfigSQL, updateConfigurationVersionConfigSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateConfigurationVersionConfig': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteConfigurationVersionByIDSQL, deleteConfigurationVersionByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteConfigurationVersionByID': %w", err)
	}
	if _, err := p.Prepare(ctx, findOrganizationByNameSQL, findOrganizationByNameSQL); err != nil {
		return fmt.Errorf("prepare query 'FindOrganizationByName': %w", err)
	}
	if _, err := p.Prepare(ctx, findOrganizationsSQL, findOrganizationsSQL); err != nil {
		return fmt.Errorf("prepare query 'FindOrganizations': %w", err)
	}
	if _, err := p.Prepare(ctx, insertOrganizationSQL, insertOrganizationSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertOrganization': %w", err)
	}
	if _, err := p.Prepare(ctx, updateOrganizationNameByNameSQL, updateOrganizationNameByNameSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateOrganizationNameByName': %w", err)
	}
	if _, err := p.Prepare(ctx, updateOrganizationSessionRememberByNameSQL, updateOrganizationSessionRememberByNameSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateOrganizationSessionRememberByName': %w", err)
	}
	if _, err := p.Prepare(ctx, updateOrganizationSessionTimeoutByNameSQL, updateOrganizationSessionTimeoutByNameSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateOrganizationSessionTimeoutByName': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteOrganizationSQL, deleteOrganizationSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteOrganization': %w", err)
	}
	if _, err := p.Prepare(ctx, insertOrganizationMembershipSQL, insertOrganizationMembershipSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertOrganizationMembership': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteOrganizationMembershipSQL, deleteOrganizationMembershipSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteOrganizationMembership': %w", err)
	}
	if _, err := p.Prepare(ctx, insertPlanSQL, insertPlanSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertPlan': %w", err)
	}
	if _, err := p.Prepare(ctx, insertPlanStatusTimestampSQL, insertPlanStatusTimestampSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertPlanStatusTimestamp': %w", err)
	}
	if _, err := p.Prepare(ctx, updatePlanStatusSQL, updatePlanStatusSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdatePlanStatus': %w", err)
	}
	if _, err := p.Prepare(ctx, getPlanBinByRunIDSQL, getPlanBinByRunIDSQL); err != nil {
		return fmt.Errorf("prepare query 'GetPlanBinByRunID': %w", err)
	}
	if _, err := p.Prepare(ctx, getPlanJSONByRunIDSQL, getPlanJSONByRunIDSQL); err != nil {
		return fmt.Errorf("prepare query 'GetPlanJSONByRunID': %w", err)
	}
	if _, err := p.Prepare(ctx, putPlanBinByRunIDSQL, putPlanBinByRunIDSQL); err != nil {
		return fmt.Errorf("prepare query 'PutPlanBinByRunID': %w", err)
	}
	if _, err := p.Prepare(ctx, putPlanJSONByRunIDSQL, putPlanJSONByRunIDSQL); err != nil {
		return fmt.Errorf("prepare query 'PutPlanJSONByRunID': %w", err)
	}
	if _, err := p.Prepare(ctx, updatePlanResourcesSQL, updatePlanResourcesSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdatePlanResources': %w", err)
	}
	if _, err := p.Prepare(ctx, insertPlanLogChunkSQL, insertPlanLogChunkSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertPlanLogChunk': %w", err)
	}
	if _, err := p.Prepare(ctx, findPlanLogChunksSQL, findPlanLogChunksSQL); err != nil {
		return fmt.Errorf("prepare query 'FindPlanLogChunks': %w", err)
	}
	if _, err := p.Prepare(ctx, insertRunSQL, insertRunSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertRun': %w", err)
	}
	if _, err := p.Prepare(ctx, insertRunStatusTimestampSQL, insertRunStatusTimestampSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertRunStatusTimestamp': %w", err)
	}
	if _, err := p.Prepare(ctx, findRunsByWorkspaceIDSQL, findRunsByWorkspaceIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindRunsByWorkspaceID': %w", err)
	}
	if _, err := p.Prepare(ctx, findRunsByWorkspaceNameSQL, findRunsByWorkspaceNameSQL); err != nil {
		return fmt.Errorf("prepare query 'FindRunsByWorkspaceName': %w", err)
	}
	if _, err := p.Prepare(ctx, findRunsByStatusesSQL, findRunsByStatusesSQL); err != nil {
		return fmt.Errorf("prepare query 'FindRunsByStatuses': %w", err)
	}
	if _, err := p.Prepare(ctx, findRunByIDSQL, findRunByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindRunByID': %w", err)
	}
	if _, err := p.Prepare(ctx, findRunByPlanIDSQL, findRunByPlanIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindRunByPlanID': %w", err)
	}
	if _, err := p.Prepare(ctx, findRunByApplyIDSQL, findRunByApplyIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindRunByApplyID': %w", err)
	}
	if _, err := p.Prepare(ctx, findRunByIDForUpdateSQL, findRunByIDForUpdateSQL); err != nil {
		return fmt.Errorf("prepare query 'FindRunByIDForUpdate': %w", err)
	}
	if _, err := p.Prepare(ctx, updateRunStatusSQL, updateRunStatusSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateRunStatus': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteRunByIDSQL, deleteRunByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteRunByID': %w", err)
	}
	if _, err := p.Prepare(ctx, insertSessionSQL, insertSessionSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertSession': %w", err)
	}
	if _, err := p.Prepare(ctx, findSessionFlashByTokenSQL, findSessionFlashByTokenSQL); err != nil {
		return fmt.Errorf("prepare query 'FindSessionFlashByToken': %w", err)
	}
	if _, err := p.Prepare(ctx, updateSessionFlashByTokenSQL, updateSessionFlashByTokenSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateSessionFlashByToken': %w", err)
	}
	if _, err := p.Prepare(ctx, updateSessionUserIDSQL, updateSessionUserIDSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateSessionUserID': %w", err)
	}
	if _, err := p.Prepare(ctx, updateSessionExpirySQL, updateSessionExpirySQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateSessionExpiry': %w", err)
	}
	if _, err := p.Prepare(ctx, updateSessionFlashSQL, updateSessionFlashSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateSessionFlash': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteSessionByTokenSQL, deleteSessionByTokenSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteSessionByToken': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteSessionsExpiredSQL, deleteSessionsExpiredSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteSessionsExpired': %w", err)
	}
	if _, err := p.Prepare(ctx, insertStateVersionSQL, insertStateVersionSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertStateVersion': %w", err)
	}
	if _, err := p.Prepare(ctx, findStateVersionsByWorkspaceNameSQL, findStateVersionsByWorkspaceNameSQL); err != nil {
		return fmt.Errorf("prepare query 'FindStateVersionsByWorkspaceName': %w", err)
	}
	if _, err := p.Prepare(ctx, findStateVersionByIDSQL, findStateVersionByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindStateVersionByID': %w", err)
	}
	if _, err := p.Prepare(ctx, findStateVersionLatestByWorkspaceIDSQL, findStateVersionLatestByWorkspaceIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindStateVersionLatestByWorkspaceID': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteStateVersionByIDSQL, deleteStateVersionByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteStateVersionByID': %w", err)
	}
	if _, err := p.Prepare(ctx, insertStateVersionOutputSQL, insertStateVersionOutputSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertStateVersionOutput': %w", err)
	}
	if _, err := p.Prepare(ctx, insertTokenSQL, insertTokenSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertToken': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteTokenByIDSQL, deleteTokenByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteTokenByID': %w", err)
	}
	if _, err := p.Prepare(ctx, insertUserSQL, insertUserSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertUser': %w", err)
	}
	if _, err := p.Prepare(ctx, findUsersSQL, findUsersSQL); err != nil {
		return fmt.Errorf("prepare query 'FindUsers': %w", err)
	}
	if _, err := p.Prepare(ctx, findUserByIDSQL, findUserByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindUserByID': %w", err)
	}
	if _, err := p.Prepare(ctx, findUserByUsernameSQL, findUserByUsernameSQL); err != nil {
		return fmt.Errorf("prepare query 'FindUserByUsername': %w", err)
	}
	if _, err := p.Prepare(ctx, findUserBySessionTokenSQL, findUserBySessionTokenSQL); err != nil {
		return fmt.Errorf("prepare query 'FindUserBySessionToken': %w", err)
	}
	if _, err := p.Prepare(ctx, findUserByAuthenticationTokenSQL, findUserByAuthenticationTokenSQL); err != nil {
		return fmt.Errorf("prepare query 'FindUserByAuthenticationToken': %w", err)
	}
	if _, err := p.Prepare(ctx, findUserByAuthenticationTokenIDSQL, findUserByAuthenticationTokenIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindUserByAuthenticationTokenID': %w", err)
	}
	if _, err := p.Prepare(ctx, updateUserCurrentOrganizationSQL, updateUserCurrentOrganizationSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateUserCurrentOrganization': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteUserByIDSQL, deleteUserByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteUserByID': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteUserByUsernameSQL, deleteUserByUsernameSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteUserByUsername': %w", err)
	}
	if _, err := p.Prepare(ctx, insertWorkspaceSQL, insertWorkspaceSQL); err != nil {
		return fmt.Errorf("prepare query 'InsertWorkspace': %w", err)
	}
	if _, err := p.Prepare(ctx, findWorkspacesSQL, findWorkspacesSQL); err != nil {
		return fmt.Errorf("prepare query 'FindWorkspaces': %w", err)
	}
	if _, err := p.Prepare(ctx, findWorkspaceByNameSQL, findWorkspaceByNameSQL); err != nil {
		return fmt.Errorf("prepare query 'FindWorkspaceByName': %w", err)
	}
	if _, err := p.Prepare(ctx, findWorkspaceByNameForUpdateSQL, findWorkspaceByNameForUpdateSQL); err != nil {
		return fmt.Errorf("prepare query 'FindWorkspaceByNameForUpdate': %w", err)
	}
	if _, err := p.Prepare(ctx, findWorkspaceByIDSQL, findWorkspaceByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'FindWorkspaceByID': %w", err)
	}
	if _, err := p.Prepare(ctx, findWorkspaceByIDForUpdateSQL, findWorkspaceByIDForUpdateSQL); err != nil {
		return fmt.Errorf("prepare query 'FindWorkspaceByIDForUpdate': %w", err)
	}
	if _, err := p.Prepare(ctx, updateWorkspaceNameByIDSQL, updateWorkspaceNameByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateWorkspaceNameByID': %w", err)
	}
	if _, err := p.Prepare(ctx, updateWorkspaceAllowDestroyPlanByIDSQL, updateWorkspaceAllowDestroyPlanByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateWorkspaceAllowDestroyPlanByID': %w", err)
	}
	if _, err := p.Prepare(ctx, updateWorkspaceLockByIDSQL, updateWorkspaceLockByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateWorkspaceLockByID': %w", err)
	}
	if _, err := p.Prepare(ctx, updateWorkspaceDescriptionByIDSQL, updateWorkspaceDescriptionByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'UpdateWorkspaceDescriptionByID': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteWorkspaceByIDSQL, deleteWorkspaceByIDSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteWorkspaceByID': %w", err)
	}
	if _, err := p.Prepare(ctx, deleteWorkspaceByNameSQL, deleteWorkspaceByNameSQL); err != nil {
		return fmt.Errorf("prepare query 'DeleteWorkspaceByName': %w", err)
	}
	return nil
}

// Applies represents the Postgres composite type "applies".
type Applies struct {
	ApplyID              *string   `json:"apply_id"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	ResourceAdditions    *int32    `json:"resource_additions"`
	ResourceChanges      *int32    `json:"resource_changes"`
	ResourceDestructions *int32    `json:"resource_destructions"`
	Status               *string   `json:"status"`
	RunID                *string   `json:"run_id"`
}

func (s Applies) GetApplyID() *string { return s.ApplyID }
func (s Applies) GetCreatedAt() time.Time { return s.CreatedAt }
func (s Applies) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s Applies) GetResourceAdditions() *int32 { return s.ResourceAdditions }
func (s Applies) GetResourceChanges() *int32 { return s.ResourceChanges }
func (s Applies) GetResourceDestructions() *int32 { return s.ResourceDestructions }
func (s Applies) GetStatus() *string { return s.Status }
func (s Applies) GetRunID() *string { return s.RunID }


// ConfigurationVersionStatusTimestamps represents the Postgres composite type "configuration_version_status_timestamps".
type ConfigurationVersionStatusTimestamps struct {
	ConfigurationVersionID *string   `json:"configuration_version_id"`
	Status                 *string   `json:"status"`
	Timestamp              time.Time `json:"timestamp"`
}

func (s ConfigurationVersionStatusTimestamps) GetConfigurationVersionID() *string { return s.ConfigurationVersionID }
func (s ConfigurationVersionStatusTimestamps) GetStatus() *string { return s.Status }
func (s ConfigurationVersionStatusTimestamps) GetTimestamp() time.Time { return s.Timestamp }


// ConfigurationVersions represents the Postgres composite type "configuration_versions".
type ConfigurationVersions struct {
	ConfigurationVersionID *string   `json:"configuration_version_id"`
	CreatedAt              time.Time `json:"created_at"`
	UpdatedAt              time.Time `json:"updated_at"`
	AutoQueueRuns          *bool     `json:"auto_queue_runs"`
	Source                 *string   `json:"source"`
	Speculative            *bool     `json:"speculative"`
	Status                 *string   `json:"status"`
	Config                 []byte    `json:"config"`
	WorkspaceID            *string   `json:"workspace_id"`
}

func (s ConfigurationVersions) GetConfigurationVersionID() *string { return s.ConfigurationVersionID }
func (s ConfigurationVersions) GetCreatedAt() time.Time { return s.CreatedAt }
func (s ConfigurationVersions) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s ConfigurationVersions) GetAutoQueueRuns() *bool { return s.AutoQueueRuns }
func (s ConfigurationVersions) GetSource() *string { return s.Source }
func (s ConfigurationVersions) GetSpeculative() *bool { return s.Speculative }
func (s ConfigurationVersions) GetStatus() *string { return s.Status }
func (s ConfigurationVersions) GetConfig() []byte { return s.Config }
func (s ConfigurationVersions) GetWorkspaceID() *string { return s.WorkspaceID }


// Organizations represents the Postgres composite type "organizations".
type Organizations struct {
	OrganizationID  *string   `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            *string   `json:"name"`
	SessionRemember *int32    `json:"session_remember"`
	SessionTimeout  *int32    `json:"session_timeout"`
}

func (s Organizations) GetOrganizationID() *string { return s.OrganizationID }
func (s Organizations) GetCreatedAt() time.Time { return s.CreatedAt }
func (s Organizations) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s Organizations) GetName() *string { return s.Name }
func (s Organizations) GetSessionRemember() *int32 { return s.SessionRemember }
func (s Organizations) GetSessionTimeout() *int32 { return s.SessionTimeout }


// Plans represents the Postgres composite type "plans".
type Plans struct {
	PlanID               *string   `json:"plan_id"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	ResourceAdditions    *int32    `json:"resource_additions"`
	ResourceChanges      *int32    `json:"resource_changes"`
	ResourceDestructions *int32    `json:"resource_destructions"`
	Status               *string   `json:"status"`
	StatusTimestamps     *string   `json:"status_timestamps"`
	PlanBin              []byte    `json:"plan_bin"`
	PlanJson             []byte    `json:"plan_json"`
	RunID                *string   `json:"run_id"`
}

func (s Plans) GetPlanID() *string { return s.PlanID }
func (s Plans) GetCreatedAt() time.Time { return s.CreatedAt }
func (s Plans) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s Plans) GetResourceAdditions() *int32 { return s.ResourceAdditions }
func (s Plans) GetResourceChanges() *int32 { return s.ResourceChanges }
func (s Plans) GetResourceDestructions() *int32 { return s.ResourceDestructions }
func (s Plans) GetStatus() *string { return s.Status }
func (s Plans) GetStatusTimestamps() *string { return s.StatusTimestamps }
func (s Plans) GetPlanBin() []byte { return s.PlanBin }
func (s Plans) GetPlanJson() []byte { return s.PlanJson }
func (s Plans) GetRunID() *string { return s.RunID }


// RunStatusTimestamps represents the Postgres composite type "run_status_timestamps".
type RunStatusTimestamps struct {
	RunID     *string   `json:"run_id"`
	Status    *string   `json:"status"`
	Timestamp time.Time `json:"timestamp"`
}

func (s RunStatusTimestamps) GetRunID() *string { return s.RunID }
func (s RunStatusTimestamps) GetStatus() *string { return s.Status }
func (s RunStatusTimestamps) GetTimestamp() time.Time { return s.Timestamp }


// Sessions represents the Postgres composite type "sessions".
type Sessions struct {
	Token     *string   `json:"token"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	Address   *string   `json:"address"`
	Flash     []byte    `json:"flash"`
	Expiry    time.Time `json:"expiry"`
	UserID    *string   `json:"user_id"`
}

func (s Sessions) GetToken() *string { return s.Token }
func (s Sessions) GetCreatedAt() time.Time { return s.CreatedAt }
func (s Sessions) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s Sessions) GetAddress() *string { return s.Address }
func (s Sessions) GetFlash() []byte { return s.Flash }
func (s Sessions) GetExpiry() time.Time { return s.Expiry }
func (s Sessions) GetUserID() *string { return s.UserID }


// StateVersionOutputs represents the Postgres composite type "state_version_outputs".
type StateVersionOutputs struct {
	StateVersionOutputID *string   `json:"state_version_output_id"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	Name                 *string   `json:"name"`
	Sensitive            *bool     `json:"sensitive"`
	Type                 *string   `json:"type"`
	Value                *string   `json:"value"`
	StateVersionID       *string   `json:"state_version_id"`
}

func (s StateVersionOutputs) GetStateVersionOutputID() *string { return s.StateVersionOutputID }
func (s StateVersionOutputs) GetCreatedAt() time.Time { return s.CreatedAt }
func (s StateVersionOutputs) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s StateVersionOutputs) GetName() *string { return s.Name }
func (s StateVersionOutputs) GetSensitive() *bool { return s.Sensitive }
func (s StateVersionOutputs) GetType() *string { return s.Type }
func (s StateVersionOutputs) GetValue() *string { return s.Value }
func (s StateVersionOutputs) GetStateVersionID() *string { return s.StateVersionID }


// Tokens represents the Postgres composite type "tokens".
type Tokens struct {
	TokenID     *string   `json:"token_id"`
	Token       *string   `json:"token"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	Description *string   `json:"description"`
	UserID      *string   `json:"user_id"`
}

func (s Tokens) GetTokenID() *string { return s.TokenID }
func (s Tokens) GetToken() *string { return s.Token }
func (s Tokens) GetCreatedAt() time.Time { return s.CreatedAt }
func (s Tokens) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s Tokens) GetDescription() *string { return s.Description }
func (s Tokens) GetUserID() *string { return s.UserID }


// Workspaces represents the Postgres composite type "workspaces".
type Workspaces struct {
	WorkspaceID                *string   `json:"workspace_id"`
	CreatedAt                  time.Time `json:"created_at"`
	UpdatedAt                  time.Time `json:"updated_at"`
	AllowDestroyPlan           *bool     `json:"allow_destroy_plan"`
	AutoApply                  *bool     `json:"auto_apply"`
	CanQueueDestroyPlan        *bool     `json:"can_queue_destroy_plan"`
	Description                *string   `json:"description"`
	Environment                *string   `json:"environment"`
	ExecutionMode              *string   `json:"execution_mode"`
	FileTriggersEnabled        *bool     `json:"file_triggers_enabled"`
	GlobalRemoteState          *bool     `json:"global_remote_state"`
	Locked                     *bool     `json:"locked"`
	MigrationEnvironment       *string   `json:"migration_environment"`
	Name                       *string   `json:"name"`
	QueueAllRuns               *bool     `json:"queue_all_runs"`
	SpeculativeEnabled         *bool     `json:"speculative_enabled"`
	SourceName                 *string   `json:"source_name"`
	SourceUrl                  *string   `json:"source_url"`
	StructuredRunOutputEnabled *bool     `json:"structured_run_output_enabled"`
	TerraformVersion           *string   `json:"terraform_version"`
	TriggerPrefixes            []string  `json:"trigger_prefixes"`
	WorkingDirectory           *string   `json:"working_directory"`
	OrganizationID             *string   `json:"organization_id"`
}

func (s Workspaces) GetWorkspaceID() *string { return s.WorkspaceID }
func (s Workspaces) GetCreatedAt() time.Time { return s.CreatedAt }
func (s Workspaces) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s Workspaces) GetAllowDestroyPlan() *bool { return s.AllowDestroyPlan }
func (s Workspaces) GetAutoApply() *bool { return s.AutoApply }
func (s Workspaces) GetCanQueueDestroyPlan() *bool { return s.CanQueueDestroyPlan }
func (s Workspaces) GetDescription() *string { return s.Description }
func (s Workspaces) GetEnvironment() *string { return s.Environment }
func (s Workspaces) GetExecutionMode() *string { return s.ExecutionMode }
func (s Workspaces) GetFileTriggersEnabled() *bool { return s.FileTriggersEnabled }
func (s Workspaces) GetGlobalRemoteState() *bool { return s.GlobalRemoteState }
func (s Workspaces) GetLocked() *bool { return s.Locked }
func (s Workspaces) GetMigrationEnvironment() *string { return s.MigrationEnvironment }
func (s Workspaces) GetName() *string { return s.Name }
func (s Workspaces) GetQueueAllRuns() *bool { return s.QueueAllRuns }
func (s Workspaces) GetSpeculativeEnabled() *bool { return s.SpeculativeEnabled }
func (s Workspaces) GetSourceName() *string { return s.SourceName }
func (s Workspaces) GetSourceUrl() *string { return s.SourceUrl }
func (s Workspaces) GetStructuredRunOutputEnabled() *bool { return s.StructuredRunOutputEnabled }
func (s Workspaces) GetTerraformVersion() *string { return s.TerraformVersion }
func (s Workspaces) GetTriggerPrefixes() []string { return s.TriggerPrefixes }
func (s Workspaces) GetWorkingDirectory() *string { return s.WorkingDirectory }
func (s Workspaces) GetOrganizationID() *string { return s.OrganizationID }


// typeResolver looks up the pgtype.ValueTranscoder by Postgres type name.
type typeResolver struct {
	connInfo *pgtype.ConnInfo // types by Postgres type name
}

func newTypeResolver(types []pgtype.DataType) *typeResolver {
	ci := pgtype.NewConnInfo()
	for _, typ := range types {
		if txt, ok := typ.Value.(textPreferrer); ok && typ.OID != unknownOID {
			typ.Value = txt.ValueTranscoder
		}
		ci.RegisterDataType(typ)
	}
	return &typeResolver{connInfo: ci}
}

// findValue find the OID, and pgtype.ValueTranscoder for a Postgres type name.
func (tr *typeResolver) findValue(name string) (uint32, pgtype.ValueTranscoder, bool) {
	typ, ok := tr.connInfo.DataTypeForName(name)
	if !ok {
		return 0, nil, false
	}
	v := pgtype.NewValue(typ.Value)
	return typ.OID, v.(pgtype.ValueTranscoder), true
}

// setValue sets the value of a ValueTranscoder to a value that should always
// work and panics if it fails.
func (tr *typeResolver) setValue(vt pgtype.ValueTranscoder, val interface{}) pgtype.ValueTranscoder {
	if err := vt.Set(val); err != nil {
		panic(fmt.Sprintf("set ValueTranscoder %T to %+v: %s", vt, val, err))
	}
	return vt
}

type compositeField struct {
	name       string                 // name of the field
	typeName   string                 // Postgres type name
	defaultVal pgtype.ValueTranscoder // default value to use
}

func (tr *typeResolver) newCompositeValue(name string, fields ...compositeField) pgtype.ValueTranscoder {
	if _, val, ok := tr.findValue(name); ok {
		return val
	}
	fs := make([]pgtype.CompositeTypeField, len(fields))
	vals := make([]pgtype.ValueTranscoder, len(fields))
	isBinaryOk := true
	for i, field := range fields {
		oid, val, ok := tr.findValue(field.typeName)
		if !ok {
			oid = unknownOID
			val = field.defaultVal
		}
		isBinaryOk = isBinaryOk && oid != unknownOID
		fs[i] = pgtype.CompositeTypeField{Name: field.name, OID: oid}
		vals[i] = val
	}
	// Okay to ignore error because it's only thrown when the number of field
	// names does not equal the number of ValueTranscoders.
	typ, _ := pgtype.NewCompositeTypeValues(name, fs, vals)
	if !isBinaryOk {
		return textPreferrer{typ, name}
	}
	return typ
}

func (tr *typeResolver) newArrayValue(name, elemName string, defaultVal func() pgtype.ValueTranscoder) pgtype.ValueTranscoder {
	if _, val, ok := tr.findValue(name); ok {
		return val
	}
	elemOID, elemVal, ok := tr.findValue(elemName)
	elemValFunc := func() pgtype.ValueTranscoder {
		return pgtype.NewValue(elemVal).(pgtype.ValueTranscoder)
	}
	if !ok {
		elemOID = unknownOID
		elemValFunc = defaultVal
	}
	typ := pgtype.NewArrayType(name, elemOID, elemValFunc)
	if elemOID == unknownOID {
		return textPreferrer{typ, name}
	}
	return typ
}

// newApplies creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'applies'.
func (tr *typeResolver) newApplies() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"applies",
		compositeField{"apply_id", "text", &pgtype.Text{}},
		compositeField{"created_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"updated_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"resource_additions", "int4", &pgtype.Int4{}},
		compositeField{"resource_changes", "int4", &pgtype.Int4{}},
		compositeField{"resource_destructions", "int4", &pgtype.Int4{}},
		compositeField{"status", "text", &pgtype.Text{}},
		compositeField{"run_id", "text", &pgtype.Text{}},
	)
}

// newConfigurationVersionStatusTimestamps creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'configuration_version_status_timestamps'.
func (tr *typeResolver) newConfigurationVersionStatusTimestamps() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"configuration_version_status_timestamps",
		compositeField{"configuration_version_id", "text", &pgtype.Text{}},
		compositeField{"status", "text", &pgtype.Text{}},
		compositeField{"timestamp", "timestamptz", &pgtype.Timestamptz{}},
	)
}

// newConfigurationVersions creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'configuration_versions'.
func (tr *typeResolver) newConfigurationVersions() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"configuration_versions",
		compositeField{"configuration_version_id", "text", &pgtype.Text{}},
		compositeField{"created_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"updated_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"auto_queue_runs", "bool", &pgtype.Bool{}},
		compositeField{"source", "text", &pgtype.Text{}},
		compositeField{"speculative", "bool", &pgtype.Bool{}},
		compositeField{"status", "text", &pgtype.Text{}},
		compositeField{"config", "bytea", &pgtype.Bytea{}},
		compositeField{"workspace_id", "text", &pgtype.Text{}},
	)
}

// newOrganizations creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'organizations'.
func (tr *typeResolver) newOrganizations() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"organizations",
		compositeField{"organization_id", "text", &pgtype.Text{}},
		compositeField{"created_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"updated_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"name", "text", &pgtype.Text{}},
		compositeField{"session_remember", "int4", &pgtype.Int4{}},
		compositeField{"session_timeout", "int4", &pgtype.Int4{}},
	)
}

// newPlans creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'plans'.
func (tr *typeResolver) newPlans() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"plans",
		compositeField{"plan_id", "text", &pgtype.Text{}},
		compositeField{"created_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"updated_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"resource_additions", "int4", &pgtype.Int4{}},
		compositeField{"resource_changes", "int4", &pgtype.Int4{}},
		compositeField{"resource_destructions", "int4", &pgtype.Int4{}},
		compositeField{"status", "text", &pgtype.Text{}},
		compositeField{"status_timestamps", "text", &pgtype.Text{}},
		compositeField{"plan_bin", "bytea", &pgtype.Bytea{}},
		compositeField{"plan_json", "bytea", &pgtype.Bytea{}},
		compositeField{"run_id", "text", &pgtype.Text{}},
	)
}

// newRunStatusTimestamps creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'run_status_timestamps'.
func (tr *typeResolver) newRunStatusTimestamps() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"run_status_timestamps",
		compositeField{"run_id", "text", &pgtype.Text{}},
		compositeField{"status", "text", &pgtype.Text{}},
		compositeField{"timestamp", "timestamptz", &pgtype.Timestamptz{}},
	)
}

// newSessions creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'sessions'.
func (tr *typeResolver) newSessions() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"sessions",
		compositeField{"token", "text", &pgtype.Text{}},
		compositeField{"created_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"updated_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"address", "text", &pgtype.Text{}},
		compositeField{"flash", "bytea", &pgtype.Bytea{}},
		compositeField{"expiry", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"user_id", "text", &pgtype.Text{}},
	)
}

// newStateVersionOutputs creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'state_version_outputs'.
func (tr *typeResolver) newStateVersionOutputs() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"state_version_outputs",
		compositeField{"state_version_output_id", "text", &pgtype.Text{}},
		compositeField{"created_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"updated_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"name", "text", &pgtype.Text{}},
		compositeField{"sensitive", "bool", &pgtype.Bool{}},
		compositeField{"type", "text", &pgtype.Text{}},
		compositeField{"value", "text", &pgtype.Text{}},
		compositeField{"state_version_id", "text", &pgtype.Text{}},
	)
}

// newTokens creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'tokens'.
func (tr *typeResolver) newTokens() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"tokens",
		compositeField{"token_id", "text", &pgtype.Text{}},
		compositeField{"token", "text", &pgtype.Text{}},
		compositeField{"created_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"updated_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"description", "text", &pgtype.Text{}},
		compositeField{"user_id", "text", &pgtype.Text{}},
	)
}

// newWorkspaces creates a new pgtype.ValueTranscoder for the Postgres
// composite type 'workspaces'.
func (tr *typeResolver) newWorkspaces() pgtype.ValueTranscoder {
	return tr.newCompositeValue(
		"workspaces",
		compositeField{"workspace_id", "text", &pgtype.Text{}},
		compositeField{"created_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"updated_at", "timestamptz", &pgtype.Timestamptz{}},
		compositeField{"allow_destroy_plan", "bool", &pgtype.Bool{}},
		compositeField{"auto_apply", "bool", &pgtype.Bool{}},
		compositeField{"can_queue_destroy_plan", "bool", &pgtype.Bool{}},
		compositeField{"description", "text", &pgtype.Text{}},
		compositeField{"environment", "text", &pgtype.Text{}},
		compositeField{"execution_mode", "text", &pgtype.Text{}},
		compositeField{"file_triggers_enabled", "bool", &pgtype.Bool{}},
		compositeField{"global_remote_state", "bool", &pgtype.Bool{}},
		compositeField{"locked", "bool", &pgtype.Bool{}},
		compositeField{"migration_environment", "text", &pgtype.Text{}},
		compositeField{"name", "text", &pgtype.Text{}},
		compositeField{"queue_all_runs", "bool", &pgtype.Bool{}},
		compositeField{"speculative_enabled", "bool", &pgtype.Bool{}},
		compositeField{"source_name", "text", &pgtype.Text{}},
		compositeField{"source_url", "text", &pgtype.Text{}},
		compositeField{"structured_run_output_enabled", "bool", &pgtype.Bool{}},
		compositeField{"terraform_version", "text", &pgtype.Text{}},
		compositeField{"trigger_prefixes", "_text", &pgtype.TextArray{}},
		compositeField{"working_directory", "text", &pgtype.Text{}},
		compositeField{"organization_id", "text", &pgtype.Text{}},
	)
}

// newConfigurationVersionStatusTimestampsArray creates a new pgtype.ValueTranscoder for the Postgres
// '_configuration_version_status_timestamps' array type.
func (tr *typeResolver) newConfigurationVersionStatusTimestampsArray() pgtype.ValueTranscoder {
	return tr.newArrayValue("_configuration_version_status_timestamps", "configuration_version_status_timestamps", tr.newConfigurationVersionStatusTimestamps)
}

// newOrganizationsArray creates a new pgtype.ValueTranscoder for the Postgres
// '_organizations' array type.
func (tr *typeResolver) newOrganizationsArray() pgtype.ValueTranscoder {
	return tr.newArrayValue("_organizations", "organizations", tr.newOrganizations)
}

// newRunStatusTimestampsArray creates a new pgtype.ValueTranscoder for the Postgres
// '_run_status_timestamps' array type.
func (tr *typeResolver) newRunStatusTimestampsArray() pgtype.ValueTranscoder {
	return tr.newArrayValue("_run_status_timestamps", "run_status_timestamps", tr.newRunStatusTimestamps)
}

// newSessionsArray creates a new pgtype.ValueTranscoder for the Postgres
// '_sessions' array type.
func (tr *typeResolver) newSessionsArray() pgtype.ValueTranscoder {
	return tr.newArrayValue("_sessions", "sessions", tr.newSessions)
}

// newStateVersionOutputsArray creates a new pgtype.ValueTranscoder for the Postgres
// '_state_version_outputs' array type.
func (tr *typeResolver) newStateVersionOutputsArray() pgtype.ValueTranscoder {
	return tr.newArrayValue("_state_version_outputs", "state_version_outputs", tr.newStateVersionOutputs)
}

// newTokensArray creates a new pgtype.ValueTranscoder for the Postgres
// '_tokens' array type.
func (tr *typeResolver) newTokensArray() pgtype.ValueTranscoder {
	return tr.newArrayValue("_tokens", "tokens", tr.newTokens)
}

const insertApplySQL = `INSERT INTO applies (
    apply_id,
    created_at,
    updated_at,
    status,
    run_id
) VALUES (
    $1,
    NOW(),
    NOW(),
    $2,
    $3
)
RETURNING *;`

type InsertApplyParams struct {
	ID     *string
	Status *string
	RunID  *string
}

type InsertApplyRow struct {
	ApplyID              *string   `json:"apply_id"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	ResourceAdditions    int32     `json:"resource_additions"`
	ResourceChanges      int32     `json:"resource_changes"`
	ResourceDestructions int32     `json:"resource_destructions"`
	Status               *string   `json:"status"`
	RunID                *string   `json:"run_id"`
}

func (s InsertApplyRow) GetApplyID() *string { return s.ApplyID }
func (s InsertApplyRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s InsertApplyRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s InsertApplyRow) GetResourceAdditions() int32 { return s.ResourceAdditions }
func (s InsertApplyRow) GetResourceChanges() int32 { return s.ResourceChanges }
func (s InsertApplyRow) GetResourceDestructions() int32 { return s.ResourceDestructions }
func (s InsertApplyRow) GetStatus() *string { return s.Status }
func (s InsertApplyRow) GetRunID() *string { return s.RunID }


// InsertApply implements Querier.InsertApply.
func (q *DBQuerier) InsertApply(ctx context.Context, params InsertApplyParams) (InsertApplyRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertApply")
	row := q.conn.QueryRow(ctx, insertApplySQL, params.ID, params.Status, params.RunID)
	var item InsertApplyRow
	if err := row.Scan(&item.ApplyID, &item.CreatedAt, &item.UpdatedAt, &item.ResourceAdditions, &item.ResourceChanges, &item.ResourceDestructions, &item.Status, &item.RunID); err != nil {
		return item, fmt.Errorf("query InsertApply: %w", err)
	}
	return item, nil
}

// InsertApplyBatch implements Querier.InsertApplyBatch.
func (q *DBQuerier) InsertApplyBatch(batch genericBatch, params InsertApplyParams) {
	batch.Queue(insertApplySQL, params.ID, params.Status, params.RunID)
}

// InsertApplyScan implements Querier.InsertApplyScan.
func (q *DBQuerier) InsertApplyScan(results pgx.BatchResults) (InsertApplyRow, error) {
	row := results.QueryRow()
	var item InsertApplyRow
	if err := row.Scan(&item.ApplyID, &item.CreatedAt, &item.UpdatedAt, &item.ResourceAdditions, &item.ResourceChanges, &item.ResourceDestructions, &item.Status, &item.RunID); err != nil {
		return item, fmt.Errorf("scan InsertApplyBatch row: %w", err)
	}
	return item, nil
}

const insertApplyStatusTimestampSQL = `INSERT INTO apply_status_timestamps (
    apply_id,
    status,
    timestamp
) VALUES (
    $1,
    $2,
    NOW()
)
RETURNING *;`

type InsertApplyStatusTimestampRow struct {
	ApplyID   *string   `json:"apply_id"`
	Status    *string   `json:"status"`
	Timestamp time.Time `json:"timestamp"`
}

func (s InsertApplyStatusTimestampRow) GetApplyID() *string { return s.ApplyID }
func (s InsertApplyStatusTimestampRow) GetStatus() *string { return s.Status }
func (s InsertApplyStatusTimestampRow) GetTimestamp() time.Time { return s.Timestamp }


// InsertApplyStatusTimestamp implements Querier.InsertApplyStatusTimestamp.
func (q *DBQuerier) InsertApplyStatusTimestamp(ctx context.Context, id *string, status *string) (InsertApplyStatusTimestampRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertApplyStatusTimestamp")
	row := q.conn.QueryRow(ctx, insertApplyStatusTimestampSQL, id, status)
	var item InsertApplyStatusTimestampRow
	if err := row.Scan(&item.ApplyID, &item.Status, &item.Timestamp); err != nil {
		return item, fmt.Errorf("query InsertApplyStatusTimestamp: %w", err)
	}
	return item, nil
}

// InsertApplyStatusTimestampBatch implements Querier.InsertApplyStatusTimestampBatch.
func (q *DBQuerier) InsertApplyStatusTimestampBatch(batch genericBatch, id *string, status *string) {
	batch.Queue(insertApplyStatusTimestampSQL, id, status)
}

// InsertApplyStatusTimestampScan implements Querier.InsertApplyStatusTimestampScan.
func (q *DBQuerier) InsertApplyStatusTimestampScan(results pgx.BatchResults) (InsertApplyStatusTimestampRow, error) {
	row := results.QueryRow()
	var item InsertApplyStatusTimestampRow
	if err := row.Scan(&item.ApplyID, &item.Status, &item.Timestamp); err != nil {
		return item, fmt.Errorf("scan InsertApplyStatusTimestampBatch row: %w", err)
	}
	return item, nil
}

const updateApplyStatusSQL = `UPDATE applies
SET
    status = $1,
    updated_at = NOW()
WHERE apply_id = $2
RETURNING *;`

type UpdateApplyStatusRow struct {
	ApplyID              *string   `json:"apply_id"`
	CreatedAt            time.Time `json:"created_at"`
	UpdatedAt            time.Time `json:"updated_at"`
	ResourceAdditions    int32     `json:"resource_additions"`
	ResourceChanges      int32     `json:"resource_changes"`
	ResourceDestructions int32     `json:"resource_destructions"`
	Status               *string   `json:"status"`
	RunID                *string   `json:"run_id"`
}

func (s UpdateApplyStatusRow) GetApplyID() *string { return s.ApplyID }
func (s UpdateApplyStatusRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s UpdateApplyStatusRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s UpdateApplyStatusRow) GetResourceAdditions() int32 { return s.ResourceAdditions }
func (s UpdateApplyStatusRow) GetResourceChanges() int32 { return s.ResourceChanges }
func (s UpdateApplyStatusRow) GetResourceDestructions() int32 { return s.ResourceDestructions }
func (s UpdateApplyStatusRow) GetStatus() *string { return s.Status }
func (s UpdateApplyStatusRow) GetRunID() *string { return s.RunID }


// UpdateApplyStatus implements Querier.UpdateApplyStatus.
func (q *DBQuerier) UpdateApplyStatus(ctx context.Context, status *string, id *string) (UpdateApplyStatusRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateApplyStatus")
	row := q.conn.QueryRow(ctx, updateApplyStatusSQL, status, id)
	var item UpdateApplyStatusRow
	if err := row.Scan(&item.ApplyID, &item.CreatedAt, &item.UpdatedAt, &item.ResourceAdditions, &item.ResourceChanges, &item.ResourceDestructions, &item.Status, &item.RunID); err != nil {
		return item, fmt.Errorf("query UpdateApplyStatus: %w", err)
	}
	return item, nil
}

// UpdateApplyStatusBatch implements Querier.UpdateApplyStatusBatch.
func (q *DBQuerier) UpdateApplyStatusBatch(batch genericBatch, status *string, id *string) {
	batch.Queue(updateApplyStatusSQL, status, id)
}

// UpdateApplyStatusScan implements Querier.UpdateApplyStatusScan.
func (q *DBQuerier) UpdateApplyStatusScan(results pgx.BatchResults) (UpdateApplyStatusRow, error) {
	row := results.QueryRow()
	var item UpdateApplyStatusRow
	if err := row.Scan(&item.ApplyID, &item.CreatedAt, &item.UpdatedAt, &item.ResourceAdditions, &item.ResourceChanges, &item.ResourceDestructions, &item.Status, &item.RunID); err != nil {
		return item, fmt.Errorf("scan UpdateApplyStatusBatch row: %w", err)
	}
	return item, nil
}

const updateApplyResourcesSQL = `UPDATE applies
SET
    resource_additions = $1,
    resource_changes = $2,
    resource_destructions = $3
WHERE run_id = $4
;`

type UpdateApplyResourcesParams struct {
	ResourceAdditions    int32
	ResourceChanges      int32
	ResourceDestructions int32
	RunID                *string
}

// UpdateApplyResources implements Querier.UpdateApplyResources.
func (q *DBQuerier) UpdateApplyResources(ctx context.Context, params UpdateApplyResourcesParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateApplyResources")
	cmdTag, err := q.conn.Exec(ctx, updateApplyResourcesSQL, params.ResourceAdditions, params.ResourceChanges, params.ResourceDestructions, params.RunID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query UpdateApplyResources: %w", err)
	}
	return cmdTag, err
}

// UpdateApplyResourcesBatch implements Querier.UpdateApplyResourcesBatch.
func (q *DBQuerier) UpdateApplyResourcesBatch(batch genericBatch, params UpdateApplyResourcesParams) {
	batch.Queue(updateApplyResourcesSQL, params.ResourceAdditions, params.ResourceChanges, params.ResourceDestructions, params.RunID)
}

// UpdateApplyResourcesScan implements Querier.UpdateApplyResourcesScan.
func (q *DBQuerier) UpdateApplyResourcesScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec UpdateApplyResourcesBatch: %w", err)
	}
	return cmdTag, err
}

// textPreferrer wraps a pgtype.ValueTranscoder and sets the preferred encoding
// format to text instead binary (the default). pggen uses the text format
// when the OID is unknownOID because the binary format requires the OID.
// Typically occurs if the results from QueryAllDataTypes aren't passed to
// NewQuerierConfig.
type textPreferrer struct {
	pgtype.ValueTranscoder
	typeName string
}

// PreferredParamFormat implements pgtype.ParamFormatPreferrer.
func (t textPreferrer) PreferredParamFormat() int16 { return pgtype.TextFormatCode }

func (t textPreferrer) NewTypeValue() pgtype.Value {
	return textPreferrer{pgtype.NewValue(t.ValueTranscoder).(pgtype.ValueTranscoder), t.typeName}
}

func (t textPreferrer) TypeName() string {
	return t.typeName
}

// unknownOID means we don't know the OID for a type. This is okay for decoding
// because pgx call DecodeText or DecodeBinary without requiring the OID. For
// encoding parameters, pggen uses textPreferrer if the OID is unknown.
const unknownOID = 0
