// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertTeamSQL = `INSERT INTO teams (
    team_id,
    name,
    created_at,
    organization_id
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertTeamParams struct {
	ID             pgtype.Text
	Name           pgtype.Text
	CreatedAt      pgtype.Timestamptz
	OrganizationID pgtype.Text
}

// InsertTeam implements Querier.InsertTeam.
func (q *DBQuerier) InsertTeam(ctx context.Context, params InsertTeamParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertTeam")
	cmdTag, err := q.conn.Exec(ctx, insertTeamSQL, params.ID, params.Name, params.CreatedAt, params.OrganizationID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertTeam: %w", err)
	}
	return cmdTag, err
}

// InsertTeamBatch implements Querier.InsertTeamBatch.
func (q *DBQuerier) InsertTeamBatch(batch genericBatch, params InsertTeamParams) {
	batch.Queue(insertTeamSQL, params.ID, params.Name, params.CreatedAt, params.OrganizationID)
}

// InsertTeamScan implements Querier.InsertTeamScan.
func (q *DBQuerier) InsertTeamScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertTeamBatch: %w", err)
	}
	return cmdTag, err
}

const findTeamsByOrgSQL = `SELECT
    t.*,
    (o.*)::"organizations" AS organization
FROM teams t
JOIN organizations o USING (organization_id)
WHERE o.name = $1
;`

type FindTeamsByOrgRow struct {
	TeamID                     pgtype.Text        `json:"team_id"`
	Name                       pgtype.Text        `json:"name"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	OrganizationID             pgtype.Text        `json:"organization_id"`
	PermissionManageWorkspaces bool               `json:"permission_manage_workspaces"`
	Organization               *Organizations     `json:"organization"`
}

// FindTeamsByOrg implements Querier.FindTeamsByOrg.
func (q *DBQuerier) FindTeamsByOrg(ctx context.Context, organizationName pgtype.Text) ([]FindTeamsByOrgRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamsByOrg")
	rows, err := q.conn.Query(ctx, findTeamsByOrgSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindTeamsByOrg: %w", err)
	}
	defer rows.Close()
	items := []FindTeamsByOrgRow{}
	organizationRow := q.types.newOrganizations()
	for rows.Next() {
		var item FindTeamsByOrgRow
		if err := rows.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, organizationRow); err != nil {
			return nil, fmt.Errorf("scan FindTeamsByOrg row: %w", err)
		}
		if err := organizationRow.AssignTo(&item.Organization); err != nil {
			return nil, fmt.Errorf("assign FindTeamsByOrg row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindTeamsByOrg rows: %w", err)
	}
	return items, err
}

// FindTeamsByOrgBatch implements Querier.FindTeamsByOrgBatch.
func (q *DBQuerier) FindTeamsByOrgBatch(batch genericBatch, organizationName pgtype.Text) {
	batch.Queue(findTeamsByOrgSQL, organizationName)
}

// FindTeamsByOrgScan implements Querier.FindTeamsByOrgScan.
func (q *DBQuerier) FindTeamsByOrgScan(results pgx.BatchResults) ([]FindTeamsByOrgRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindTeamsByOrgBatch: %w", err)
	}
	defer rows.Close()
	items := []FindTeamsByOrgRow{}
	organizationRow := q.types.newOrganizations()
	for rows.Next() {
		var item FindTeamsByOrgRow
		if err := rows.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, organizationRow); err != nil {
			return nil, fmt.Errorf("scan FindTeamsByOrgBatch row: %w", err)
		}
		if err := organizationRow.AssignTo(&item.Organization); err != nil {
			return nil, fmt.Errorf("assign FindTeamsByOrg row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindTeamsByOrgBatch rows: %w", err)
	}
	return items, err
}

const findTeamByNameSQL = `SELECT
    t.*,
    (o.*)::"organizations" AS organization
FROM teams t
JOIN organizations o USING (organization_id)
WHERE t.name = $1
AND   o.name = $2
;`

type FindTeamByNameRow struct {
	TeamID                     pgtype.Text        `json:"team_id"`
	Name                       pgtype.Text        `json:"name"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	OrganizationID             pgtype.Text        `json:"organization_id"`
	PermissionManageWorkspaces bool               `json:"permission_manage_workspaces"`
	Organization               *Organizations     `json:"organization"`
}

// FindTeamByName implements Querier.FindTeamByName.
func (q *DBQuerier) FindTeamByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindTeamByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamByName")
	row := q.conn.QueryRow(ctx, findTeamByNameSQL, name, organizationName)
	var item FindTeamByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, organizationRow); err != nil {
		return item, fmt.Errorf("query FindTeamByName: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByName row: %w", err)
	}
	return item, nil
}

// FindTeamByNameBatch implements Querier.FindTeamByNameBatch.
func (q *DBQuerier) FindTeamByNameBatch(batch genericBatch, name pgtype.Text, organizationName pgtype.Text) {
	batch.Queue(findTeamByNameSQL, name, organizationName)
}

// FindTeamByNameScan implements Querier.FindTeamByNameScan.
func (q *DBQuerier) FindTeamByNameScan(results pgx.BatchResults) (FindTeamByNameRow, error) {
	row := results.QueryRow()
	var item FindTeamByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindTeamByNameBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByName row: %w", err)
	}
	return item, nil
}

const findTeamByNameForUpdateSQL = `SELECT
    t.*,
    (o.*)::"organizations" AS organization
FROM teams t
JOIN organizations o USING (organization_id)
WHERE t.name = $1
AND   o.name = $2
FOR UPDATE OF t
;`

type FindTeamByNameForUpdateRow struct {
	TeamID                     pgtype.Text        `json:"team_id"`
	Name                       pgtype.Text        `json:"name"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	OrganizationID             pgtype.Text        `json:"organization_id"`
	PermissionManageWorkspaces bool               `json:"permission_manage_workspaces"`
	Organization               *Organizations     `json:"organization"`
}

// FindTeamByNameForUpdate implements Querier.FindTeamByNameForUpdate.
func (q *DBQuerier) FindTeamByNameForUpdate(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindTeamByNameForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamByNameForUpdate")
	row := q.conn.QueryRow(ctx, findTeamByNameForUpdateSQL, name, organizationName)
	var item FindTeamByNameForUpdateRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, organizationRow); err != nil {
		return item, fmt.Errorf("query FindTeamByNameForUpdate: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByNameForUpdate row: %w", err)
	}
	return item, nil
}

// FindTeamByNameForUpdateBatch implements Querier.FindTeamByNameForUpdateBatch.
func (q *DBQuerier) FindTeamByNameForUpdateBatch(batch genericBatch, name pgtype.Text, organizationName pgtype.Text) {
	batch.Queue(findTeamByNameForUpdateSQL, name, organizationName)
}

// FindTeamByNameForUpdateScan implements Querier.FindTeamByNameForUpdateScan.
func (q *DBQuerier) FindTeamByNameForUpdateScan(results pgx.BatchResults) (FindTeamByNameForUpdateRow, error) {
	row := results.QueryRow()
	var item FindTeamByNameForUpdateRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindTeamByNameForUpdateBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByNameForUpdate row: %w", err)
	}
	return item, nil
}

const updateTeamByNameSQL = `UPDATE teams
SET permission_manage_workspaces = $1
FROM organizations o
WHERE teams.organization_id = o.organization_id
AND   o.name = $2
AND   teams.name = $3
RETURNING team_id;`

type UpdateTeamByNameParams struct {
	PermissionManageWorkspaces bool
	OrganizationName           pgtype.Text
	Name                       pgtype.Text
}

// UpdateTeamByName implements Querier.UpdateTeamByName.
func (q *DBQuerier) UpdateTeamByName(ctx context.Context, params UpdateTeamByNameParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateTeamByName")
	row := q.conn.QueryRow(ctx, updateTeamByNameSQL, params.PermissionManageWorkspaces, params.OrganizationName, params.Name)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateTeamByName: %w", err)
	}
	return item, nil
}

// UpdateTeamByNameBatch implements Querier.UpdateTeamByNameBatch.
func (q *DBQuerier) UpdateTeamByNameBatch(batch genericBatch, params UpdateTeamByNameParams) {
	batch.Queue(updateTeamByNameSQL, params.PermissionManageWorkspaces, params.OrganizationName, params.Name)
}

// UpdateTeamByNameScan implements Querier.UpdateTeamByNameScan.
func (q *DBQuerier) UpdateTeamByNameScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateTeamByNameBatch row: %w", err)
	}
	return item, nil
}

const deleteTeamByNameSQL = `DELETE
FROM teams
USING organizations
WHERE teams.organization_id = organizations.organization_id
AND   teams.name = $1
AND   organizations.name = $2
RETURNING team_id
;`

// DeleteTeamByName implements Querier.DeleteTeamByName.
func (q *DBQuerier) DeleteTeamByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteTeamByName")
	row := q.conn.QueryRow(ctx, deleteTeamByNameSQL, name, organizationName)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteTeamByName: %w", err)
	}
	return item, nil
}

// DeleteTeamByNameBatch implements Querier.DeleteTeamByNameBatch.
func (q *DBQuerier) DeleteTeamByNameBatch(batch genericBatch, name pgtype.Text, organizationName pgtype.Text) {
	batch.Queue(deleteTeamByNameSQL, name, organizationName)
}

// DeleteTeamByNameScan implements Querier.DeleteTeamByNameScan.
func (q *DBQuerier) DeleteTeamByNameScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteTeamByNameBatch row: %w", err)
	}
	return item, nil
}
