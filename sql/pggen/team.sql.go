// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertTeamSQL = `INSERT INTO teams (
    team_id,
    name,
    created_at,
    organization_id
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertTeamParams struct {
	ID             pgtype.Text
	Name           pgtype.Text
	CreatedAt      pgtype.Timestamptz
	OrganizationID pgtype.Text
}

// InsertTeam implements Querier.InsertTeam.
func (q *DBQuerier) InsertTeam(ctx context.Context, params InsertTeamParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertTeam")
	cmdTag, err := q.conn.Exec(ctx, insertTeamSQL, params.ID, params.Name, params.CreatedAt, params.OrganizationID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertTeam: %w", err)
	}
	return cmdTag, err
}

// InsertTeamBatch implements Querier.InsertTeamBatch.
func (q *DBQuerier) InsertTeamBatch(batch genericBatch, params InsertTeamParams) {
	batch.Queue(insertTeamSQL, params.ID, params.Name, params.CreatedAt, params.OrganizationID)
}

// InsertTeamScan implements Querier.InsertTeamScan.
func (q *DBQuerier) InsertTeamScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertTeamBatch: %w", err)
	}
	return cmdTag, err
}

const findTeamsByOrgSQL = `SELECT
    t.*,
    (o.*)::"organizations" AS organization
FROM teams t
JOIN organizations o USING (organization_id)
WHERE o.name = $1
;`

type FindTeamsByOrgRow struct {
	TeamID                     pgtype.Text        `json:"team_id"`
	Name                       pgtype.Text        `json:"name"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	OrganizationID             pgtype.Text        `json:"organization_id"`
	PermissionManageWorkspaces bool               `json:"permission_manage_workspaces"`
	PermissionManageVCS        bool               `json:"permission_manage_vcs"`
	Organization               *Organizations     `json:"organization"`
}

// FindTeamsByOrg implements Querier.FindTeamsByOrg.
func (q *DBQuerier) FindTeamsByOrg(ctx context.Context, organizationName pgtype.Text) ([]FindTeamsByOrgRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamsByOrg")
	rows, err := q.conn.Query(ctx, findTeamsByOrgSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindTeamsByOrg: %w", err)
	}
	defer rows.Close()
	items := []FindTeamsByOrgRow{}
	organizationRow := q.types.newOrganizations()
	for rows.Next() {
		var item FindTeamsByOrgRow
		if err := rows.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, organizationRow); err != nil {
			return nil, fmt.Errorf("scan FindTeamsByOrg row: %w", err)
		}
		if err := organizationRow.AssignTo(&item.Organization); err != nil {
			return nil, fmt.Errorf("assign FindTeamsByOrg row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindTeamsByOrg rows: %w", err)
	}
	return items, err
}

// FindTeamsByOrgBatch implements Querier.FindTeamsByOrgBatch.
func (q *DBQuerier) FindTeamsByOrgBatch(batch genericBatch, organizationName pgtype.Text) {
	batch.Queue(findTeamsByOrgSQL, organizationName)
}

// FindTeamsByOrgScan implements Querier.FindTeamsByOrgScan.
func (q *DBQuerier) FindTeamsByOrgScan(results pgx.BatchResults) ([]FindTeamsByOrgRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindTeamsByOrgBatch: %w", err)
	}
	defer rows.Close()
	items := []FindTeamsByOrgRow{}
	organizationRow := q.types.newOrganizations()
	for rows.Next() {
		var item FindTeamsByOrgRow
		if err := rows.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, organizationRow); err != nil {
			return nil, fmt.Errorf("scan FindTeamsByOrgBatch row: %w", err)
		}
		if err := organizationRow.AssignTo(&item.Organization); err != nil {
			return nil, fmt.Errorf("assign FindTeamsByOrg row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindTeamsByOrgBatch rows: %w", err)
	}
	return items, err
}

const findTeamByNameSQL = `SELECT
    t.*,
    (o.*)::"organizations" AS organization
FROM teams t
JOIN organizations o USING (organization_id)
WHERE t.name = $1
AND   o.name = $2
;`

type FindTeamByNameRow struct {
	TeamID                     pgtype.Text        `json:"team_id"`
	Name                       pgtype.Text        `json:"name"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	OrganizationID             pgtype.Text        `json:"organization_id"`
	PermissionManageWorkspaces bool               `json:"permission_manage_workspaces"`
	PermissionManageVCS        bool               `json:"permission_manage_vcs"`
	Organization               *Organizations     `json:"organization"`
}

// FindTeamByName implements Querier.FindTeamByName.
func (q *DBQuerier) FindTeamByName(ctx context.Context, name pgtype.Text, organizationName pgtype.Text) (FindTeamByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamByName")
	row := q.conn.QueryRow(ctx, findTeamByNameSQL, name, organizationName)
	var item FindTeamByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, organizationRow); err != nil {
		return item, fmt.Errorf("query FindTeamByName: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByName row: %w", err)
	}
	return item, nil
}

// FindTeamByNameBatch implements Querier.FindTeamByNameBatch.
func (q *DBQuerier) FindTeamByNameBatch(batch genericBatch, name pgtype.Text, organizationName pgtype.Text) {
	batch.Queue(findTeamByNameSQL, name, organizationName)
}

// FindTeamByNameScan implements Querier.FindTeamByNameScan.
func (q *DBQuerier) FindTeamByNameScan(results pgx.BatchResults) (FindTeamByNameRow, error) {
	row := results.QueryRow()
	var item FindTeamByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindTeamByNameBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByName row: %w", err)
	}
	return item, nil
}

const findTeamByIDSQL = `SELECT
    t.*,
    (o.*)::"organizations" AS organization
FROM teams t
JOIN organizations o USING (organization_id)
WHERE t.team_id = $1
;`

type FindTeamByIDRow struct {
	TeamID                     pgtype.Text        `json:"team_id"`
	Name                       pgtype.Text        `json:"name"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	OrganizationID             pgtype.Text        `json:"organization_id"`
	PermissionManageWorkspaces bool               `json:"permission_manage_workspaces"`
	PermissionManageVCS        bool               `json:"permission_manage_vcs"`
	Organization               *Organizations     `json:"organization"`
}

// FindTeamByID implements Querier.FindTeamByID.
func (q *DBQuerier) FindTeamByID(ctx context.Context, teamID pgtype.Text) (FindTeamByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamByID")
	row := q.conn.QueryRow(ctx, findTeamByIDSQL, teamID)
	var item FindTeamByIDRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, organizationRow); err != nil {
		return item, fmt.Errorf("query FindTeamByID: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByID row: %w", err)
	}
	return item, nil
}

// FindTeamByIDBatch implements Querier.FindTeamByIDBatch.
func (q *DBQuerier) FindTeamByIDBatch(batch genericBatch, teamID pgtype.Text) {
	batch.Queue(findTeamByIDSQL, teamID)
}

// FindTeamByIDScan implements Querier.FindTeamByIDScan.
func (q *DBQuerier) FindTeamByIDScan(results pgx.BatchResults) (FindTeamByIDRow, error) {
	row := results.QueryRow()
	var item FindTeamByIDRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindTeamByIDBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByID row: %w", err)
	}
	return item, nil
}

const findTeamByIDForUpdateSQL = `SELECT
    t.*,
    (o.*)::"organizations" AS organization
FROM teams t
JOIN organizations o USING (organization_id)
WHERE t.team_id = $1
FOR UPDATE OF t
;`

type FindTeamByIDForUpdateRow struct {
	TeamID                     pgtype.Text        `json:"team_id"`
	Name                       pgtype.Text        `json:"name"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	OrganizationID             pgtype.Text        `json:"organization_id"`
	PermissionManageWorkspaces bool               `json:"permission_manage_workspaces"`
	PermissionManageVCS        bool               `json:"permission_manage_vcs"`
	Organization               *Organizations     `json:"organization"`
}

// FindTeamByIDForUpdate implements Querier.FindTeamByIDForUpdate.
func (q *DBQuerier) FindTeamByIDForUpdate(ctx context.Context, teamID pgtype.Text) (FindTeamByIDForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTeamByIDForUpdate")
	row := q.conn.QueryRow(ctx, findTeamByIDForUpdateSQL, teamID)
	var item FindTeamByIDForUpdateRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, organizationRow); err != nil {
		return item, fmt.Errorf("query FindTeamByIDForUpdate: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByIDForUpdate row: %w", err)
	}
	return item, nil
}

// FindTeamByIDForUpdateBatch implements Querier.FindTeamByIDForUpdateBatch.
func (q *DBQuerier) FindTeamByIDForUpdateBatch(batch genericBatch, teamID pgtype.Text) {
	batch.Queue(findTeamByIDForUpdateSQL, teamID)
}

// FindTeamByIDForUpdateScan implements Querier.FindTeamByIDForUpdateScan.
func (q *DBQuerier) FindTeamByIDForUpdateScan(results pgx.BatchResults) (FindTeamByIDForUpdateRow, error) {
	row := results.QueryRow()
	var item FindTeamByIDForUpdateRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.TeamID, &item.Name, &item.CreatedAt, &item.OrganizationID, &item.PermissionManageWorkspaces, &item.PermissionManageVCS, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindTeamByIDForUpdateBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindTeamByIDForUpdate row: %w", err)
	}
	return item, nil
}

const updateTeamByIDSQL = `UPDATE teams
SET
    permission_manage_workspaces = $1,
    permission_manage_vcs = $2
WHERE team_id = $3
RETURNING team_id;`

type UpdateTeamByIDParams struct {
	PermissionManageWorkspaces bool
	PermissionManageVCS        bool
	TeamID                     pgtype.Text
}

// UpdateTeamByID implements Querier.UpdateTeamByID.
func (q *DBQuerier) UpdateTeamByID(ctx context.Context, params UpdateTeamByIDParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateTeamByID")
	row := q.conn.QueryRow(ctx, updateTeamByIDSQL, params.PermissionManageWorkspaces, params.PermissionManageVCS, params.TeamID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateTeamByID: %w", err)
	}
	return item, nil
}

// UpdateTeamByIDBatch implements Querier.UpdateTeamByIDBatch.
func (q *DBQuerier) UpdateTeamByIDBatch(batch genericBatch, params UpdateTeamByIDParams) {
	batch.Queue(updateTeamByIDSQL, params.PermissionManageWorkspaces, params.PermissionManageVCS, params.TeamID)
}

// UpdateTeamByIDScan implements Querier.UpdateTeamByIDScan.
func (q *DBQuerier) UpdateTeamByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateTeamByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteTeamByIDSQL = `DELETE
FROM teams
WHERE team_id = $1
RETURNING team_id
;`

// DeleteTeamByID implements Querier.DeleteTeamByID.
func (q *DBQuerier) DeleteTeamByID(ctx context.Context, teamID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteTeamByID")
	row := q.conn.QueryRow(ctx, deleteTeamByIDSQL, teamID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteTeamByID: %w", err)
	}
	return item, nil
}

// DeleteTeamByIDBatch implements Querier.DeleteTeamByIDBatch.
func (q *DBQuerier) DeleteTeamByIDBatch(batch genericBatch, teamID pgtype.Text) {
	batch.Queue(deleteTeamByIDSQL, teamID)
}

// DeleteTeamByIDScan implements Querier.DeleteTeamByIDScan.
func (q *DBQuerier) DeleteTeamByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteTeamByIDBatch row: %w", err)
	}
	return item, nil
}
