// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertVCSRepoSQL = `INSERT INTO vcs_repos (
    identifier,
    branch,
    vcs_provider_id,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertVCSRepoParams struct {
	Identifier    pgtype.Text
	Branch        pgtype.Text
	VCSProviderID pgtype.Text
	WorkspaceID   pgtype.Text
}

// InsertVCSRepo implements Querier.InsertVCSRepo.
func (q *DBQuerier) InsertVCSRepo(ctx context.Context, params InsertVCSRepoParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertVCSRepo")
	cmdTag, err := q.conn.Exec(ctx, insertVCSRepoSQL, params.Identifier, params.Branch, params.VCSProviderID, params.WorkspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertVCSRepo: %w", err)
	}
	return cmdTag, err
}

// InsertVCSRepoBatch implements Querier.InsertVCSRepoBatch.
func (q *DBQuerier) InsertVCSRepoBatch(batch genericBatch, params InsertVCSRepoParams) {
	batch.Queue(insertVCSRepoSQL, params.Identifier, params.Branch, params.VCSProviderID, params.WorkspaceID)
}

// InsertVCSRepoScan implements Querier.InsertVCSRepoScan.
func (q *DBQuerier) InsertVCSRepoScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertVCSRepoBatch: %w", err)
	}
	return cmdTag, err
}

const updateVCSRepoSQL = `UPDATE vcs_repos
SET
    identifier = $1,
    branch = $2,
    vcs_provider_id = $3
WHERE workspace_id = $4
RETURNING workspace_id;`

type UpdateVCSRepoParams struct {
	Identifier    pgtype.Text
	Branch        pgtype.Text
	VCSProviderID pgtype.Text
	WorkspaceID   pgtype.Text
}

// UpdateVCSRepo implements Querier.UpdateVCSRepo.
func (q *DBQuerier) UpdateVCSRepo(ctx context.Context, params UpdateVCSRepoParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateVCSRepo")
	row := q.conn.QueryRow(ctx, updateVCSRepoSQL, params.Identifier, params.Branch, params.VCSProviderID, params.WorkspaceID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateVCSRepo: %w", err)
	}
	return item, nil
}

// UpdateVCSRepoBatch implements Querier.UpdateVCSRepoBatch.
func (q *DBQuerier) UpdateVCSRepoBatch(batch genericBatch, params UpdateVCSRepoParams) {
	batch.Queue(updateVCSRepoSQL, params.Identifier, params.Branch, params.VCSProviderID, params.WorkspaceID)
}

// UpdateVCSRepoScan implements Querier.UpdateVCSRepoScan.
func (q *DBQuerier) UpdateVCSRepoScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateVCSRepoBatch row: %w", err)
	}
	return item, nil
}

const deleteVCSRepoSQL = `DELETE
FROM vcs_repos
WHERE workspace_id = $1
RETURNING workspace_id
;`

// DeleteVCSRepo implements Querier.DeleteVCSRepo.
func (q *DBQuerier) DeleteVCSRepo(ctx context.Context, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteVCSRepo")
	cmdTag, err := q.conn.Exec(ctx, deleteVCSRepoSQL, workspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteVCSRepo: %w", err)
	}
	return cmdTag, err
}

// DeleteVCSRepoBatch implements Querier.DeleteVCSRepoBatch.
func (q *DBQuerier) DeleteVCSRepoBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(deleteVCSRepoSQL, workspaceID)
}

// DeleteVCSRepoScan implements Querier.DeleteVCSRepoScan.
func (q *DBQuerier) DeleteVCSRepoScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteVCSRepoBatch: %w", err)
	}
	return cmdTag, err
}
