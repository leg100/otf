// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertVariableSQL = `INSERT INTO variables (
    variable_id,
    key,
    value,
    description,
    category,
    sensitive,
    hcl,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
);`

type InsertVariableParams struct {
	VariableID  pgtype.Text
	Key         pgtype.Text
	Value       pgtype.Text
	Description pgtype.Text
	Category    pgtype.Text
	Sensitive   bool
	HCL         bool
	WorkspaceID pgtype.Text
}

// InsertVariable implements Querier.InsertVariable.
func (q *DBQuerier) InsertVariable(ctx context.Context, params InsertVariableParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertVariable")
	cmdTag, err := q.conn.Exec(ctx, insertVariableSQL, params.VariableID, params.Key, params.Value, params.Description, params.Category, params.Sensitive, params.HCL, params.WorkspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertVariable: %w", err)
	}
	return cmdTag, err
}

// InsertVariableBatch implements Querier.InsertVariableBatch.
func (q *DBQuerier) InsertVariableBatch(batch genericBatch, params InsertVariableParams) {
	batch.Queue(insertVariableSQL, params.VariableID, params.Key, params.Value, params.Description, params.Category, params.Sensitive, params.HCL, params.WorkspaceID)
}

// InsertVariableScan implements Querier.InsertVariableScan.
func (q *DBQuerier) InsertVariableScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertVariableBatch: %w", err)
	}
	return cmdTag, err
}

const findVariablesSQL = `SELECT *
FROM variables
WHERE workspace_id = $1
;`

type FindVariablesRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   bool        `json:"sensitive"`
	HCL         bool        `json:"hcl"`
	WorkspaceID pgtype.Text `json:"workspace_id"`
}

// FindVariables implements Querier.FindVariables.
func (q *DBQuerier) FindVariables(ctx context.Context, workspaceID pgtype.Text) ([]FindVariablesRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindVariables")
	rows, err := q.conn.Query(ctx, findVariablesSQL, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("query FindVariables: %w", err)
	}
	defer rows.Close()
	items := []FindVariablesRow{}
	for rows.Next() {
		var item FindVariablesRow
		if err := rows.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindVariables row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindVariables rows: %w", err)
	}
	return items, err
}

// FindVariablesBatch implements Querier.FindVariablesBatch.
func (q *DBQuerier) FindVariablesBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(findVariablesSQL, workspaceID)
}

// FindVariablesScan implements Querier.FindVariablesScan.
func (q *DBQuerier) FindVariablesScan(results pgx.BatchResults) ([]FindVariablesRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindVariablesBatch: %w", err)
	}
	defer rows.Close()
	items := []FindVariablesRow{}
	for rows.Next() {
		var item FindVariablesRow
		if err := rows.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindVariablesBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindVariablesBatch rows: %w", err)
	}
	return items, err
}

const findVariableSQL = `SELECT *
FROM variables
WHERE variable_id = $1
;`

type FindVariableRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   bool        `json:"sensitive"`
	HCL         bool        `json:"hcl"`
	WorkspaceID pgtype.Text `json:"workspace_id"`
}

// FindVariable implements Querier.FindVariable.
func (q *DBQuerier) FindVariable(ctx context.Context, variableID pgtype.Text) (FindVariableRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindVariable")
	row := q.conn.QueryRow(ctx, findVariableSQL, variableID)
	var item FindVariableRow
	if err := row.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("query FindVariable: %w", err)
	}
	return item, nil
}

// FindVariableBatch implements Querier.FindVariableBatch.
func (q *DBQuerier) FindVariableBatch(batch genericBatch, variableID pgtype.Text) {
	batch.Queue(findVariableSQL, variableID)
}

// FindVariableScan implements Querier.FindVariableScan.
func (q *DBQuerier) FindVariableScan(results pgx.BatchResults) (FindVariableRow, error) {
	row := results.QueryRow()
	var item FindVariableRow
	if err := row.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("scan FindVariableBatch row: %w", err)
	}
	return item, nil
}

const findVariableForUpdateSQL = `SELECT *
FROM variables
WHERE variable_id = $1
FOR UPDATE;`

type FindVariableForUpdateRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   bool        `json:"sensitive"`
	HCL         bool        `json:"hcl"`
	WorkspaceID pgtype.Text `json:"workspace_id"`
}

// FindVariableForUpdate implements Querier.FindVariableForUpdate.
func (q *DBQuerier) FindVariableForUpdate(ctx context.Context, variableID pgtype.Text) (FindVariableForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindVariableForUpdate")
	row := q.conn.QueryRow(ctx, findVariableForUpdateSQL, variableID)
	var item FindVariableForUpdateRow
	if err := row.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("query FindVariableForUpdate: %w", err)
	}
	return item, nil
}

// FindVariableForUpdateBatch implements Querier.FindVariableForUpdateBatch.
func (q *DBQuerier) FindVariableForUpdateBatch(batch genericBatch, variableID pgtype.Text) {
	batch.Queue(findVariableForUpdateSQL, variableID)
}

// FindVariableForUpdateScan implements Querier.FindVariableForUpdateScan.
func (q *DBQuerier) FindVariableForUpdateScan(results pgx.BatchResults) (FindVariableForUpdateRow, error) {
	row := results.QueryRow()
	var item FindVariableForUpdateRow
	if err := row.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("scan FindVariableForUpdateBatch row: %w", err)
	}
	return item, nil
}

const updateVariableSQL = `UPDATE variables
SET
    key = $1,
    value = $2,
    description = $3,
    category = $4,
    sensitive = $5,
    hcl = $6
WHERE variable_id = $7
RETURNING variable_id
;`

type UpdateVariableParams struct {
	Key         pgtype.Text
	Value       pgtype.Text
	Description pgtype.Text
	Category    pgtype.Text
	Sensitive   bool
	HCL         bool
	VariableID  pgtype.Text
}

// UpdateVariable implements Querier.UpdateVariable.
func (q *DBQuerier) UpdateVariable(ctx context.Context, params UpdateVariableParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateVariable")
	row := q.conn.QueryRow(ctx, updateVariableSQL, params.Key, params.Value, params.Description, params.Category, params.Sensitive, params.HCL, params.VariableID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateVariable: %w", err)
	}
	return item, nil
}

// UpdateVariableBatch implements Querier.UpdateVariableBatch.
func (q *DBQuerier) UpdateVariableBatch(batch genericBatch, params UpdateVariableParams) {
	batch.Queue(updateVariableSQL, params.Key, params.Value, params.Description, params.Category, params.Sensitive, params.HCL, params.VariableID)
}

// UpdateVariableScan implements Querier.UpdateVariableScan.
func (q *DBQuerier) UpdateVariableScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateVariableBatch row: %w", err)
	}
	return item, nil
}

const deleteVariableSQL = `DELETE
FROM variables
WHERE variable_id = $1
RETURNING *
;`

type DeleteVariableRow struct {
	VariableID  pgtype.Text `json:"variable_id"`
	Key         pgtype.Text `json:"key"`
	Value       pgtype.Text `json:"value"`
	Description pgtype.Text `json:"description"`
	Category    pgtype.Text `json:"category"`
	Sensitive   bool        `json:"sensitive"`
	HCL         bool        `json:"hcl"`
	WorkspaceID pgtype.Text `json:"workspace_id"`
}

// DeleteVariable implements Querier.DeleteVariable.
func (q *DBQuerier) DeleteVariable(ctx context.Context, variableID pgtype.Text) (DeleteVariableRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteVariable")
	row := q.conn.QueryRow(ctx, deleteVariableSQL, variableID)
	var item DeleteVariableRow
	if err := row.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("query DeleteVariable: %w", err)
	}
	return item, nil
}

// DeleteVariableBatch implements Querier.DeleteVariableBatch.
func (q *DBQuerier) DeleteVariableBatch(batch genericBatch, variableID pgtype.Text) {
	batch.Queue(deleteVariableSQL, variableID)
}

// DeleteVariableScan implements Querier.DeleteVariableScan.
func (q *DBQuerier) DeleteVariableScan(results pgx.BatchResults) (DeleteVariableRow, error) {
	row := results.QueryRow()
	var item DeleteVariableRow
	if err := row.Scan(&item.VariableID, &item.Key, &item.Value, &item.Description, &item.Category, &item.Sensitive, &item.HCL, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("scan DeleteVariableBatch row: %w", err)
	}
	return item, nil
}
