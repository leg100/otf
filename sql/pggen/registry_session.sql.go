// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertRegistrySessionSQL = `INSERT INTO registry_sessions (
    token,
    expiry,
    organization_name
) VALUES (
    $1,
    $2,
    $3
);`

type InsertRegistrySessionParams struct {
	Token            pgtype.Text
	Expiry           pgtype.Timestamptz
	OrganizationName pgtype.Text
}

// InsertRegistrySession implements Querier.InsertRegistrySession.
func (q *DBQuerier) InsertRegistrySession(ctx context.Context, params InsertRegistrySessionParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertRegistrySession")
	cmdTag, err := q.conn.Exec(ctx, insertRegistrySessionSQL, params.Token, params.Expiry, params.OrganizationName)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertRegistrySession: %w", err)
	}
	return cmdTag, err
}

// InsertRegistrySessionBatch implements Querier.InsertRegistrySessionBatch.
func (q *DBQuerier) InsertRegistrySessionBatch(batch genericBatch, params InsertRegistrySessionParams) {
	batch.Queue(insertRegistrySessionSQL, params.Token, params.Expiry, params.OrganizationName)
}

// InsertRegistrySessionScan implements Querier.InsertRegistrySessionScan.
func (q *DBQuerier) InsertRegistrySessionScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertRegistrySessionBatch: %w", err)
	}
	return cmdTag, err
}

const findRegistrySessionSQL = `SELECT *
FROM registry_sessions
WHERE token = $1
AND   expiry > current_timestamp
;`

type FindRegistrySessionRow struct {
	Token            pgtype.Text        `json:"token"`
	Expiry           pgtype.Timestamptz `json:"expiry"`
	OrganizationName pgtype.Text        `json:"organization_name"`
}

// FindRegistrySession implements Querier.FindRegistrySession.
func (q *DBQuerier) FindRegistrySession(ctx context.Context, token pgtype.Text) (FindRegistrySessionRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRegistrySession")
	row := q.conn.QueryRow(ctx, findRegistrySessionSQL, token)
	var item FindRegistrySessionRow
	if err := row.Scan(&item.Token, &item.Expiry, &item.OrganizationName); err != nil {
		return item, fmt.Errorf("query FindRegistrySession: %w", err)
	}
	return item, nil
}

// FindRegistrySessionBatch implements Querier.FindRegistrySessionBatch.
func (q *DBQuerier) FindRegistrySessionBatch(batch genericBatch, token pgtype.Text) {
	batch.Queue(findRegistrySessionSQL, token)
}

// FindRegistrySessionScan implements Querier.FindRegistrySessionScan.
func (q *DBQuerier) FindRegistrySessionScan(results pgx.BatchResults) (FindRegistrySessionRow, error) {
	row := results.QueryRow()
	var item FindRegistrySessionRow
	if err := row.Scan(&item.Token, &item.Expiry, &item.OrganizationName); err != nil {
		return item, fmt.Errorf("scan FindRegistrySessionBatch row: %w", err)
	}
	return item, nil
}

const deleteExpiredRegistrySessionsSQL = `DELETE
FROM sessions
WHERE expiry < current_timestamp
RETURNING token
;`

// DeleteExpiredRegistrySessions implements Querier.DeleteExpiredRegistrySessions.
func (q *DBQuerier) DeleteExpiredRegistrySessions(ctx context.Context) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteExpiredRegistrySessions")
	row := q.conn.QueryRow(ctx, deleteExpiredRegistrySessionsSQL)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteExpiredRegistrySessions: %w", err)
	}
	return item, nil
}

// DeleteExpiredRegistrySessionsBatch implements Querier.DeleteExpiredRegistrySessionsBatch.
func (q *DBQuerier) DeleteExpiredRegistrySessionsBatch(batch genericBatch) {
	batch.Queue(deleteExpiredRegistrySessionsSQL)
}

// DeleteExpiredRegistrySessionsScan implements Querier.DeleteExpiredRegistrySessionsScan.
func (q *DBQuerier) DeleteExpiredRegistrySessionsScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteExpiredRegistrySessionsBatch row: %w", err)
	}
	return item, nil
}
