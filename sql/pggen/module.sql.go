// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertModuleSQL = `INSERT INTO modules (
    module_id,
    created_at,
    updated_at,
    name,
    provider,
    organization_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
);`

type InsertModuleParams struct {
	ID             pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Name           pgtype.Text
	Provider       pgtype.Text
	OrganizationID pgtype.Text
}

// InsertModule implements Querier.InsertModule.
func (q *DBQuerier) InsertModule(ctx context.Context, params InsertModuleParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertModule")
	cmdTag, err := q.conn.Exec(ctx, insertModuleSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.Name, params.Provider, params.OrganizationID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertModule: %w", err)
	}
	return cmdTag, err
}

// InsertModuleBatch implements Querier.InsertModuleBatch.
func (q *DBQuerier) InsertModuleBatch(batch genericBatch, params InsertModuleParams) {
	batch.Queue(insertModuleSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.Name, params.Provider, params.OrganizationID)
}

// InsertModuleScan implements Querier.InsertModuleScan.
func (q *DBQuerier) InsertModuleScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertModuleBatch: %w", err)
	}
	return cmdTag, err
}

const insertModuleVersionSQL = `INSERT INTO module_versions (
    version,
    created_at,
    updated_at,
    module_id
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING *;`

type InsertModuleVersionParams struct {
	Version   pgtype.Text
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	ModuleID  pgtype.Text
}

type InsertModuleVersionRow struct {
	Version   pgtype.Text        `json:"version"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Tarball   []byte             `json:"tarball"`
	ModuleID  pgtype.Text        `json:"module_id"`
}

// InsertModuleVersion implements Querier.InsertModuleVersion.
func (q *DBQuerier) InsertModuleVersion(ctx context.Context, params InsertModuleVersionParams) (InsertModuleVersionRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertModuleVersion")
	row := q.conn.QueryRow(ctx, insertModuleVersionSQL, params.Version, params.CreatedAt, params.UpdatedAt, params.ModuleID)
	var item InsertModuleVersionRow
	if err := row.Scan(&item.Version, &item.CreatedAt, &item.UpdatedAt, &item.Tarball, &item.ModuleID); err != nil {
		return item, fmt.Errorf("query InsertModuleVersion: %w", err)
	}
	return item, nil
}

// InsertModuleVersionBatch implements Querier.InsertModuleVersionBatch.
func (q *DBQuerier) InsertModuleVersionBatch(batch genericBatch, params InsertModuleVersionParams) {
	batch.Queue(insertModuleVersionSQL, params.Version, params.CreatedAt, params.UpdatedAt, params.ModuleID)
}

// InsertModuleVersionScan implements Querier.InsertModuleVersionScan.
func (q *DBQuerier) InsertModuleVersionScan(results pgx.BatchResults) (InsertModuleVersionRow, error) {
	row := results.QueryRow()
	var item InsertModuleVersionRow
	if err := row.Scan(&item.Version, &item.CreatedAt, &item.UpdatedAt, &item.Tarball, &item.ModuleID); err != nil {
		return item, fmt.Errorf("scan InsertModuleVersionBatch row: %w", err)
	}
	return item, nil
}

const listModulesByOrganizationSQL = `SELECT
    m.module_id,
    m.created_at,
    m.updated_at,
    m.name,
    m.provider,
    (o.*)::"organizations" AS organization
FROM modules m
JOIN organizations o USING (organization_id)
WHERE o.name = $1
;`

type ListModulesByOrganizationRow struct {
	ModuleID     pgtype.Text        `json:"module_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	Name         pgtype.Text        `json:"name"`
	Provider     pgtype.Text        `json:"provider"`
	Organization *Organizations     `json:"organization"`
}

// ListModulesByOrganization implements Querier.ListModulesByOrganization.
func (q *DBQuerier) ListModulesByOrganization(ctx context.Context, organizationName pgtype.Text) ([]ListModulesByOrganizationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListModulesByOrganization")
	rows, err := q.conn.Query(ctx, listModulesByOrganizationSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query ListModulesByOrganization: %w", err)
	}
	defer rows.Close()
	items := []ListModulesByOrganizationRow{}
	organizationRow := q.types.newOrganizations()
	for rows.Next() {
		var item ListModulesByOrganizationRow
		if err := rows.Scan(&item.ModuleID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.Provider, organizationRow); err != nil {
			return nil, fmt.Errorf("scan ListModulesByOrganization row: %w", err)
		}
		if err := organizationRow.AssignTo(&item.Organization); err != nil {
			return nil, fmt.Errorf("assign ListModulesByOrganization row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListModulesByOrganization rows: %w", err)
	}
	return items, err
}

// ListModulesByOrganizationBatch implements Querier.ListModulesByOrganizationBatch.
func (q *DBQuerier) ListModulesByOrganizationBatch(batch genericBatch, organizationName pgtype.Text) {
	batch.Queue(listModulesByOrganizationSQL, organizationName)
}

// ListModulesByOrganizationScan implements Querier.ListModulesByOrganizationScan.
func (q *DBQuerier) ListModulesByOrganizationScan(results pgx.BatchResults) ([]ListModulesByOrganizationRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query ListModulesByOrganizationBatch: %w", err)
	}
	defer rows.Close()
	items := []ListModulesByOrganizationRow{}
	organizationRow := q.types.newOrganizations()
	for rows.Next() {
		var item ListModulesByOrganizationRow
		if err := rows.Scan(&item.ModuleID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.Provider, organizationRow); err != nil {
			return nil, fmt.Errorf("scan ListModulesByOrganizationBatch row: %w", err)
		}
		if err := organizationRow.AssignTo(&item.Organization); err != nil {
			return nil, fmt.Errorf("assign ListModulesByOrganization row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListModulesByOrganizationBatch rows: %w", err)
	}
	return items, err
}

const findModuleByNameSQL = `SELECT
    m.module_id,
    m.created_at,
    m.updated_at,
    m.name,
    m.provider,
    (o.*)::"organizations" AS organization
FROM modules m
JOIN organizations o USING (organization_id)
WHERE o.name = $1
AND   m.name = $2
AND   m.provider = $3
;`

type FindModuleByNameParams struct {
	OrganizatonName pgtype.Text
	Name            pgtype.Text
	Provider        pgtype.Text
}

type FindModuleByNameRow struct {
	ModuleID     pgtype.Text        `json:"module_id"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	Name         pgtype.Text        `json:"name"`
	Provider     pgtype.Text        `json:"provider"`
	Organization *Organizations     `json:"organization"`
}

// FindModuleByName implements Querier.FindModuleByName.
func (q *DBQuerier) FindModuleByName(ctx context.Context, params FindModuleByNameParams) (FindModuleByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindModuleByName")
	row := q.conn.QueryRow(ctx, findModuleByNameSQL, params.OrganizatonName, params.Name, params.Provider)
	var item FindModuleByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.ModuleID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.Provider, organizationRow); err != nil {
		return item, fmt.Errorf("query FindModuleByName: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindModuleByName row: %w", err)
	}
	return item, nil
}

// FindModuleByNameBatch implements Querier.FindModuleByNameBatch.
func (q *DBQuerier) FindModuleByNameBatch(batch genericBatch, params FindModuleByNameParams) {
	batch.Queue(findModuleByNameSQL, params.OrganizatonName, params.Name, params.Provider)
}

// FindModuleByNameScan implements Querier.FindModuleByNameScan.
func (q *DBQuerier) FindModuleByNameScan(results pgx.BatchResults) (FindModuleByNameRow, error) {
	row := results.QueryRow()
	var item FindModuleByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.ModuleID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.Provider, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindModuleByNameBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindModuleByName row: %w", err)
	}
	return item, nil
}

const uploadModuleVersionSQL = `UPDATE module_versions
SET
    tarball = $1,
    updated_at = $2
WHERE module_id = $3
AND   version = $4
RETURNING version;`

type UploadModuleVersionParams struct {
	Tarball   []byte
	UpdatedAt pgtype.Timestamptz
	ModuleID  pgtype.Text
	Version   pgtype.Text
}

// UploadModuleVersion implements Querier.UploadModuleVersion.
func (q *DBQuerier) UploadModuleVersion(ctx context.Context, params UploadModuleVersionParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UploadModuleVersion")
	row := q.conn.QueryRow(ctx, uploadModuleVersionSQL, params.Tarball, params.UpdatedAt, params.ModuleID, params.Version)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UploadModuleVersion: %w", err)
	}
	return item, nil
}

// UploadModuleVersionBatch implements Querier.UploadModuleVersionBatch.
func (q *DBQuerier) UploadModuleVersionBatch(batch genericBatch, params UploadModuleVersionParams) {
	batch.Queue(uploadModuleVersionSQL, params.Tarball, params.UpdatedAt, params.ModuleID, params.Version)
}

// UploadModuleVersionScan implements Querier.UploadModuleVersionScan.
func (q *DBQuerier) UploadModuleVersionScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UploadModuleVersionBatch row: %w", err)
	}
	return item, nil
}

const downloadModuleVersionSQL = `SELECT tarball
FROM module_versions
WHERE module_id = $1
AND   version = $2
;`

// DownloadModuleVersion implements Querier.DownloadModuleVersion.
func (q *DBQuerier) DownloadModuleVersion(ctx context.Context, moduleID pgtype.Text, version pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DownloadModuleVersion")
	row := q.conn.QueryRow(ctx, downloadModuleVersionSQL, moduleID, version)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DownloadModuleVersion: %w", err)
	}
	return item, nil
}

// DownloadModuleVersionBatch implements Querier.DownloadModuleVersionBatch.
func (q *DBQuerier) DownloadModuleVersionBatch(batch genericBatch, moduleID pgtype.Text, version pgtype.Text) {
	batch.Queue(downloadModuleVersionSQL, moduleID, version)
}

// DownloadModuleVersionScan implements Querier.DownloadModuleVersionScan.
func (q *DBQuerier) DownloadModuleVersionScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DownloadModuleVersionBatch row: %w", err)
	}
	return item, nil
}

const deleteModuleByIDSQL = `DELETE
FROM modules
WHERE module_id = $1
RETURNING module_id;`

// DeleteModuleByID implements Querier.DeleteModuleByID.
func (q *DBQuerier) DeleteModuleByID(ctx context.Context, id pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteModuleByID")
	row := q.conn.QueryRow(ctx, deleteModuleByIDSQL, id)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteModuleByID: %w", err)
	}
	return item, nil
}

// DeleteModuleByIDBatch implements Querier.DeleteModuleByIDBatch.
func (q *DBQuerier) DeleteModuleByIDBatch(batch genericBatch, id pgtype.Text) {
	batch.Queue(deleteModuleByIDSQL, id)
}

// DeleteModuleByIDScan implements Querier.DeleteModuleByIDScan.
func (q *DBQuerier) DeleteModuleByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteModuleByIDBatch row: %w", err)
	}
	return item, nil
}
