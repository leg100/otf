// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertPlanSQL = `INSERT INTO plans (
    plan_id,
    job_id
) VALUES (
    $1,
    $2
);`

// InsertPlan implements Querier.InsertPlan.
func (q *DBQuerier) InsertPlan(ctx context.Context, planID pgtype.Text, jobID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPlan")
	cmdTag, err := q.conn.Exec(ctx, insertPlanSQL, planID, jobID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertPlan: %w", err)
	}
	return cmdTag, err
}

// InsertPlanBatch implements Querier.InsertPlanBatch.
func (q *DBQuerier) InsertPlanBatch(batch genericBatch, planID pgtype.Text, jobID pgtype.Text) {
	batch.Queue(insertPlanSQL, planID, jobID)
}

// InsertPlanScan implements Querier.InsertPlanScan.
func (q *DBQuerier) InsertPlanScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertPlanBatch: %w", err)
	}
	return cmdTag, err
}

const updatePlannedChangesByIDSQL = `UPDATE plans
SET report = (
    $1,
    $2,
    $3
)
WHERE plan_id = $4
RETURNING plan_id
;`

type UpdatePlannedChangesByIDParams struct {
	Additions    int
	Changes      int
	Destructions int
	PlanID       pgtype.Text
}

// UpdatePlannedChangesByID implements Querier.UpdatePlannedChangesByID.
func (q *DBQuerier) UpdatePlannedChangesByID(ctx context.Context, params UpdatePlannedChangesByIDParams) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlannedChangesByID")
	row := q.conn.QueryRow(ctx, updatePlannedChangesByIDSQL, params.Additions, params.Changes, params.Destructions, params.PlanID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdatePlannedChangesByID: %w", err)
	}
	return item, nil
}

// UpdatePlannedChangesByIDBatch implements Querier.UpdatePlannedChangesByIDBatch.
func (q *DBQuerier) UpdatePlannedChangesByIDBatch(batch genericBatch, params UpdatePlannedChangesByIDParams) {
	batch.Queue(updatePlannedChangesByIDSQL, params.Additions, params.Changes, params.Destructions, params.PlanID)
}

// UpdatePlannedChangesByIDScan implements Querier.UpdatePlannedChangesByIDScan.
func (q *DBQuerier) UpdatePlannedChangesByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdatePlannedChangesByIDBatch row: %w", err)
	}
	return item, nil
}

const findRunIDByPlanIDSQL = `SELECT jobs.run_id
FROM plans
JOIN jobs USING(job_id)
WHERE plans.plan_id = $1
;`

// FindRunIDByPlanID implements Querier.FindRunIDByPlanID.
func (q *DBQuerier) FindRunIDByPlanID(ctx context.Context, planID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunIDByPlanID")
	row := q.conn.QueryRow(ctx, findRunIDByPlanIDSQL, planID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindRunIDByPlanID: %w", err)
	}
	return item, nil
}

// FindRunIDByPlanIDBatch implements Querier.FindRunIDByPlanIDBatch.
func (q *DBQuerier) FindRunIDByPlanIDBatch(batch genericBatch, planID pgtype.Text) {
	batch.Queue(findRunIDByPlanIDSQL, planID)
}

// FindRunIDByPlanIDScan implements Querier.FindRunIDByPlanIDScan.
func (q *DBQuerier) FindRunIDByPlanIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindRunIDByPlanIDBatch row: %w", err)
	}
	return item, nil
}

const getPlanBinByIDSQL = `SELECT plan_bin
FROM plans
WHERE plan_id = $1
;`

// GetPlanBinByID implements Querier.GetPlanBinByID.
func (q *DBQuerier) GetPlanBinByID(ctx context.Context, planID pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetPlanBinByID")
	row := q.conn.QueryRow(ctx, getPlanBinByIDSQL, planID)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query GetPlanBinByID: %w", err)
	}
	return item, nil
}

// GetPlanBinByIDBatch implements Querier.GetPlanBinByIDBatch.
func (q *DBQuerier) GetPlanBinByIDBatch(batch genericBatch, planID pgtype.Text) {
	batch.Queue(getPlanBinByIDSQL, planID)
}

// GetPlanBinByIDScan implements Querier.GetPlanBinByIDScan.
func (q *DBQuerier) GetPlanBinByIDScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan GetPlanBinByIDBatch row: %w", err)
	}
	return item, nil
}

const getPlanJSONByIDSQL = `SELECT plan_json
FROM plans
WHERE plan_id = $1
;`

// GetPlanJSONByID implements Querier.GetPlanJSONByID.
func (q *DBQuerier) GetPlanJSONByID(ctx context.Context, planID pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetPlanJSONByID")
	row := q.conn.QueryRow(ctx, getPlanJSONByIDSQL, planID)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query GetPlanJSONByID: %w", err)
	}
	return item, nil
}

// GetPlanJSONByIDBatch implements Querier.GetPlanJSONByIDBatch.
func (q *DBQuerier) GetPlanJSONByIDBatch(batch genericBatch, planID pgtype.Text) {
	batch.Queue(getPlanJSONByIDSQL, planID)
}

// GetPlanJSONByIDScan implements Querier.GetPlanJSONByIDScan.
func (q *DBQuerier) GetPlanJSONByIDScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan GetPlanJSONByIDBatch row: %w", err)
	}
	return item, nil
}

const updatePlanBinByIDSQL = `UPDATE plans
SET plan_bin = $1
WHERE plan_id = $2
RETURNING plan_id
;`

// UpdatePlanBinByID implements Querier.UpdatePlanBinByID.
func (q *DBQuerier) UpdatePlanBinByID(ctx context.Context, planBin []byte, planID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlanBinByID")
	row := q.conn.QueryRow(ctx, updatePlanBinByIDSQL, planBin, planID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdatePlanBinByID: %w", err)
	}
	return item, nil
}

// UpdatePlanBinByIDBatch implements Querier.UpdatePlanBinByIDBatch.
func (q *DBQuerier) UpdatePlanBinByIDBatch(batch genericBatch, planBin []byte, planID pgtype.Text) {
	batch.Queue(updatePlanBinByIDSQL, planBin, planID)
}

// UpdatePlanBinByIDScan implements Querier.UpdatePlanBinByIDScan.
func (q *DBQuerier) UpdatePlanBinByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdatePlanBinByIDBatch row: %w", err)
	}
	return item, nil
}

const updatePlanJSONByIDSQL = `UPDATE plans
SET plan_json = $1
WHERE plan_id = $2
RETURNING plan_id
;`

// UpdatePlanJSONByID implements Querier.UpdatePlanJSONByID.
func (q *DBQuerier) UpdatePlanJSONByID(ctx context.Context, planJSON []byte, planID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdatePlanJSONByID")
	row := q.conn.QueryRow(ctx, updatePlanJSONByIDSQL, planJSON, planID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdatePlanJSONByID: %w", err)
	}
	return item, nil
}

// UpdatePlanJSONByIDBatch implements Querier.UpdatePlanJSONByIDBatch.
func (q *DBQuerier) UpdatePlanJSONByIDBatch(batch genericBatch, planJSON []byte, planID pgtype.Text) {
	batch.Queue(updatePlanJSONByIDSQL, planJSON, planID)
}

// UpdatePlanJSONByIDScan implements Querier.UpdatePlanJSONByIDScan.
func (q *DBQuerier) UpdatePlanJSONByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdatePlanJSONByIDBatch row: %w", err)
	}
	return item, nil
}
