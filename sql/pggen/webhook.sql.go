// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertWebhookSQL = `INSERT INTO webhooks (
    webhook_id,
    vcs_id,
    secret,
    identifier,
    http_url
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
);`

type InsertWebhookParams struct {
	WebhookID  pgtype.UUID
	VCSID      pgtype.Text
	Secret     pgtype.Text
	Identifier pgtype.Text
	HTTPURL    pgtype.Text
}

// InsertWebhook implements Querier.InsertWebhook.
func (q *DBQuerier) InsertWebhook(ctx context.Context, params InsertWebhookParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWebhook")
	cmdTag, err := q.conn.Exec(ctx, insertWebhookSQL, params.WebhookID, params.VCSID, params.Secret, params.Identifier, params.HTTPURL)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertWebhook: %w", err)
	}
	return cmdTag, err
}

// InsertWebhookBatch implements Querier.InsertWebhookBatch.
func (q *DBQuerier) InsertWebhookBatch(batch genericBatch, params InsertWebhookParams) {
	batch.Queue(insertWebhookSQL, params.WebhookID, params.VCSID, params.Secret, params.Identifier, params.HTTPURL)
}

// InsertWebhookScan implements Querier.InsertWebhookScan.
func (q *DBQuerier) InsertWebhookScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertWebhookBatch: %w", err)
	}
	return cmdTag, err
}

const updateWebhookVCSIDSQL = `UPDATE webhooks
SET vcs_id = $1
WHERE webhook_id = $2;`

// UpdateWebhookVCSID implements Querier.UpdateWebhookVCSID.
func (q *DBQuerier) UpdateWebhookVCSID(ctx context.Context, vcsID pgtype.Text, webhookID pgtype.UUID) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWebhookVCSID")
	cmdTag, err := q.conn.Exec(ctx, updateWebhookVCSIDSQL, vcsID, webhookID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query UpdateWebhookVCSID: %w", err)
	}
	return cmdTag, err
}

// UpdateWebhookVCSIDBatch implements Querier.UpdateWebhookVCSIDBatch.
func (q *DBQuerier) UpdateWebhookVCSIDBatch(batch genericBatch, vcsID pgtype.Text, webhookID pgtype.UUID) {
	batch.Queue(updateWebhookVCSIDSQL, vcsID, webhookID)
}

// UpdateWebhookVCSIDScan implements Querier.UpdateWebhookVCSIDScan.
func (q *DBQuerier) UpdateWebhookVCSIDScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec UpdateWebhookVCSIDBatch: %w", err)
	}
	return cmdTag, err
}

const findWebhookSecretSQL = `SELECT secret
FROM webhooks
WHERE webhook_id = $1;`

// FindWebhookSecret implements Querier.FindWebhookSecret.
func (q *DBQuerier) FindWebhookSecret(ctx context.Context, webhookID pgtype.UUID) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWebhookSecret")
	row := q.conn.QueryRow(ctx, findWebhookSecretSQL, webhookID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindWebhookSecret: %w", err)
	}
	return item, nil
}

// FindWebhookSecretBatch implements Querier.FindWebhookSecretBatch.
func (q *DBQuerier) FindWebhookSecretBatch(batch genericBatch, webhookID pgtype.UUID) {
	batch.Queue(findWebhookSecretSQL, webhookID)
}

// FindWebhookSecretScan implements Querier.FindWebhookSecretScan.
func (q *DBQuerier) FindWebhookSecretScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindWebhookSecretBatch row: %w", err)
	}
	return item, nil
}

const findWebhookByURLSQL = `SELECT *
FROM webhooks
WHERE http_url = $1;`

type FindWebhookByURLRow struct {
	WebhookID  pgtype.UUID `json:"webhook_id"`
	VCSID      pgtype.Text `json:"vcs_id"`
	Secret     pgtype.Text `json:"secret"`
	Identifier pgtype.Text `json:"identifier"`
	HTTPURL    pgtype.Text `json:"http_url"`
}

// FindWebhookByURL implements Querier.FindWebhookByURL.
func (q *DBQuerier) FindWebhookByURL(ctx context.Context, httpURL pgtype.Text) (FindWebhookByURLRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWebhookByURL")
	row := q.conn.QueryRow(ctx, findWebhookByURLSQL, httpURL)
	var item FindWebhookByURLRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.HTTPURL); err != nil {
		return item, fmt.Errorf("query FindWebhookByURL: %w", err)
	}
	return item, nil
}

// FindWebhookByURLBatch implements Querier.FindWebhookByURLBatch.
func (q *DBQuerier) FindWebhookByURLBatch(batch genericBatch, httpURL pgtype.Text) {
	batch.Queue(findWebhookByURLSQL, httpURL)
}

// FindWebhookByURLScan implements Querier.FindWebhookByURLScan.
func (q *DBQuerier) FindWebhookByURLScan(results pgx.BatchResults) (FindWebhookByURLRow, error) {
	row := results.QueryRow()
	var item FindWebhookByURLRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.HTTPURL); err != nil {
		return item, fmt.Errorf("scan FindWebhookByURLBatch row: %w", err)
	}
	return item, nil
}

const deleteWebhookSQL = `DELETE
FROM webhooks
WHERE webhook_id = $1;`

// DeleteWebhook implements Querier.DeleteWebhook.
func (q *DBQuerier) DeleteWebhook(ctx context.Context, webhookID pgtype.UUID) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWebhook")
	cmdTag, err := q.conn.Exec(ctx, deleteWebhookSQL, webhookID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteWebhook: %w", err)
	}
	return cmdTag, err
}

// DeleteWebhookBatch implements Querier.DeleteWebhookBatch.
func (q *DBQuerier) DeleteWebhookBatch(batch genericBatch, webhookID pgtype.UUID) {
	batch.Queue(deleteWebhookSQL, webhookID)
}

// DeleteWebhookScan implements Querier.DeleteWebhookScan.
func (q *DBQuerier) DeleteWebhookScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteWebhookBatch: %w", err)
	}
	return cmdTag, err
}
