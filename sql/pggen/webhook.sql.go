// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const upsertWebhookSQL = `INSERT INTO webhooks (
    webhook_id,
    secret,
    identifier,
    cloud,
    connected
) VALUES (
    $1,
    $2,
    $3,
    $4,
    1
) ON CONFLICT (identifier, cloud) DO
    UPDATE
    SET connected = webhooks.connected + 1
RETURNING *
;`

type UpsertWebhookParams struct {
	WebhookID  pgtype.UUID
	Secret     pgtype.Text
	Identifier pgtype.Text
	Cloud      pgtype.Text
}

type UpsertWebhookRow struct {
	WebhookID  pgtype.UUID `json:"webhook_id"`
	VCSID      pgtype.Text `json:"vcs_id"`
	Secret     pgtype.Text `json:"secret"`
	Identifier pgtype.Text `json:"identifier"`
	Cloud      pgtype.Text `json:"cloud"`
	Connected  int         `json:"connected"`
}

// UpsertWebhook implements Querier.UpsertWebhook.
func (q *DBQuerier) UpsertWebhook(ctx context.Context, params UpsertWebhookParams) (UpsertWebhookRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpsertWebhook")
	row := q.conn.QueryRow(ctx, upsertWebhookSQL, params.WebhookID, params.Secret, params.Identifier, params.Cloud)
	var item UpsertWebhookRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("query UpsertWebhook: %w", err)
	}
	return item, nil
}

// UpsertWebhookBatch implements Querier.UpsertWebhookBatch.
func (q *DBQuerier) UpsertWebhookBatch(batch genericBatch, params UpsertWebhookParams) {
	batch.Queue(upsertWebhookSQL, params.WebhookID, params.Secret, params.Identifier, params.Cloud)
}

// UpsertWebhookScan implements Querier.UpsertWebhookScan.
func (q *DBQuerier) UpsertWebhookScan(results pgx.BatchResults) (UpsertWebhookRow, error) {
	row := results.QueryRow()
	var item UpsertWebhookRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("scan UpsertWebhookBatch row: %w", err)
	}
	return item, nil
}

const updateWebhookVCSIDSQL = `UPDATE webhooks
SET vcs_id = $1
WHERE webhook_id = $2
RETURNING *
;`

type UpdateWebhookVCSIDRow struct {
	WebhookID  pgtype.UUID `json:"webhook_id"`
	VCSID      pgtype.Text `json:"vcs_id"`
	Secret     pgtype.Text `json:"secret"`
	Identifier pgtype.Text `json:"identifier"`
	Cloud      pgtype.Text `json:"cloud"`
	Connected  int         `json:"connected"`
}

// UpdateWebhookVCSID implements Querier.UpdateWebhookVCSID.
func (q *DBQuerier) UpdateWebhookVCSID(ctx context.Context, vcsID pgtype.Text, webhookID pgtype.UUID) (UpdateWebhookVCSIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWebhookVCSID")
	row := q.conn.QueryRow(ctx, updateWebhookVCSIDSQL, vcsID, webhookID)
	var item UpdateWebhookVCSIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("query UpdateWebhookVCSID: %w", err)
	}
	return item, nil
}

// UpdateWebhookVCSIDBatch implements Querier.UpdateWebhookVCSIDBatch.
func (q *DBQuerier) UpdateWebhookVCSIDBatch(batch genericBatch, vcsID pgtype.Text, webhookID pgtype.UUID) {
	batch.Queue(updateWebhookVCSIDSQL, vcsID, webhookID)
}

// UpdateWebhookVCSIDScan implements Querier.UpdateWebhookVCSIDScan.
func (q *DBQuerier) UpdateWebhookVCSIDScan(results pgx.BatchResults) (UpdateWebhookVCSIDRow, error) {
	row := results.QueryRow()
	var item UpdateWebhookVCSIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("scan UpdateWebhookVCSIDBatch row: %w", err)
	}
	return item, nil
}

const findWebhookByIDSQL = `SELECT *
FROM webhooks
WHERE webhook_id = $1;`

type FindWebhookByIDRow struct {
	WebhookID  pgtype.UUID `json:"webhook_id"`
	VCSID      pgtype.Text `json:"vcs_id"`
	Secret     pgtype.Text `json:"secret"`
	Identifier pgtype.Text `json:"identifier"`
	Cloud      pgtype.Text `json:"cloud"`
	Connected  int         `json:"connected"`
}

// FindWebhookByID implements Querier.FindWebhookByID.
func (q *DBQuerier) FindWebhookByID(ctx context.Context, webhookID pgtype.UUID) (FindWebhookByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWebhookByID")
	row := q.conn.QueryRow(ctx, findWebhookByIDSQL, webhookID)
	var item FindWebhookByIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("query FindWebhookByID: %w", err)
	}
	return item, nil
}

// FindWebhookByIDBatch implements Querier.FindWebhookByIDBatch.
func (q *DBQuerier) FindWebhookByIDBatch(batch genericBatch, webhookID pgtype.UUID) {
	batch.Queue(findWebhookByIDSQL, webhookID)
}

// FindWebhookByIDScan implements Querier.FindWebhookByIDScan.
func (q *DBQuerier) FindWebhookByIDScan(results pgx.BatchResults) (FindWebhookByIDRow, error) {
	row := results.QueryRow()
	var item FindWebhookByIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("scan FindWebhookByIDBatch row: %w", err)
	}
	return item, nil
}

const findWebhookByRepoSQL = `SELECT *
FROM webhooks
WHERE identifier = $1
AND   cloud = $2;`

type FindWebhookByRepoRow struct {
	WebhookID  pgtype.UUID `json:"webhook_id"`
	VCSID      pgtype.Text `json:"vcs_id"`
	Secret     pgtype.Text `json:"secret"`
	Identifier pgtype.Text `json:"identifier"`
	Cloud      pgtype.Text `json:"cloud"`
	Connected  int         `json:"connected"`
}

// FindWebhookByRepo implements Querier.FindWebhookByRepo.
func (q *DBQuerier) FindWebhookByRepo(ctx context.Context, identifier pgtype.Text, cloud pgtype.Text) (FindWebhookByRepoRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWebhookByRepo")
	row := q.conn.QueryRow(ctx, findWebhookByRepoSQL, identifier, cloud)
	var item FindWebhookByRepoRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("query FindWebhookByRepo: %w", err)
	}
	return item, nil
}

// FindWebhookByRepoBatch implements Querier.FindWebhookByRepoBatch.
func (q *DBQuerier) FindWebhookByRepoBatch(batch genericBatch, identifier pgtype.Text, cloud pgtype.Text) {
	batch.Queue(findWebhookByRepoSQL, identifier, cloud)
}

// FindWebhookByRepoScan implements Querier.FindWebhookByRepoScan.
func (q *DBQuerier) FindWebhookByRepoScan(results pgx.BatchResults) (FindWebhookByRepoRow, error) {
	row := results.QueryRow()
	var item FindWebhookByRepoRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("scan FindWebhookByRepoBatch row: %w", err)
	}
	return item, nil
}

const disconnectWebhookSQL = `UPDATE webhooks
SET connected = connected - 1
WHERE webhook_id = $1
RETURNING *
;`

type DisconnectWebhookRow struct {
	WebhookID  pgtype.UUID `json:"webhook_id"`
	VCSID      pgtype.Text `json:"vcs_id"`
	Secret     pgtype.Text `json:"secret"`
	Identifier pgtype.Text `json:"identifier"`
	Cloud      pgtype.Text `json:"cloud"`
	Connected  int         `json:"connected"`
}

// DisconnectWebhook implements Querier.DisconnectWebhook.
func (q *DBQuerier) DisconnectWebhook(ctx context.Context, webhookID pgtype.UUID) (DisconnectWebhookRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DisconnectWebhook")
	row := q.conn.QueryRow(ctx, disconnectWebhookSQL, webhookID)
	var item DisconnectWebhookRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("query DisconnectWebhook: %w", err)
	}
	return item, nil
}

// DisconnectWebhookBatch implements Querier.DisconnectWebhookBatch.
func (q *DBQuerier) DisconnectWebhookBatch(batch genericBatch, webhookID pgtype.UUID) {
	batch.Queue(disconnectWebhookSQL, webhookID)
}

// DisconnectWebhookScan implements Querier.DisconnectWebhookScan.
func (q *DBQuerier) DisconnectWebhookScan(results pgx.BatchResults) (DisconnectWebhookRow, error) {
	row := results.QueryRow()
	var item DisconnectWebhookRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("scan DisconnectWebhookBatch row: %w", err)
	}
	return item, nil
}

const deleteWebhookByIDSQL = `DELETE
FROM webhooks
WHERE webhook_id = $1
RETURNING *
;`

type DeleteWebhookByIDRow struct {
	WebhookID  pgtype.UUID `json:"webhook_id"`
	VCSID      pgtype.Text `json:"vcs_id"`
	Secret     pgtype.Text `json:"secret"`
	Identifier pgtype.Text `json:"identifier"`
	Cloud      pgtype.Text `json:"cloud"`
	Connected  int         `json:"connected"`
}

// DeleteWebhookByID implements Querier.DeleteWebhookByID.
func (q *DBQuerier) DeleteWebhookByID(ctx context.Context, webhookID pgtype.UUID) (DeleteWebhookByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWebhookByID")
	row := q.conn.QueryRow(ctx, deleteWebhookByIDSQL, webhookID)
	var item DeleteWebhookByIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("query DeleteWebhookByID: %w", err)
	}
	return item, nil
}

// DeleteWebhookByIDBatch implements Querier.DeleteWebhookByIDBatch.
func (q *DBQuerier) DeleteWebhookByIDBatch(batch genericBatch, webhookID pgtype.UUID) {
	batch.Queue(deleteWebhookByIDSQL, webhookID)
}

// DeleteWebhookByIDScan implements Querier.DeleteWebhookByIDScan.
func (q *DBQuerier) DeleteWebhookByIDScan(results pgx.BatchResults) (DeleteWebhookByIDRow, error) {
	row := results.QueryRow()
	var item DeleteWebhookByIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSID, &item.Secret, &item.Identifier, &item.Cloud, &item.Connected); err != nil {
		return item, fmt.Errorf("scan DeleteWebhookByIDBatch row: %w", err)
	}
	return item, nil
}
