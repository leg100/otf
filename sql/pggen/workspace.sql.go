// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
	"time"
)

const insertWorkspaceSQL = `INSERT INTO workspaces (
    workspace_id,
    created_at,
    updated_at,
    allow_destroy_plan,
    auto_apply,
    can_queue_destroy_plan,
    description,
    environment,
    execution_mode,
    file_triggers_enabled,
    global_remote_state,
    locked,
    migration_environment,
    name,
    queue_all_runs,
    speculative_enabled,
    source_name,
    source_url,
    structured_run_output_enabled,
    terraform_version,
    trigger_prefixes,
    working_directory,
    organization_id
) VALUES (
    $1,
    current_timestamp,
    current_timestamp,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20,
    $21
)
RETURNING *;`

type InsertWorkspaceParams struct {
	ID                         string
	AllowDestroyPlan           bool
	AutoApply                  bool
	CanQueueDestroyPlan        bool
	Description                string
	Environment                string
	ExecutionMode              string
	FileTriggersEnabled        bool
	GlobalRemoteState          bool
	Locked                     bool
	MigrationEnvironment       string
	Name                       string
	QueueAllRuns               bool
	SpeculativeEnabled         bool
	SourceName                 string
	SourceURL                  string
	StructuredRunOutputEnabled bool
	TerraformVersion           string
	TriggerPrefixes            []string
	WorkingDirectory           string
	OrganizationID             string
}

type InsertWorkspaceRow struct {
	WorkspaceID                string    `json:"workspace_id"`
	CreatedAt                  time.Time `json:"created_at"`
	UpdatedAt                  time.Time `json:"updated_at"`
	AllowDestroyPlan           bool      `json:"allow_destroy_plan"`
	AutoApply                  bool      `json:"auto_apply"`
	CanQueueDestroyPlan        bool      `json:"can_queue_destroy_plan"`
	Description                string    `json:"description"`
	Environment                string    `json:"environment"`
	ExecutionMode              string    `json:"execution_mode"`
	FileTriggersEnabled        bool      `json:"file_triggers_enabled"`
	GlobalRemoteState          bool      `json:"global_remote_state"`
	Locked                     bool      `json:"locked"`
	MigrationEnvironment       string    `json:"migration_environment"`
	Name                       string    `json:"name"`
	QueueAllRuns               bool      `json:"queue_all_runs"`
	SpeculativeEnabled         bool      `json:"speculative_enabled"`
	SourceName                 string    `json:"source_name"`
	SourceURL                  string    `json:"source_url"`
	StructuredRunOutputEnabled bool      `json:"structured_run_output_enabled"`
	TerraformVersion           string    `json:"terraform_version"`
	TriggerPrefixes            []string  `json:"trigger_prefixes"`
	WorkingDirectory           string    `json:"working_directory"`
	OrganizationID             string    `json:"organization_id"`
}

// InsertWorkspace implements Querier.InsertWorkspace.
func (q *DBQuerier) InsertWorkspace(ctx context.Context, params InsertWorkspaceParams) (InsertWorkspaceRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspace")
	row := q.conn.QueryRow(ctx, insertWorkspaceSQL, params.ID, params.AllowDestroyPlan, params.AutoApply, params.CanQueueDestroyPlan, params.Description, params.Environment, params.ExecutionMode, params.FileTriggersEnabled, params.GlobalRemoteState, params.Locked, params.MigrationEnvironment, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.SourceName, params.SourceURL, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.WorkingDirectory, params.OrganizationID)
	var item InsertWorkspaceRow
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID); err != nil {
		return item, fmt.Errorf("query InsertWorkspace: %w", err)
	}
	return item, nil
}

// InsertWorkspaceBatch implements Querier.InsertWorkspaceBatch.
func (q *DBQuerier) InsertWorkspaceBatch(batch genericBatch, params InsertWorkspaceParams) {
	batch.Queue(insertWorkspaceSQL, params.ID, params.AllowDestroyPlan, params.AutoApply, params.CanQueueDestroyPlan, params.Description, params.Environment, params.ExecutionMode, params.FileTriggersEnabled, params.GlobalRemoteState, params.Locked, params.MigrationEnvironment, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.SourceName, params.SourceURL, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.WorkingDirectory, params.OrganizationID)
}

// InsertWorkspaceScan implements Querier.InsertWorkspaceScan.
func (q *DBQuerier) InsertWorkspaceScan(results pgx.BatchResults) (InsertWorkspaceRow, error) {
	row := results.QueryRow()
	var item InsertWorkspaceRow
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID); err != nil {
		return item, fmt.Errorf("scan InsertWorkspaceBatch row: %w", err)
	}
	return item, nil
}

const findWorkspacesSQL = `SELECT
    workspaces.*,
    (organizations.*)::"organizations" AS organization
FROM workspaces
JOIN organizations USING (organization_id)
WHERE workspaces.name LIKE $1 || '%'
AND organizations.name = $2
LIMIT $3
OFFSET $4
;`

type FindWorkspacesParams struct {
	Prefix           string
	OrganizationName string
	Limit            int
	Offset           int
}

type FindWorkspacesRow struct {
	WorkspaceID                string         `json:"workspace_id"`
	CreatedAt                  time.Time      `json:"created_at"`
	UpdatedAt                  time.Time      `json:"updated_at"`
	AllowDestroyPlan           bool           `json:"allow_destroy_plan"`
	AutoApply                  bool           `json:"auto_apply"`
	CanQueueDestroyPlan        bool           `json:"can_queue_destroy_plan"`
	Description                string         `json:"description"`
	Environment                string         `json:"environment"`
	ExecutionMode              string         `json:"execution_mode"`
	FileTriggersEnabled        bool           `json:"file_triggers_enabled"`
	GlobalRemoteState          bool           `json:"global_remote_state"`
	Locked                     bool           `json:"locked"`
	MigrationEnvironment       string         `json:"migration_environment"`
	Name                       string         `json:"name"`
	QueueAllRuns               bool           `json:"queue_all_runs"`
	SpeculativeEnabled         bool           `json:"speculative_enabled"`
	SourceName                 string         `json:"source_name"`
	SourceURL                  string         `json:"source_url"`
	StructuredRunOutputEnabled bool           `json:"structured_run_output_enabled"`
	TerraformVersion           string         `json:"terraform_version"`
	TriggerPrefixes            []string       `json:"trigger_prefixes"`
	WorkingDirectory           string         `json:"working_directory"`
	OrganizationID             string         `json:"organization_id"`
	Organization               *Organizations `json:"organization"`
}

// FindWorkspaces implements Querier.FindWorkspaces.
func (q *DBQuerier) FindWorkspaces(ctx context.Context, params FindWorkspacesParams) ([]FindWorkspacesRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaces")
	rows, err := q.conn.Query(ctx, findWorkspacesSQL, params.Prefix, params.OrganizationName, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaces: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspacesRow{}
	organizationRow := q.types.newOrganizations()
	for rows.Next() {
		var item FindWorkspacesRow
		if err := rows.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
			return nil, fmt.Errorf("scan FindWorkspaces row: %w", err)
		}
		if err := organizationRow.AssignTo(&item.Organization); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspaces rows: %w", err)
	}
	return items, err
}

// FindWorkspacesBatch implements Querier.FindWorkspacesBatch.
func (q *DBQuerier) FindWorkspacesBatch(batch genericBatch, params FindWorkspacesParams) {
	batch.Queue(findWorkspacesSQL, params.Prefix, params.OrganizationName, params.Limit, params.Offset)
}

// FindWorkspacesScan implements Querier.FindWorkspacesScan.
func (q *DBQuerier) FindWorkspacesScan(results pgx.BatchResults) ([]FindWorkspacesRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspacesBatch: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspacesRow{}
	organizationRow := q.types.newOrganizations()
	for rows.Next() {
		var item FindWorkspacesRow
		if err := rows.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
			return nil, fmt.Errorf("scan FindWorkspacesBatch row: %w", err)
		}
		if err := organizationRow.AssignTo(&item.Organization); err != nil {
			return nil, fmt.Errorf("assign FindWorkspaces row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspacesBatch rows: %w", err)
	}
	return items, err
}

const countWorkspacesSQL = `SELECT count(*)
FROM workspaces
JOIN organizations USING (organization_id)
WHERE workspaces.name LIKE $1 || '%'
AND organizations.name = $2
;`

// CountWorkspaces implements Querier.CountWorkspaces.
func (q *DBQuerier) CountWorkspaces(ctx context.Context, prefix string, organizationName string) (*int, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountWorkspaces")
	row := q.conn.QueryRow(ctx, countWorkspacesSQL, prefix, organizationName)
	var item int
	if err := row.Scan(&item); err != nil {
		return &item, fmt.Errorf("query CountWorkspaces: %w", err)
	}
	return &item, nil
}

// CountWorkspacesBatch implements Querier.CountWorkspacesBatch.
func (q *DBQuerier) CountWorkspacesBatch(batch genericBatch, prefix string, organizationName string) {
	batch.Queue(countWorkspacesSQL, prefix, organizationName)
}

// CountWorkspacesScan implements Querier.CountWorkspacesScan.
func (q *DBQuerier) CountWorkspacesScan(results pgx.BatchResults) (*int, error) {
	row := results.QueryRow()
	var item int
	if err := row.Scan(&item); err != nil {
		return &item, fmt.Errorf("scan CountWorkspacesBatch row: %w", err)
	}
	return &item, nil
}

const findWorkspaceIDByNameSQL = `SELECT workspaces.workspace_id
FROM workspaces
JOIN organizations USING (organization_id)
WHERE workspaces.name = $1
AND organizations.name = $2;`

// FindWorkspaceIDByName implements Querier.FindWorkspaceIDByName.
func (q *DBQuerier) FindWorkspaceIDByName(ctx context.Context, name string, organizationName string) (string, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceIDByName")
	row := q.conn.QueryRow(ctx, findWorkspaceIDByNameSQL, name, organizationName)
	var item string
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindWorkspaceIDByName: %w", err)
	}
	return item, nil
}

// FindWorkspaceIDByNameBatch implements Querier.FindWorkspaceIDByNameBatch.
func (q *DBQuerier) FindWorkspaceIDByNameBatch(batch genericBatch, name string, organizationName string) {
	batch.Queue(findWorkspaceIDByNameSQL, name, organizationName)
}

// FindWorkspaceIDByNameScan implements Querier.FindWorkspaceIDByNameScan.
func (q *DBQuerier) FindWorkspaceIDByNameScan(results pgx.BatchResults) (string, error) {
	row := results.QueryRow()
	var item string
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceIDByNameBatch row: %w", err)
	}
	return item, nil
}

const findWorkspaceByNameSQL = `SELECT workspaces.*, (organizations.*)::"organizations" AS organization
FROM workspaces
JOIN organizations USING (organization_id)
WHERE workspaces.name = $1
AND organizations.name = $2;`

type FindWorkspaceByNameRow struct {
	WorkspaceID                string         `json:"workspace_id"`
	CreatedAt                  time.Time      `json:"created_at"`
	UpdatedAt                  time.Time      `json:"updated_at"`
	AllowDestroyPlan           bool           `json:"allow_destroy_plan"`
	AutoApply                  bool           `json:"auto_apply"`
	CanQueueDestroyPlan        bool           `json:"can_queue_destroy_plan"`
	Description                string         `json:"description"`
	Environment                string         `json:"environment"`
	ExecutionMode              string         `json:"execution_mode"`
	FileTriggersEnabled        bool           `json:"file_triggers_enabled"`
	GlobalRemoteState          bool           `json:"global_remote_state"`
	Locked                     bool           `json:"locked"`
	MigrationEnvironment       string         `json:"migration_environment"`
	Name                       string         `json:"name"`
	QueueAllRuns               bool           `json:"queue_all_runs"`
	SpeculativeEnabled         bool           `json:"speculative_enabled"`
	SourceName                 string         `json:"source_name"`
	SourceURL                  string         `json:"source_url"`
	StructuredRunOutputEnabled bool           `json:"structured_run_output_enabled"`
	TerraformVersion           string         `json:"terraform_version"`
	TriggerPrefixes            []string       `json:"trigger_prefixes"`
	WorkingDirectory           string         `json:"working_directory"`
	OrganizationID             string         `json:"organization_id"`
	Organization               *Organizations `json:"organization"`
}

// FindWorkspaceByName implements Querier.FindWorkspaceByName.
func (q *DBQuerier) FindWorkspaceByName(ctx context.Context, name string, organizationName string) (FindWorkspaceByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByName")
	row := q.conn.QueryRow(ctx, findWorkspaceByNameSQL, name, organizationName)
	var item FindWorkspaceByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceByName: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	return item, nil
}

// FindWorkspaceByNameBatch implements Querier.FindWorkspaceByNameBatch.
func (q *DBQuerier) FindWorkspaceByNameBatch(batch genericBatch, name string, organizationName string) {
	batch.Queue(findWorkspaceByNameSQL, name, organizationName)
}

// FindWorkspaceByNameScan implements Querier.FindWorkspaceByNameScan.
func (q *DBQuerier) FindWorkspaceByNameScan(results pgx.BatchResults) (FindWorkspaceByNameRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceByNameBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	return item, nil
}

const findWorkspaceByNameForUpdateSQL = `SELECT workspaces.*, (organizations.*)::"organizations" AS organization
FROM workspaces
JOIN organizations USING (organization_id)
WHERE workspaces.name = $1
AND organizations.name = $2
FOR UPDATE;`

type FindWorkspaceByNameForUpdateRow struct {
	WorkspaceID                string         `json:"workspace_id"`
	CreatedAt                  time.Time      `json:"created_at"`
	UpdatedAt                  time.Time      `json:"updated_at"`
	AllowDestroyPlan           bool           `json:"allow_destroy_plan"`
	AutoApply                  bool           `json:"auto_apply"`
	CanQueueDestroyPlan        bool           `json:"can_queue_destroy_plan"`
	Description                string         `json:"description"`
	Environment                string         `json:"environment"`
	ExecutionMode              string         `json:"execution_mode"`
	FileTriggersEnabled        bool           `json:"file_triggers_enabled"`
	GlobalRemoteState          bool           `json:"global_remote_state"`
	Locked                     bool           `json:"locked"`
	MigrationEnvironment       string         `json:"migration_environment"`
	Name                       string         `json:"name"`
	QueueAllRuns               bool           `json:"queue_all_runs"`
	SpeculativeEnabled         bool           `json:"speculative_enabled"`
	SourceName                 string         `json:"source_name"`
	SourceURL                  string         `json:"source_url"`
	StructuredRunOutputEnabled bool           `json:"structured_run_output_enabled"`
	TerraformVersion           string         `json:"terraform_version"`
	TriggerPrefixes            []string       `json:"trigger_prefixes"`
	WorkingDirectory           string         `json:"working_directory"`
	OrganizationID             string         `json:"organization_id"`
	Organization               *Organizations `json:"organization"`
}

// FindWorkspaceByNameForUpdate implements Querier.FindWorkspaceByNameForUpdate.
func (q *DBQuerier) FindWorkspaceByNameForUpdate(ctx context.Context, name string, organizationName string) (FindWorkspaceByNameForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByNameForUpdate")
	row := q.conn.QueryRow(ctx, findWorkspaceByNameForUpdateSQL, name, organizationName)
	var item FindWorkspaceByNameForUpdateRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceByNameForUpdate: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByNameForUpdate row: %w", err)
	}
	return item, nil
}

// FindWorkspaceByNameForUpdateBatch implements Querier.FindWorkspaceByNameForUpdateBatch.
func (q *DBQuerier) FindWorkspaceByNameForUpdateBatch(batch genericBatch, name string, organizationName string) {
	batch.Queue(findWorkspaceByNameForUpdateSQL, name, organizationName)
}

// FindWorkspaceByNameForUpdateScan implements Querier.FindWorkspaceByNameForUpdateScan.
func (q *DBQuerier) FindWorkspaceByNameForUpdateScan(results pgx.BatchResults) (FindWorkspaceByNameForUpdateRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceByNameForUpdateRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceByNameForUpdateBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByNameForUpdate row: %w", err)
	}
	return item, nil
}

const findWorkspaceByIDSQL = `SELECT workspaces.*, (organizations.*)::"organizations" AS organization
FROM workspaces
JOIN organizations USING (organization_id)
WHERE workspaces.workspace_id = $1;`

type FindWorkspaceByIDRow struct {
	WorkspaceID                string         `json:"workspace_id"`
	CreatedAt                  time.Time      `json:"created_at"`
	UpdatedAt                  time.Time      `json:"updated_at"`
	AllowDestroyPlan           bool           `json:"allow_destroy_plan"`
	AutoApply                  bool           `json:"auto_apply"`
	CanQueueDestroyPlan        bool           `json:"can_queue_destroy_plan"`
	Description                string         `json:"description"`
	Environment                string         `json:"environment"`
	ExecutionMode              string         `json:"execution_mode"`
	FileTriggersEnabled        bool           `json:"file_triggers_enabled"`
	GlobalRemoteState          bool           `json:"global_remote_state"`
	Locked                     bool           `json:"locked"`
	MigrationEnvironment       string         `json:"migration_environment"`
	Name                       string         `json:"name"`
	QueueAllRuns               bool           `json:"queue_all_runs"`
	SpeculativeEnabled         bool           `json:"speculative_enabled"`
	SourceName                 string         `json:"source_name"`
	SourceURL                  string         `json:"source_url"`
	StructuredRunOutputEnabled bool           `json:"structured_run_output_enabled"`
	TerraformVersion           string         `json:"terraform_version"`
	TriggerPrefixes            []string       `json:"trigger_prefixes"`
	WorkingDirectory           string         `json:"working_directory"`
	OrganizationID             string         `json:"organization_id"`
	Organization               *Organizations `json:"organization"`
}

// FindWorkspaceByID implements Querier.FindWorkspaceByID.
func (q *DBQuerier) FindWorkspaceByID(ctx context.Context, id string) (FindWorkspaceByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByID")
	row := q.conn.QueryRow(ctx, findWorkspaceByIDSQL, id)
	var item FindWorkspaceByIDRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceByID: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	return item, nil
}

// FindWorkspaceByIDBatch implements Querier.FindWorkspaceByIDBatch.
func (q *DBQuerier) FindWorkspaceByIDBatch(batch genericBatch, id string) {
	batch.Queue(findWorkspaceByIDSQL, id)
}

// FindWorkspaceByIDScan implements Querier.FindWorkspaceByIDScan.
func (q *DBQuerier) FindWorkspaceByIDScan(results pgx.BatchResults) (FindWorkspaceByIDRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceByIDRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceByIDBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	return item, nil
}

const findWorkspaceByIDForUpdateSQL = `SELECT workspaces.*, (organizations.*)::"organizations" AS organization
FROM workspaces
JOIN organizations USING (organization_id)
WHERE workspaces.workspace_id = $1
FOR UPDATE;`

type FindWorkspaceByIDForUpdateRow struct {
	WorkspaceID                string         `json:"workspace_id"`
	CreatedAt                  time.Time      `json:"created_at"`
	UpdatedAt                  time.Time      `json:"updated_at"`
	AllowDestroyPlan           bool           `json:"allow_destroy_plan"`
	AutoApply                  bool           `json:"auto_apply"`
	CanQueueDestroyPlan        bool           `json:"can_queue_destroy_plan"`
	Description                string         `json:"description"`
	Environment                string         `json:"environment"`
	ExecutionMode              string         `json:"execution_mode"`
	FileTriggersEnabled        bool           `json:"file_triggers_enabled"`
	GlobalRemoteState          bool           `json:"global_remote_state"`
	Locked                     bool           `json:"locked"`
	MigrationEnvironment       string         `json:"migration_environment"`
	Name                       string         `json:"name"`
	QueueAllRuns               bool           `json:"queue_all_runs"`
	SpeculativeEnabled         bool           `json:"speculative_enabled"`
	SourceName                 string         `json:"source_name"`
	SourceURL                  string         `json:"source_url"`
	StructuredRunOutputEnabled bool           `json:"structured_run_output_enabled"`
	TerraformVersion           string         `json:"terraform_version"`
	TriggerPrefixes            []string       `json:"trigger_prefixes"`
	WorkingDirectory           string         `json:"working_directory"`
	OrganizationID             string         `json:"organization_id"`
	Organization               *Organizations `json:"organization"`
}

// FindWorkspaceByIDForUpdate implements Querier.FindWorkspaceByIDForUpdate.
func (q *DBQuerier) FindWorkspaceByIDForUpdate(ctx context.Context, id string) (FindWorkspaceByIDForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByIDForUpdate")
	row := q.conn.QueryRow(ctx, findWorkspaceByIDForUpdateSQL, id)
	var item FindWorkspaceByIDForUpdateRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceByIDForUpdate: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	return item, nil
}

// FindWorkspaceByIDForUpdateBatch implements Querier.FindWorkspaceByIDForUpdateBatch.
func (q *DBQuerier) FindWorkspaceByIDForUpdateBatch(batch genericBatch, id string) {
	batch.Queue(findWorkspaceByIDForUpdateSQL, id)
}

// FindWorkspaceByIDForUpdateScan implements Querier.FindWorkspaceByIDForUpdateScan.
func (q *DBQuerier) FindWorkspaceByIDForUpdateScan(results pgx.BatchResults) (FindWorkspaceByIDForUpdateRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceByIDForUpdateRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceURL, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceByIDForUpdateBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByIDForUpdate row: %w", err)
	}
	return item, nil
}

const updateWorkspaceByIDSQL = `UPDATE workspaces
SET
    allow_destroy_plan = $1,
    description = $2,
    execution_mode = $3,
    locked = $4,
    name = $5,
    queue_all_runs = $6,
    speculative_enabled = $7,
    structured_run_output_enabled = $8,
    terraform_version = $9,
    trigger_prefixes = $10,
    working_directory = $11,
    updated_at = current_timestamp
WHERE workspace_id = $12
RETURNING updated_at;`

type UpdateWorkspaceByIDParams struct {
	AllowDestroyPlan           bool
	Description                string
	ExecutionMode              string
	Locked                     bool
	Name                       string
	QueueAllRuns               bool
	SpeculativeEnabled         bool
	StructuredRunOutputEnabled bool
	TerraformVersion           string
	TriggerPrefixes            []string
	WorkingDirectory           string
	ID                         string
}

// UpdateWorkspaceByID implements Querier.UpdateWorkspaceByID.
func (q *DBQuerier) UpdateWorkspaceByID(ctx context.Context, params UpdateWorkspaceByIDParams) (time.Time, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateWorkspaceByID")
	row := q.conn.QueryRow(ctx, updateWorkspaceByIDSQL, params.AllowDestroyPlan, params.Description, params.ExecutionMode, params.Locked, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.WorkingDirectory, params.ID)
	var item time.Time
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateWorkspaceByID: %w", err)
	}
	return item, nil
}

// UpdateWorkspaceByIDBatch implements Querier.UpdateWorkspaceByIDBatch.
func (q *DBQuerier) UpdateWorkspaceByIDBatch(batch genericBatch, params UpdateWorkspaceByIDParams) {
	batch.Queue(updateWorkspaceByIDSQL, params.AllowDestroyPlan, params.Description, params.ExecutionMode, params.Locked, params.Name, params.QueueAllRuns, params.SpeculativeEnabled, params.StructuredRunOutputEnabled, params.TerraformVersion, params.TriggerPrefixes, params.WorkingDirectory, params.ID)
}

// UpdateWorkspaceByIDScan implements Querier.UpdateWorkspaceByIDScan.
func (q *DBQuerier) UpdateWorkspaceByIDScan(results pgx.BatchResults) (time.Time, error) {
	row := results.QueryRow()
	var item time.Time
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateWorkspaceByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteWorkspaceByIDSQL = `DELETE
FROM workspaces
WHERE workspace_id = $1;`

// DeleteWorkspaceByID implements Querier.DeleteWorkspaceByID.
func (q *DBQuerier) DeleteWorkspaceByID(ctx context.Context, workspaceID string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceByID")
	cmdTag, err := q.conn.Exec(ctx, deleteWorkspaceByIDSQL, workspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteWorkspaceByID: %w", err)
	}
	return cmdTag, err
}

// DeleteWorkspaceByIDBatch implements Querier.DeleteWorkspaceByIDBatch.
func (q *DBQuerier) DeleteWorkspaceByIDBatch(batch genericBatch, workspaceID string) {
	batch.Queue(deleteWorkspaceByIDSQL, workspaceID)
}

// DeleteWorkspaceByIDScan implements Querier.DeleteWorkspaceByIDScan.
func (q *DBQuerier) DeleteWorkspaceByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteWorkspaceByIDBatch: %w", err)
	}
	return cmdTag, err
}

const deleteWorkspaceByNameSQL = `DELETE
FROM workspaces
USING organizations
WHERE workspaces.organization_id = organizations.organization_id
AND workspaces.name = $1
AND organizations.name = $2;`

// DeleteWorkspaceByName implements Querier.DeleteWorkspaceByName.
func (q *DBQuerier) DeleteWorkspaceByName(ctx context.Context, name string, organizationName string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceByName")
	cmdTag, err := q.conn.Exec(ctx, deleteWorkspaceByNameSQL, name, organizationName)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteWorkspaceByName: %w", err)
	}
	return cmdTag, err
}

// DeleteWorkspaceByNameBatch implements Querier.DeleteWorkspaceByNameBatch.
func (q *DBQuerier) DeleteWorkspaceByNameBatch(batch genericBatch, name string, organizationName string) {
	batch.Queue(deleteWorkspaceByNameSQL, name, organizationName)
}

// DeleteWorkspaceByNameScan implements Querier.DeleteWorkspaceByNameScan.
func (q *DBQuerier) DeleteWorkspaceByNameScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteWorkspaceByNameBatch: %w", err)
	}
	return cmdTag, err
}
