// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertPhaseStatusTimestampSQL = `INSERT INTO phase_status_timestamps (
    run_id,
    phase,
    status,
    timestamp
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertPhaseStatusTimestampParams struct {
	RunID     pgtype.Text
	Phase     pgtype.Text
	Status    pgtype.Text
	Timestamp pgtype.Timestamptz
}

// InsertPhaseStatusTimestamp implements Querier.InsertPhaseStatusTimestamp.
func (q *DBQuerier) InsertPhaseStatusTimestamp(ctx context.Context, params InsertPhaseStatusTimestampParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPhaseStatusTimestamp")
	cmdTag, err := q.conn.Exec(ctx, insertPhaseStatusTimestampSQL, params.RunID, params.Phase, params.Status, params.Timestamp)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertPhaseStatusTimestamp: %w", err)
	}
	return cmdTag, err
}

// InsertPhaseStatusTimestampBatch implements Querier.InsertPhaseStatusTimestampBatch.
func (q *DBQuerier) InsertPhaseStatusTimestampBatch(batch genericBatch, params InsertPhaseStatusTimestampParams) {
	batch.Queue(insertPhaseStatusTimestampSQL, params.RunID, params.Phase, params.Status, params.Timestamp)
}

// InsertPhaseStatusTimestampScan implements Querier.InsertPhaseStatusTimestampScan.
func (q *DBQuerier) InsertPhaseStatusTimestampScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertPhaseStatusTimestampBatch: %w", err)
	}
	return cmdTag, err
}

const insertLogChunkSQL = `INSERT INTO logs (
    run_id,
    phase,
    chunk,
    _offset
) VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING chunk_id
;`

type InsertLogChunkParams struct {
	RunID  pgtype.Text
	Phase  pgtype.Text
	Chunk  []byte
	Offset int
}

// InsertLogChunk implements Querier.InsertLogChunk.
func (q *DBQuerier) InsertLogChunk(ctx context.Context, params InsertLogChunkParams) (int, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertLogChunk")
	row := q.conn.QueryRow(ctx, insertLogChunkSQL, params.RunID, params.Phase, params.Chunk, params.Offset)
	var item int
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query InsertLogChunk: %w", err)
	}
	return item, nil
}

// InsertLogChunkBatch implements Querier.InsertLogChunkBatch.
func (q *DBQuerier) InsertLogChunkBatch(batch genericBatch, params InsertLogChunkParams) {
	batch.Queue(insertLogChunkSQL, params.RunID, params.Phase, params.Chunk, params.Offset)
}

// InsertLogChunkScan implements Querier.InsertLogChunkScan.
func (q *DBQuerier) InsertLogChunkScan(results pgx.BatchResults) (int, error) {
	row := results.QueryRow()
	var item int
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan InsertLogChunkBatch row: %w", err)
	}
	return item, nil
}

const findLogsSQL = `SELECT
    string_agg(chunk, '')
FROM (
    SELECT run_id, phase, chunk
    FROM logs
    WHERE run_id = $1
    AND   phase  = $2
    ORDER BY chunk_id
) c
GROUP BY run_id, phase
;`

// FindLogs implements Querier.FindLogs.
func (q *DBQuerier) FindLogs(ctx context.Context, runID pgtype.Text, phase pgtype.Text) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindLogs")
	row := q.conn.QueryRow(ctx, findLogsSQL, runID, phase)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindLogs: %w", err)
	}
	return item, nil
}

// FindLogsBatch implements Querier.FindLogsBatch.
func (q *DBQuerier) FindLogsBatch(batch genericBatch, runID pgtype.Text, phase pgtype.Text) {
	batch.Queue(findLogsSQL, runID, phase)
}

// FindLogsScan implements Querier.FindLogsScan.
func (q *DBQuerier) FindLogsScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindLogsBatch row: %w", err)
	}
	return item, nil
}

const findLogChunkByIDSQL = `SELECT
    chunk_id,
    run_id,
    phase,
    chunk,
    _offset AS offset
FROM logs
WHERE chunk_id = $1
;`

type FindLogChunkByIDRow struct {
	ChunkID int         `json:"chunk_id"`
	RunID   pgtype.Text `json:"run_id"`
	Phase   pgtype.Text `json:"phase"`
	Chunk   []byte      `json:"chunk"`
	Offset  int         `json:"offset"`
}

// FindLogChunkByID implements Querier.FindLogChunkByID.
func (q *DBQuerier) FindLogChunkByID(ctx context.Context, chunkID int) (FindLogChunkByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindLogChunkByID")
	row := q.conn.QueryRow(ctx, findLogChunkByIDSQL, chunkID)
	var item FindLogChunkByIDRow
	if err := row.Scan(&item.ChunkID, &item.RunID, &item.Phase, &item.Chunk, &item.Offset); err != nil {
		return item, fmt.Errorf("query FindLogChunkByID: %w", err)
	}
	return item, nil
}

// FindLogChunkByIDBatch implements Querier.FindLogChunkByIDBatch.
func (q *DBQuerier) FindLogChunkByIDBatch(batch genericBatch, chunkID int) {
	batch.Queue(findLogChunkByIDSQL, chunkID)
}

// FindLogChunkByIDScan implements Querier.FindLogChunkByIDScan.
func (q *DBQuerier) FindLogChunkByIDScan(results pgx.BatchResults) (FindLogChunkByIDRow, error) {
	row := results.QueryRow()
	var item FindLogChunkByIDRow
	if err := row.Scan(&item.ChunkID, &item.RunID, &item.Phase, &item.Chunk, &item.Offset); err != nil {
		return item, fmt.Errorf("scan FindLogChunkByIDBatch row: %w", err)
	}
	return item, nil
}
