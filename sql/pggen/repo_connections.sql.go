// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertRepoConnectionSQL = `INSERT INTO repo_connections (
    webhook_id,
    vcs_provider_id,
    workspace_id,
    module_id
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertRepoConnectionParams struct {
	WebhookID     pgtype.UUID
	VCSProviderID pgtype.Text
	WorkspaceID   pgtype.Text
	ModuleID      pgtype.Text
}

// InsertRepoConnection implements Querier.InsertRepoConnection.
func (q *DBQuerier) InsertRepoConnection(ctx context.Context, params InsertRepoConnectionParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertRepoConnection")
	cmdTag, err := q.conn.Exec(ctx, insertRepoConnectionSQL, params.WebhookID, params.VCSProviderID, params.WorkspaceID, params.ModuleID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertRepoConnection: %w", err)
	}
	return cmdTag, err
}

// InsertRepoConnectionBatch implements Querier.InsertRepoConnectionBatch.
func (q *DBQuerier) InsertRepoConnectionBatch(batch genericBatch, params InsertRepoConnectionParams) {
	batch.Queue(insertRepoConnectionSQL, params.WebhookID, params.VCSProviderID, params.WorkspaceID, params.ModuleID)
}

// InsertRepoConnectionScan implements Querier.InsertRepoConnectionScan.
func (q *DBQuerier) InsertRepoConnectionScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertRepoConnectionBatch: %w", err)
	}
	return cmdTag, err
}

const countRepoConnectionsByIDSQL = `SELECT count(*)
FROM repo_connections
WHERE webhook_id = $1
;`

// CountRepoConnectionsByID implements Querier.CountRepoConnectionsByID.
func (q *DBQuerier) CountRepoConnectionsByID(ctx context.Context, webhookID pgtype.UUID) (*int, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountRepoConnectionsByID")
	row := q.conn.QueryRow(ctx, countRepoConnectionsByIDSQL, webhookID)
	var item int
	if err := row.Scan(&item); err != nil {
		return &item, fmt.Errorf("query CountRepoConnectionsByID: %w", err)
	}
	return &item, nil
}

// CountRepoConnectionsByIDBatch implements Querier.CountRepoConnectionsByIDBatch.
func (q *DBQuerier) CountRepoConnectionsByIDBatch(batch genericBatch, webhookID pgtype.UUID) {
	batch.Queue(countRepoConnectionsByIDSQL, webhookID)
}

// CountRepoConnectionsByIDScan implements Querier.CountRepoConnectionsByIDScan.
func (q *DBQuerier) CountRepoConnectionsByIDScan(results pgx.BatchResults) (*int, error) {
	row := results.QueryRow()
	var item int
	if err := row.Scan(&item); err != nil {
		return &item, fmt.Errorf("scan CountRepoConnectionsByIDBatch row: %w", err)
	}
	return &item, nil
}

const deleteWorkspaceConnectionByIDSQL = `DELETE
FROM repo_connections
WHERE workspace_id = $1
RETURNING webhook_id, vcs_provider_id
;`

type DeleteWorkspaceConnectionByIDRow struct {
	WebhookID     pgtype.UUID `json:"webhook_id"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
}

// DeleteWorkspaceConnectionByID implements Querier.DeleteWorkspaceConnectionByID.
func (q *DBQuerier) DeleteWorkspaceConnectionByID(ctx context.Context, workspaceID pgtype.Text) (DeleteWorkspaceConnectionByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceConnectionByID")
	row := q.conn.QueryRow(ctx, deleteWorkspaceConnectionByIDSQL, workspaceID)
	var item DeleteWorkspaceConnectionByIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("query DeleteWorkspaceConnectionByID: %w", err)
	}
	return item, nil
}

// DeleteWorkspaceConnectionByIDBatch implements Querier.DeleteWorkspaceConnectionByIDBatch.
func (q *DBQuerier) DeleteWorkspaceConnectionByIDBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(deleteWorkspaceConnectionByIDSQL, workspaceID)
}

// DeleteWorkspaceConnectionByIDScan implements Querier.DeleteWorkspaceConnectionByIDScan.
func (q *DBQuerier) DeleteWorkspaceConnectionByIDScan(results pgx.BatchResults) (DeleteWorkspaceConnectionByIDRow, error) {
	row := results.QueryRow()
	var item DeleteWorkspaceConnectionByIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("scan DeleteWorkspaceConnectionByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteModuleConnectionByIDSQL = `DELETE
FROM repo_connections
WHERE module_id = $1
RETURNING webhook_id, vcs_provider_id
;`

type DeleteModuleConnectionByIDRow struct {
	WebhookID     pgtype.UUID `json:"webhook_id"`
	VCSProviderID pgtype.Text `json:"vcs_provider_id"`
}

// DeleteModuleConnectionByID implements Querier.DeleteModuleConnectionByID.
func (q *DBQuerier) DeleteModuleConnectionByID(ctx context.Context, id pgtype.Text) (DeleteModuleConnectionByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteModuleConnectionByID")
	row := q.conn.QueryRow(ctx, deleteModuleConnectionByIDSQL, id)
	var item DeleteModuleConnectionByIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("query DeleteModuleConnectionByID: %w", err)
	}
	return item, nil
}

// DeleteModuleConnectionByIDBatch implements Querier.DeleteModuleConnectionByIDBatch.
func (q *DBQuerier) DeleteModuleConnectionByIDBatch(batch genericBatch, id pgtype.Text) {
	batch.Queue(deleteModuleConnectionByIDSQL, id)
}

// DeleteModuleConnectionByIDScan implements Querier.DeleteModuleConnectionByIDScan.
func (q *DBQuerier) DeleteModuleConnectionByIDScan(results pgx.BatchResults) (DeleteModuleConnectionByIDRow, error) {
	row := results.QueryRow()
	var item DeleteModuleConnectionByIDRow
	if err := row.Scan(&item.WebhookID, &item.VCSProviderID); err != nil {
		return item, fmt.Errorf("scan DeleteModuleConnectionByIDBatch row: %w", err)
	}
	return item, nil
}
