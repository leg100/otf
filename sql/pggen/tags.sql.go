// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertTagSQL = `INSERT INTO tags (
    tag_id,
    name,
    organization_name
) VALUES (
    $1,
    $2,
    $3
);`

type InsertTagParams struct {
	TagID            pgtype.Text
	Name             pgtype.Text
	OrganizationName pgtype.Text
}

// InsertTag implements Querier.InsertTag.
func (q *DBQuerier) InsertTag(ctx context.Context, params InsertTagParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertTag")
	cmdTag, err := q.conn.Exec(ctx, insertTagSQL, params.TagID, params.Name, params.OrganizationName)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertTag: %w", err)
	}
	return cmdTag, err
}

// InsertTagBatch implements Querier.InsertTagBatch.
func (q *DBQuerier) InsertTagBatch(batch genericBatch, params InsertTagParams) {
	batch.Queue(insertTagSQL, params.TagID, params.Name, params.OrganizationName)
}

// InsertTagScan implements Querier.InsertTagScan.
func (q *DBQuerier) InsertTagScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertTagBatch: %w", err)
	}
	return cmdTag, err
}

const insertWorkspaceTagSQL = `INSERT INTO workspace_tags (
    tag_id,
    workspace_id
) VALUES (
    $1,
    $2
);`

// InsertWorkspaceTag implements Querier.InsertWorkspaceTag.
func (q *DBQuerier) InsertWorkspaceTag(ctx context.Context, tagID pgtype.Text, workspaceID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertWorkspaceTag")
	cmdTag, err := q.conn.Exec(ctx, insertWorkspaceTagSQL, tagID, workspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertWorkspaceTag: %w", err)
	}
	return cmdTag, err
}

// InsertWorkspaceTagBatch implements Querier.InsertWorkspaceTagBatch.
func (q *DBQuerier) InsertWorkspaceTagBatch(batch genericBatch, tagID pgtype.Text, workspaceID pgtype.Text) {
	batch.Queue(insertWorkspaceTagSQL, tagID, workspaceID)
}

// InsertWorkspaceTagScan implements Querier.InsertWorkspaceTagScan.
func (q *DBQuerier) InsertWorkspaceTagScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertWorkspaceTagBatch: %w", err)
	}
	return cmdTag, err
}

const findTagsSQL = `SELECT
    t.*,
    (
        SELECT count(*)
        FROM workspace_tags wt
        WHERE wt.tag_id = t.tag_id
    ) AS instance_count
FROM tags t
WHERE t.organization_name = $1
;`

type FindTagsRow struct {
	TagID            pgtype.Text `json:"tag_id"`
	Name             pgtype.Text `json:"name"`
	OrganizationName pgtype.Text `json:"organization_name"`
	InstanceCount    int         `json:"instance_count"`
}

// FindTags implements Querier.FindTags.
func (q *DBQuerier) FindTags(ctx context.Context, organizationName pgtype.Text) ([]FindTagsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindTags")
	rows, err := q.conn.Query(ctx, findTagsSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindTags: %w", err)
	}
	defer rows.Close()
	items := []FindTagsRow{}
	for rows.Next() {
		var item FindTagsRow
		if err := rows.Scan(&item.TagID, &item.Name, &item.OrganizationName, &item.InstanceCount); err != nil {
			return nil, fmt.Errorf("scan FindTags row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindTags rows: %w", err)
	}
	return items, err
}

// FindTagsBatch implements Querier.FindTagsBatch.
func (q *DBQuerier) FindTagsBatch(batch genericBatch, organizationName pgtype.Text) {
	batch.Queue(findTagsSQL, organizationName)
}

// FindTagsScan implements Querier.FindTagsScan.
func (q *DBQuerier) FindTagsScan(results pgx.BatchResults) ([]FindTagsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindTagsBatch: %w", err)
	}
	defer rows.Close()
	items := []FindTagsRow{}
	for rows.Next() {
		var item FindTagsRow
		if err := rows.Scan(&item.TagID, &item.Name, &item.OrganizationName, &item.InstanceCount); err != nil {
			return nil, fmt.Errorf("scan FindTagsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindTagsBatch rows: %w", err)
	}
	return items, err
}

const findWorkspaceTagsSQL = `SELECT
    t.*,
    (
        SELECT count(*)
        FROM workspace_tags wt
        WHERE wt.tag_id = t.tag_id
    ) AS instance_count
FROM workspace_tags wt
JOIN tags t USING (tag_id)
WHERE wt.workspace_id = $1
;`

type FindWorkspaceTagsRow struct {
	TagID            pgtype.Text `json:"tag_id"`
	Name             pgtype.Text `json:"name"`
	OrganizationName pgtype.Text `json:"organization_name"`
	InstanceCount    *int        `json:"instance_count"`
}

// FindWorkspaceTags implements Querier.FindWorkspaceTags.
func (q *DBQuerier) FindWorkspaceTags(ctx context.Context, workspaceID pgtype.Text) ([]FindWorkspaceTagsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceTags")
	rows, err := q.conn.Query(ctx, findWorkspaceTagsSQL, workspaceID)
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaceTags: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspaceTagsRow{}
	for rows.Next() {
		var item FindWorkspaceTagsRow
		if err := rows.Scan(&item.TagID, &item.Name, &item.OrganizationName, &item.InstanceCount); err != nil {
			return nil, fmt.Errorf("scan FindWorkspaceTags row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspaceTags rows: %w", err)
	}
	return items, err
}

// FindWorkspaceTagsBatch implements Querier.FindWorkspaceTagsBatch.
func (q *DBQuerier) FindWorkspaceTagsBatch(batch genericBatch, workspaceID pgtype.Text) {
	batch.Queue(findWorkspaceTagsSQL, workspaceID)
}

// FindWorkspaceTagsScan implements Querier.FindWorkspaceTagsScan.
func (q *DBQuerier) FindWorkspaceTagsScan(results pgx.BatchResults) ([]FindWorkspaceTagsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindWorkspaceTagsBatch: %w", err)
	}
	defer rows.Close()
	items := []FindWorkspaceTagsRow{}
	for rows.Next() {
		var item FindWorkspaceTagsRow
		if err := rows.Scan(&item.TagID, &item.Name, &item.OrganizationName, &item.InstanceCount); err != nil {
			return nil, fmt.Errorf("scan FindWorkspaceTagsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindWorkspaceTagsBatch rows: %w", err)
	}
	return items, err
}

const deleteWorkspaceTagSQL = `DELETE
FROM workspace_tags
WHERE workspace_id  = $1
AND   tag_id        = $2
;`

// DeleteWorkspaceTag implements Querier.DeleteWorkspaceTag.
func (q *DBQuerier) DeleteWorkspaceTag(ctx context.Context, workspaceID pgtype.Text, tagID pgtype.Text) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceTag")
	cmdTag, err := q.conn.Exec(ctx, deleteWorkspaceTagSQL, workspaceID, tagID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteWorkspaceTag: %w", err)
	}
	return cmdTag, err
}

// DeleteWorkspaceTagBatch implements Querier.DeleteWorkspaceTagBatch.
func (q *DBQuerier) DeleteWorkspaceTagBatch(batch genericBatch, workspaceID pgtype.Text, tagID pgtype.Text) {
	batch.Queue(deleteWorkspaceTagSQL, workspaceID, tagID)
}

// DeleteWorkspaceTagScan implements Querier.DeleteWorkspaceTagScan.
func (q *DBQuerier) DeleteWorkspaceTagScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteWorkspaceTagBatch: %w", err)
	}
	return cmdTag, err
}
