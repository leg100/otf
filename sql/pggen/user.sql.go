// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertUserSQL = `INSERT INTO users (
    user_id,
    created_at,
    updated_at,
    username
) VALUES (
    $1,
    $2,
    $3,
    $4
);`

type InsertUserParams struct {
	ID        pgtype.Text
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Username  pgtype.Text
}

// InsertUser implements Querier.InsertUser.
func (q *DBQuerier) InsertUser(ctx context.Context, params InsertUserParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertUser")
	cmdTag, err := q.conn.Exec(ctx, insertUserSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.Username)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertUser: %w", err)
	}
	return cmdTag, err
}

// InsertUserBatch implements Querier.InsertUserBatch.
func (q *DBQuerier) InsertUserBatch(batch genericBatch, params InsertUserParams) {
	batch.Queue(insertUserSQL, params.ID, params.CreatedAt, params.UpdatedAt, params.Username)
}

// InsertUserScan implements Querier.InsertUserScan.
func (q *DBQuerier) InsertUserScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertUserBatch: %w", err)
	}
	return cmdTag, err
}

const findUsersSQL = `SELECT u.*,
    array_remove(array_agg(s), NULL) AS sessions,
    array_remove(array_agg(t), NULL) AS tokens,
    array_remove(array_agg(o), NULL) AS organizations,
    array_remove(array_agg(teams), NULL) AS teams
FROM users u
LEFT JOIN sessions s ON u.user_id = s.user_id AND s.expiry > current_timestamp
LEFT JOIN tokens t ON u.user_id = t.user_id
LEFT JOIN (organization_memberships om JOIN organizations o USING (organization_id)) ON u.user_id = om.user_id
LEFT JOIN (team_memberships tm JOIN teams USING (team_id)) ON u.user_id = tm.user_id
GROUP BY u.user_id
;`

type FindUsersRow struct {
	UserID        pgtype.Text        `json:"user_id"`
	Username      pgtype.Text        `json:"username"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Sessions      []Sessions         `json:"sessions"`
	Tokens        []Tokens           `json:"tokens"`
	Organizations []Organizations    `json:"organizations"`
	Teams         []Teams            `json:"teams"`
}

// FindUsers implements Querier.FindUsers.
func (q *DBQuerier) FindUsers(ctx context.Context) ([]FindUsersRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUsers")
	rows, err := q.conn.Query(ctx, findUsersSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindUsers: %w", err)
	}
	defer rows.Close()
	items := []FindUsersRow{}
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsers row: %w", err)
		}
		if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		if err := tokensArray.AssignTo(&item.Tokens); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsers rows: %w", err)
	}
	return items, err
}

// FindUsersBatch implements Querier.FindUsersBatch.
func (q *DBQuerier) FindUsersBatch(batch genericBatch) {
	batch.Queue(findUsersSQL)
}

// FindUsersScan implements Querier.FindUsersScan.
func (q *DBQuerier) FindUsersScan(results pgx.BatchResults) ([]FindUsersRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindUsersBatch: %w", err)
	}
	defer rows.Close()
	items := []FindUsersRow{}
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersBatch row: %w", err)
		}
		if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		if err := tokensArray.AssignTo(&item.Tokens); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsers row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersBatch rows: %w", err)
	}
	return items, err
}

const findUsersByOrganizationSQL = `SELECT u.*,
    array_remove(array_agg(s), NULL) AS sessions,
    array_remove(array_agg(t), NULL) AS tokens,
    (
        SELECT array_remove(array_agg(o), NULL)
        FROM organizations o
        LEFT JOIN organization_memberships om USING (organization_id)
        WHERE om.user_id = u.user_id
    ) AS organizations,
    array_remove(array_agg(teams), NULL) AS teams
FROM users u
LEFT JOIN sessions s ON u.user_id = s.user_id AND s.expiry > current_timestamp
LEFT JOIN tokens t ON u.user_id = t.user_id
LEFT JOIN (organization_memberships om JOIN organizations o USING (organization_id)) ON u.user_id = om.user_id
LEFT JOIN (team_memberships tm JOIN teams USING (team_id)) ON u.user_id = tm.user_id
WHERE o.name = $1
GROUP BY u.user_id
;`

type FindUsersByOrganizationRow struct {
	UserID        pgtype.Text        `json:"user_id"`
	Username      pgtype.Text        `json:"username"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Sessions      []Sessions         `json:"sessions"`
	Tokens        []Tokens           `json:"tokens"`
	Organizations []Organizations    `json:"organizations"`
	Teams         []Teams            `json:"teams"`
}

// FindUsersByOrganization implements Querier.FindUsersByOrganization.
func (q *DBQuerier) FindUsersByOrganization(ctx context.Context, organizationName pgtype.Text) ([]FindUsersByOrganizationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUsersByOrganization")
	rows, err := q.conn.Query(ctx, findUsersByOrganizationSQL, organizationName)
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByOrganization: %w", err)
	}
	defer rows.Close()
	items := []FindUsersByOrganizationRow{}
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersByOrganizationRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersByOrganization row: %w", err)
		}
		if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		if err := tokensArray.AssignTo(&item.Tokens); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersByOrganization rows: %w", err)
	}
	return items, err
}

// FindUsersByOrganizationBatch implements Querier.FindUsersByOrganizationBatch.
func (q *DBQuerier) FindUsersByOrganizationBatch(batch genericBatch, organizationName pgtype.Text) {
	batch.Queue(findUsersByOrganizationSQL, organizationName)
}

// FindUsersByOrganizationScan implements Querier.FindUsersByOrganizationScan.
func (q *DBQuerier) FindUsersByOrganizationScan(results pgx.BatchResults) ([]FindUsersByOrganizationRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByOrganizationBatch: %w", err)
	}
	defer rows.Close()
	items := []FindUsersByOrganizationRow{}
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersByOrganizationRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersByOrganizationBatch row: %w", err)
		}
		if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		if err := tokensArray.AssignTo(&item.Tokens); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsersByOrganization row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersByOrganizationBatch rows: %w", err)
	}
	return items, err
}

const findUsersByTeamSQL = `SELECT u.*,
    array_remove(array_agg(s), NULL) AS sessions,
    array_remove(array_agg(t), NULL) AS tokens,
    (
        SELECT array_remove(array_agg(o), NULL)
        FROM organizations o
        LEFT JOIN organization_memberships om USING (organization_id)
        WHERE om.user_id = u.user_id
    ) AS organizations,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM teams t
        LEFT JOIN team_memberships tm USING (team_id)
        WHERE tm.user_id = u.user_id
    ) AS teams
FROM users u
LEFT JOIN sessions s ON u.user_id = s.user_id AND s.expiry > current_timestamp
LEFT JOIN tokens t ON u.user_id = t.user_id
LEFT JOIN (organization_memberships om JOIN organizations o USING (organization_id)) ON u.user_id = om.user_id
LEFT JOIN (team_memberships tm JOIN teams USING (team_id)) ON u.user_id = tm.user_id
WHERE o.name = $1
AND   teams.name = $2
GROUP BY u.user_id
;`

type FindUsersByTeamRow struct {
	UserID        pgtype.Text        `json:"user_id"`
	Username      pgtype.Text        `json:"username"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Sessions      []Sessions         `json:"sessions"`
	Tokens        []Tokens           `json:"tokens"`
	Organizations []Organizations    `json:"organizations"`
	Teams         []Teams            `json:"teams"`
}

// FindUsersByTeam implements Querier.FindUsersByTeam.
func (q *DBQuerier) FindUsersByTeam(ctx context.Context, organizationName pgtype.Text, teamName pgtype.Text) ([]FindUsersByTeamRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUsersByTeam")
	rows, err := q.conn.Query(ctx, findUsersByTeamSQL, organizationName, teamName)
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByTeam: %w", err)
	}
	defer rows.Close()
	items := []FindUsersByTeamRow{}
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersByTeamRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersByTeam row: %w", err)
		}
		if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeam row: %w", err)
		}
		if err := tokensArray.AssignTo(&item.Tokens); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeam row: %w", err)
		}
		if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeam row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeam row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersByTeam rows: %w", err)
	}
	return items, err
}

// FindUsersByTeamBatch implements Querier.FindUsersByTeamBatch.
func (q *DBQuerier) FindUsersByTeamBatch(batch genericBatch, organizationName pgtype.Text, teamName pgtype.Text) {
	batch.Queue(findUsersByTeamSQL, organizationName, teamName)
}

// FindUsersByTeamScan implements Querier.FindUsersByTeamScan.
func (q *DBQuerier) FindUsersByTeamScan(results pgx.BatchResults) ([]FindUsersByTeamRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindUsersByTeamBatch: %w", err)
	}
	defer rows.Close()
	items := []FindUsersByTeamRow{}
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	for rows.Next() {
		var item FindUsersByTeamRow
		if err := rows.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
			return nil, fmt.Errorf("scan FindUsersByTeamBatch row: %w", err)
		}
		if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeam row: %w", err)
		}
		if err := tokensArray.AssignTo(&item.Tokens); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeam row: %w", err)
		}
		if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeam row: %w", err)
		}
		if err := teamsArray.AssignTo(&item.Teams); err != nil {
			return nil, fmt.Errorf("assign FindUsersByTeam row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindUsersByTeamBatch rows: %w", err)
	}
	return items, err
}

const findUserByIDSQL = `SELECT u.*,
    (
        SELECT array_remove(array_agg(s), NULL)
        FROM sessions s
        WHERE s.user_id = u.user_id
        AND s.expiry > current_timestamp
    ) AS sessions,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM tokens t
        WHERE t.user_id = u.user_id
    ) AS tokens,
    (
        SELECT array_remove(array_agg(o), NULL)
        FROM organizations o
        LEFT JOIN organization_memberships om USING (organization_id)
        WHERE om.user_id = u.user_id
    ) AS organizations,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM teams t
        LEFT JOIN team_memberships tm USING (team_id)
        WHERE tm.user_id = u.user_id
    ) AS teams
FROM users u
WHERE u.user_id = $1
GROUP BY u.user_id
;`

type FindUserByIDRow struct {
	UserID        pgtype.Text        `json:"user_id"`
	Username      pgtype.Text        `json:"username"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Sessions      []Sessions         `json:"sessions"`
	Tokens        []Tokens           `json:"tokens"`
	Organizations []Organizations    `json:"organizations"`
	Teams         []Teams            `json:"teams"`
}

// FindUserByID implements Querier.FindUserByID.
func (q *DBQuerier) FindUserByID(ctx context.Context, userID pgtype.Text) (FindUserByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByID")
	row := q.conn.QueryRow(ctx, findUserByIDSQL, userID)
	var item FindUserByIDRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("query FindUserByID: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	return item, nil
}

// FindUserByIDBatch implements Querier.FindUserByIDBatch.
func (q *DBQuerier) FindUserByIDBatch(batch genericBatch, userID pgtype.Text) {
	batch.Queue(findUserByIDSQL, userID)
}

// FindUserByIDScan implements Querier.FindUserByIDScan.
func (q *DBQuerier) FindUserByIDScan(results pgx.BatchResults) (FindUserByIDRow, error) {
	row := results.QueryRow()
	var item FindUserByIDRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("scan FindUserByIDBatch row: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByID row: %w", err)
	}
	return item, nil
}

const findUserByUsernameSQL = `SELECT u.*,
    (
        SELECT array_remove(array_agg(s), NULL)
        FROM sessions s
        WHERE s.user_id = u.user_id
        AND s.expiry > current_timestamp
    ) AS sessions,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM tokens t
        WHERE t.user_id = u.user_id
    ) AS tokens,
    (
        SELECT array_remove(array_agg(o), NULL)
        FROM organizations o
        LEFT JOIN organization_memberships om USING (organization_id)
        WHERE om.user_id = u.user_id
    ) AS organizations,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM teams t
        LEFT JOIN team_memberships tm USING (team_id)
        WHERE tm.user_id = u.user_id
    ) AS teams
FROM users u
WHERE u.username = $1
GROUP BY u.user_id
;`

type FindUserByUsernameRow struct {
	UserID        pgtype.Text        `json:"user_id"`
	Username      pgtype.Text        `json:"username"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Sessions      []Sessions         `json:"sessions"`
	Tokens        []Tokens           `json:"tokens"`
	Organizations []Organizations    `json:"organizations"`
	Teams         []Teams            `json:"teams"`
}

// FindUserByUsername implements Querier.FindUserByUsername.
func (q *DBQuerier) FindUserByUsername(ctx context.Context, username pgtype.Text) (FindUserByUsernameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByUsername")
	row := q.conn.QueryRow(ctx, findUserByUsernameSQL, username)
	var item FindUserByUsernameRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("query FindUserByUsername: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	return item, nil
}

// FindUserByUsernameBatch implements Querier.FindUserByUsernameBatch.
func (q *DBQuerier) FindUserByUsernameBatch(batch genericBatch, username pgtype.Text) {
	batch.Queue(findUserByUsernameSQL, username)
}

// FindUserByUsernameScan implements Querier.FindUserByUsernameScan.
func (q *DBQuerier) FindUserByUsernameScan(results pgx.BatchResults) (FindUserByUsernameRow, error) {
	row := results.QueryRow()
	var item FindUserByUsernameRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("scan FindUserByUsernameBatch row: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByUsername row: %w", err)
	}
	return item, nil
}

const findUserBySessionTokenSQL = `SELECT u.*,
    (
        SELECT array_remove(array_agg(s), NULL)
        FROM sessions s
        WHERE s.user_id = u.user_id
        AND s.expiry > current_timestamp
    ) AS sessions,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM tokens t
        WHERE t.user_id = u.user_id
    ) AS tokens,
    (
        SELECT array_remove(array_agg(o), NULL)
        FROM organizations o
        LEFT JOIN organization_memberships om USING (organization_id)
        WHERE om.user_id = u.user_id
    ) AS organizations,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM teams t
        LEFT JOIN team_memberships tm USING (team_id)
        WHERE tm.user_id = u.user_id
    ) AS teams
FROM users u
JOIN sessions s ON u.user_id = s.user_id AND s.expiry > current_timestamp
WHERE s.token = $1
GROUP BY u.user_id
;`

type FindUserBySessionTokenRow struct {
	UserID        pgtype.Text        `json:"user_id"`
	Username      pgtype.Text        `json:"username"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Sessions      []Sessions         `json:"sessions"`
	Tokens        []Tokens           `json:"tokens"`
	Organizations []Organizations    `json:"organizations"`
	Teams         []Teams            `json:"teams"`
}

// FindUserBySessionToken implements Querier.FindUserBySessionToken.
func (q *DBQuerier) FindUserBySessionToken(ctx context.Context, token pgtype.Text) (FindUserBySessionTokenRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserBySessionToken")
	row := q.conn.QueryRow(ctx, findUserBySessionTokenSQL, token)
	var item FindUserBySessionTokenRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("query FindUserBySessionToken: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserBySessionToken row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserBySessionToken row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserBySessionToken row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserBySessionToken row: %w", err)
	}
	return item, nil
}

// FindUserBySessionTokenBatch implements Querier.FindUserBySessionTokenBatch.
func (q *DBQuerier) FindUserBySessionTokenBatch(batch genericBatch, token pgtype.Text) {
	batch.Queue(findUserBySessionTokenSQL, token)
}

// FindUserBySessionTokenScan implements Querier.FindUserBySessionTokenScan.
func (q *DBQuerier) FindUserBySessionTokenScan(results pgx.BatchResults) (FindUserBySessionTokenRow, error) {
	row := results.QueryRow()
	var item FindUserBySessionTokenRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("scan FindUserBySessionTokenBatch row: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserBySessionToken row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserBySessionToken row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserBySessionToken row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserBySessionToken row: %w", err)
	}
	return item, nil
}

const findUserByAuthenticationTokenSQL = `SELECT u.*,
    (
        select array_remove(array_agg(s), null)
        from sessions s
        where s.user_id = u.user_id
        and s.expiry > current_timestamp
    ) as sessions,
    (
        select array_remove(array_agg(t), null)
        from tokens t
        where t.user_id = u.user_id
    ) as tokens,
    (
        select array_remove(array_agg(o), null)
        from organizations o
        left join organization_memberships om using (organization_id)
        where om.user_id = u.user_id
    ) as organizations,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM teams t
        LEFT JOIN team_memberships tm USING (team_id)
        WHERE tm.user_id = u.user_id
    ) AS teams
FROM users u
LEFT JOIN tokens t ON u.user_id = t.user_id
WHERE t.token = $1
GROUP BY u.user_id
;`

type FindUserByAuthenticationTokenRow struct {
	UserID        pgtype.Text        `json:"user_id"`
	Username      pgtype.Text        `json:"username"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Sessions      []Sessions         `json:"sessions"`
	Tokens        []Tokens           `json:"tokens"`
	Organizations []Organizations    `json:"organizations"`
	Teams         []Teams            `json:"teams"`
}

// FindUserByAuthenticationToken implements Querier.FindUserByAuthenticationToken.
func (q *DBQuerier) FindUserByAuthenticationToken(ctx context.Context, token pgtype.Text) (FindUserByAuthenticationTokenRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByAuthenticationToken")
	row := q.conn.QueryRow(ctx, findUserByAuthenticationTokenSQL, token)
	var item FindUserByAuthenticationTokenRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("query FindUserByAuthenticationToken: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationToken row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationToken row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationToken row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationToken row: %w", err)
	}
	return item, nil
}

// FindUserByAuthenticationTokenBatch implements Querier.FindUserByAuthenticationTokenBatch.
func (q *DBQuerier) FindUserByAuthenticationTokenBatch(batch genericBatch, token pgtype.Text) {
	batch.Queue(findUserByAuthenticationTokenSQL, token)
}

// FindUserByAuthenticationTokenScan implements Querier.FindUserByAuthenticationTokenScan.
func (q *DBQuerier) FindUserByAuthenticationTokenScan(results pgx.BatchResults) (FindUserByAuthenticationTokenRow, error) {
	row := results.QueryRow()
	var item FindUserByAuthenticationTokenRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("scan FindUserByAuthenticationTokenBatch row: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationToken row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationToken row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationToken row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationToken row: %w", err)
	}
	return item, nil
}

const findUserByAuthenticationTokenIDSQL = `SELECT u.*,
    (
        SELECT array_remove(array_agg(s), NULL)
        FROM sessions s
        WHERE s.user_id = u.user_id
        AND s.expiry > current_timestamp
    ) AS sessions,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM tokens t
        WHERE t.user_id = u.user_id
    ) AS tokens,
    (
        SELECT array_remove(array_agg(o), NULL)
        FROM organizations o
        LEFT JOIN organization_memberships om USING (organization_id)
        WHERE om.user_id = u.user_id
    ) AS organizations,
    (
        SELECT array_remove(array_agg(t), NULL)
        FROM teams t
        LEFT JOIN team_memberships tm USING (team_id)
        WHERE tm.user_id = u.user_id
    ) AS teams
FROM users u
JOIN tokens t ON u.user_id = t.user_id
WHERE t.token_id = $1
GROUP BY u.user_id
;`

type FindUserByAuthenticationTokenIDRow struct {
	UserID        pgtype.Text        `json:"user_id"`
	Username      pgtype.Text        `json:"username"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	Sessions      []Sessions         `json:"sessions"`
	Tokens        []Tokens           `json:"tokens"`
	Organizations []Organizations    `json:"organizations"`
	Teams         []Teams            `json:"teams"`
}

// FindUserByAuthenticationTokenID implements Querier.FindUserByAuthenticationTokenID.
func (q *DBQuerier) FindUserByAuthenticationTokenID(ctx context.Context, tokenID pgtype.Text) (FindUserByAuthenticationTokenIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindUserByAuthenticationTokenID")
	row := q.conn.QueryRow(ctx, findUserByAuthenticationTokenIDSQL, tokenID)
	var item FindUserByAuthenticationTokenIDRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("query FindUserByAuthenticationTokenID: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	return item, nil
}

// FindUserByAuthenticationTokenIDBatch implements Querier.FindUserByAuthenticationTokenIDBatch.
func (q *DBQuerier) FindUserByAuthenticationTokenIDBatch(batch genericBatch, tokenID pgtype.Text) {
	batch.Queue(findUserByAuthenticationTokenIDSQL, tokenID)
}

// FindUserByAuthenticationTokenIDScan implements Querier.FindUserByAuthenticationTokenIDScan.
func (q *DBQuerier) FindUserByAuthenticationTokenIDScan(results pgx.BatchResults) (FindUserByAuthenticationTokenIDRow, error) {
	row := results.QueryRow()
	var item FindUserByAuthenticationTokenIDRow
	sessionsArray := q.types.newSessionsArray()
	tokensArray := q.types.newTokensArray()
	organizationsArray := q.types.newOrganizationsArray()
	teamsArray := q.types.newTeamsArray()
	if err := row.Scan(&item.UserID, &item.Username, &item.CreatedAt, &item.UpdatedAt, sessionsArray, tokensArray, organizationsArray, teamsArray); err != nil {
		return item, fmt.Errorf("scan FindUserByAuthenticationTokenIDBatch row: %w", err)
	}
	if err := sessionsArray.AssignTo(&item.Sessions); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	if err := tokensArray.AssignTo(&item.Tokens); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	if err := teamsArray.AssignTo(&item.Teams); err != nil {
		return item, fmt.Errorf("assign FindUserByAuthenticationTokenID row: %w", err)
	}
	return item, nil
}

const deleteUserByIDSQL = `DELETE
FROM users
WHERE user_id = $1
RETURNING user_id
;`

// DeleteUserByID implements Querier.DeleteUserByID.
func (q *DBQuerier) DeleteUserByID(ctx context.Context, userID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteUserByID")
	row := q.conn.QueryRow(ctx, deleteUserByIDSQL, userID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteUserByID: %w", err)
	}
	return item, nil
}

// DeleteUserByIDBatch implements Querier.DeleteUserByIDBatch.
func (q *DBQuerier) DeleteUserByIDBatch(batch genericBatch, userID pgtype.Text) {
	batch.Queue(deleteUserByIDSQL, userID)
}

// DeleteUserByIDScan implements Querier.DeleteUserByIDScan.
func (q *DBQuerier) DeleteUserByIDScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteUserByIDBatch row: %w", err)
	}
	return item, nil
}

const deleteUserByUsernameSQL = `DELETE
FROM users
WHERE username = $1
RETURNING user_id
;`

// DeleteUserByUsername implements Querier.DeleteUserByUsername.
func (q *DBQuerier) DeleteUserByUsername(ctx context.Context, username pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteUserByUsername")
	row := q.conn.QueryRow(ctx, deleteUserByUsernameSQL, username)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query DeleteUserByUsername: %w", err)
	}
	return item, nil
}

// DeleteUserByUsernameBatch implements Querier.DeleteUserByUsernameBatch.
func (q *DBQuerier) DeleteUserByUsernameBatch(batch genericBatch, username pgtype.Text) {
	batch.Queue(deleteUserByUsernameSQL, username)
}

// DeleteUserByUsernameScan implements Querier.DeleteUserByUsernameScan.
func (q *DBQuerier) DeleteUserByUsernameScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan DeleteUserByUsernameBatch row: %w", err)
	}
	return item, nil
}
