// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const findQueuedJobsSQL = `SELECT
    j.job_id,
    j.run_id,
    j.status,
    r.is_destroy,
    r.refresh,
    r.refresh_only,
    w.auto_apply,
    cv.speculative,
    r.configuration_version_id,
    r.workspace_id
FROM jobs j
JOIN runs r ON r.run_id = j.run_id
JOIN configuration_versions cv USING(configuration_version_id)
JOIN workspaces w ON r.workspace_id = w.workspace_id
WHERE j.status = 'queued'
;`

type FindQueuedJobsRow struct {
	JobID                  pgtype.Text `json:"job_id"`
	RunID                  pgtype.Text `json:"run_id"`
	Status                 pgtype.Text `json:"status"`
	IsDestroy              bool        `json:"is_destroy"`
	Refresh                bool        `json:"refresh"`
	RefreshOnly            bool        `json:"refresh_only"`
	AutoApply              bool        `json:"auto_apply"`
	Speculative            bool        `json:"speculative"`
	ConfigurationVersionID pgtype.Text `json:"configuration_version_id"`
	WorkspaceID            pgtype.Text `json:"workspace_id"`
}

// FindQueuedJobs implements Querier.FindQueuedJobs.
func (q *DBQuerier) FindQueuedJobs(ctx context.Context) ([]FindQueuedJobsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindQueuedJobs")
	rows, err := q.conn.Query(ctx, findQueuedJobsSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindQueuedJobs: %w", err)
	}
	defer rows.Close()
	items := []FindQueuedJobsRow{}
	for rows.Next() {
		var item FindQueuedJobsRow
		if err := rows.Scan(&item.JobID, &item.RunID, &item.Status, &item.IsDestroy, &item.Refresh, &item.RefreshOnly, &item.AutoApply, &item.Speculative, &item.ConfigurationVersionID, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindQueuedJobs row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindQueuedJobs rows: %w", err)
	}
	return items, err
}

// FindQueuedJobsBatch implements Querier.FindQueuedJobsBatch.
func (q *DBQuerier) FindQueuedJobsBatch(batch genericBatch) {
	batch.Queue(findQueuedJobsSQL)
}

// FindQueuedJobsScan implements Querier.FindQueuedJobsScan.
func (q *DBQuerier) FindQueuedJobsScan(results pgx.BatchResults) ([]FindQueuedJobsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindQueuedJobsBatch: %w", err)
	}
	defer rows.Close()
	items := []FindQueuedJobsRow{}
	for rows.Next() {
		var item FindQueuedJobsRow
		if err := rows.Scan(&item.JobID, &item.RunID, &item.Status, &item.IsDestroy, &item.Refresh, &item.RefreshOnly, &item.AutoApply, &item.Speculative, &item.ConfigurationVersionID, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindQueuedJobsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindQueuedJobsBatch rows: %w", err)
	}
	return items, err
}
