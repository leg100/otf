// Code generated by pggen. DO NOT EDIT.

package pggen

import (
	"context"
	"fmt"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const findQueuedJobsSQL = `SELECT
    j.job_id,
    j.run_id,
    j.status,
    r.is_destroy,
    r.refresh,
    r.refresh_only,
    w.auto_apply,
    cv.speculative,
    r.configuration_version_id,
    r.workspace_id
FROM jobs j
JOIN runs r ON r.run_id = j.run_id
JOIN configuration_versions cv USING(configuration_version_id)
JOIN workspaces w ON r.workspace_id = w.workspace_id
WHERE j.status = 'queued'
;`

type FindQueuedJobsRow struct {
	JobID                  pgtype.Text `json:"job_id"`
	RunID                  pgtype.Text `json:"run_id"`
	Status                 pgtype.Text `json:"status"`
	IsDestroy              bool        `json:"is_destroy"`
	Refresh                bool        `json:"refresh"`
	RefreshOnly            bool        `json:"refresh_only"`
	AutoApply              bool        `json:"auto_apply"`
	Speculative            bool        `json:"speculative"`
	ConfigurationVersionID pgtype.Text `json:"configuration_version_id"`
	WorkspaceID            pgtype.Text `json:"workspace_id"`
}

// FindQueuedJobs implements Querier.FindQueuedJobs.
func (q *DBQuerier) FindQueuedJobs(ctx context.Context) ([]FindQueuedJobsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindQueuedJobs")
	rows, err := q.conn.Query(ctx, findQueuedJobsSQL)
	if err != nil {
		return nil, fmt.Errorf("query FindQueuedJobs: %w", err)
	}
	defer rows.Close()
	items := []FindQueuedJobsRow{}
	for rows.Next() {
		var item FindQueuedJobsRow
		if err := rows.Scan(&item.JobID, &item.RunID, &item.Status, &item.IsDestroy, &item.Refresh, &item.RefreshOnly, &item.AutoApply, &item.Speculative, &item.ConfigurationVersionID, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindQueuedJobs row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindQueuedJobs rows: %w", err)
	}
	return items, err
}

// FindQueuedJobsBatch implements Querier.FindQueuedJobsBatch.
func (q *DBQuerier) FindQueuedJobsBatch(batch genericBatch) {
	batch.Queue(findQueuedJobsSQL)
}

// FindQueuedJobsScan implements Querier.FindQueuedJobsScan.
func (q *DBQuerier) FindQueuedJobsScan(results pgx.BatchResults) ([]FindQueuedJobsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindQueuedJobsBatch: %w", err)
	}
	defer rows.Close()
	items := []FindQueuedJobsRow{}
	for rows.Next() {
		var item FindQueuedJobsRow
		if err := rows.Scan(&item.JobID, &item.RunID, &item.Status, &item.IsDestroy, &item.Refresh, &item.RefreshOnly, &item.AutoApply, &item.Speculative, &item.ConfigurationVersionID, &item.WorkspaceID); err != nil {
			return nil, fmt.Errorf("scan FindQueuedJobsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindQueuedJobsBatch rows: %w", err)
	}
	return items, err
}

const insertLogChunkSQL = `INSERT INTO logs (
    job_id,
    chunk
) VALUES (
    $1,
    $2
)
;`

// InsertLogChunk implements Querier.InsertLogChunk.
func (q *DBQuerier) InsertLogChunk(ctx context.Context, jobID pgtype.Text, chunk []byte) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertLogChunk")
	cmdTag, err := q.conn.Exec(ctx, insertLogChunkSQL, jobID, chunk)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query InsertLogChunk: %w", err)
	}
	return cmdTag, err
}

// InsertLogChunkBatch implements Querier.InsertLogChunkBatch.
func (q *DBQuerier) InsertLogChunkBatch(batch genericBatch, jobID pgtype.Text, chunk []byte) {
	batch.Queue(insertLogChunkSQL, jobID, chunk)
}

// InsertLogChunkScan implements Querier.InsertLogChunkScan.
func (q *DBQuerier) InsertLogChunkScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec InsertLogChunkBatch: %w", err)
	}
	return cmdTag, err
}

const findLogChunksSQL = `SELECT
    substring(string_agg(chunk, '') FROM $1 FOR $2)
FROM (
    SELECT job_id, chunk
    FROM logs
    WHERE job_id = $3
    ORDER BY chunk_id
) c
GROUP BY job_id
;`

type FindLogChunksParams struct {
	Offset int
	Limit  int
	JobID  pgtype.Text
}

// FindLogChunks implements Querier.FindLogChunks.
func (q *DBQuerier) FindLogChunks(ctx context.Context, params FindLogChunksParams) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindLogChunks")
	row := q.conn.QueryRow(ctx, findLogChunksSQL, params.Offset, params.Limit, params.JobID)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindLogChunks: %w", err)
	}
	return item, nil
}

// FindLogChunksBatch implements Querier.FindLogChunksBatch.
func (q *DBQuerier) FindLogChunksBatch(batch genericBatch, params FindLogChunksParams) {
	batch.Queue(findLogChunksSQL, params.Offset, params.Limit, params.JobID)
}

// FindLogChunksScan implements Querier.FindLogChunksScan.
func (q *DBQuerier) FindLogChunksScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindLogChunksBatch row: %w", err)
	}
	return item, nil
}

const updateJobStatusSQL = `UPDATE jobs
SET status = $1
WHERE job_id = $2
RETURNING job_id
;`

// UpdateJobStatus implements Querier.UpdateJobStatus.
func (q *DBQuerier) UpdateJobStatus(ctx context.Context, status pgtype.Text, jobID pgtype.Text) (pgtype.Text, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateJobStatus")
	row := q.conn.QueryRow(ctx, updateJobStatusSQL, status, jobID)
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query UpdateJobStatus: %w", err)
	}
	return item, nil
}

// UpdateJobStatusBatch implements Querier.UpdateJobStatusBatch.
func (q *DBQuerier) UpdateJobStatusBatch(batch genericBatch, status pgtype.Text, jobID pgtype.Text) {
	batch.Queue(updateJobStatusSQL, status, jobID)
}

// UpdateJobStatusScan implements Querier.UpdateJobStatusScan.
func (q *DBQuerier) UpdateJobStatusScan(results pgx.BatchResults) (pgtype.Text, error) {
	row := results.QueryRow()
	var item pgtype.Text
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan UpdateJobStatusBatch row: %w", err)
	}
	return item, nil
}
