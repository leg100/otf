// Code generated by pggen. DO NOT EDIT.

package sql

import (
	"context"
	"fmt"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertPlanLogChunkSQL = `INSERT INTO plan_logs (
    plan_id,
    chunk,
    start,
    _end,
    size
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5
)
RETURNING *;`

type InsertPlanLogChunkParams struct {
	PlanID *string
	Chunk  []byte
	Start  *bool
	End    *bool
	Size   int32
}

type InsertPlanLogChunkRow struct {
	PlanID  *string `json:"plan_id"`
	ChunkID int32   `json:"chunk_id"`
	Chunk   []byte  `json:"chunk"`
	Size    int32   `json:"size"`
	Start   *bool   `json:"start"`
	End     *bool   `json:"_end"`
}

func (s InsertPlanLogChunkRow) GetPlanID() *string { return s.PlanID }
func (s InsertPlanLogChunkRow) GetChunkID() int32 { return s.ChunkID }
func (s InsertPlanLogChunkRow) GetChunk() []byte { return s.Chunk }
func (s InsertPlanLogChunkRow) GetSize() int32 { return s.Size }
func (s InsertPlanLogChunkRow) GetStart() *bool { return s.Start }
func (s InsertPlanLogChunkRow) GetEnd() *bool { return s.End }


// InsertPlanLogChunk implements Querier.InsertPlanLogChunk.
func (q *DBQuerier) InsertPlanLogChunk(ctx context.Context, params InsertPlanLogChunkParams) (InsertPlanLogChunkRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPlanLogChunk")
	row := q.conn.QueryRow(ctx, insertPlanLogChunkSQL, params.PlanID, params.Chunk, params.Start, params.End, params.Size)
	var item InsertPlanLogChunkRow
	if err := row.Scan(&item.PlanID, &item.ChunkID, &item.Chunk, &item.Size, &item.Start, &item.End); err != nil {
		return item, fmt.Errorf("query InsertPlanLogChunk: %w", err)
	}
	return item, nil
}

// InsertPlanLogChunkBatch implements Querier.InsertPlanLogChunkBatch.
func (q *DBQuerier) InsertPlanLogChunkBatch(batch genericBatch, params InsertPlanLogChunkParams) {
	batch.Queue(insertPlanLogChunkSQL, params.PlanID, params.Chunk, params.Start, params.End, params.Size)
}

// InsertPlanLogChunkScan implements Querier.InsertPlanLogChunkScan.
func (q *DBQuerier) InsertPlanLogChunkScan(results pgx.BatchResults) (InsertPlanLogChunkRow, error) {
	row := results.QueryRow()
	var item InsertPlanLogChunkRow
	if err := row.Scan(&item.PlanID, &item.ChunkID, &item.Chunk, &item.Size, &item.Start, &item.End); err != nil {
		return item, fmt.Errorf("scan InsertPlanLogChunkBatch row: %w", err)
	}
	return item, nil
}

const findPlanLogChunksSQL = `SELECT chunk, start, _end
FROM plan_logs
WHERE plan_id = $1
ORDER BY chunk_id ASC
;`

type FindPlanLogChunksRow struct {
	Chunk pgtype.Bytea `json:"chunk"`
	Start *bool        `json:"start"`
	End   *bool        `json:"_end"`
}

func (s FindPlanLogChunksRow) GetChunk() pgtype.Bytea { return s.Chunk }
func (s FindPlanLogChunksRow) GetStart() *bool { return s.Start }
func (s FindPlanLogChunksRow) GetEnd() *bool { return s.End }


// FindPlanLogChunks implements Querier.FindPlanLogChunks.
func (q *DBQuerier) FindPlanLogChunks(ctx context.Context, planID *string) ([]FindPlanLogChunksRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindPlanLogChunks")
	rows, err := q.conn.Query(ctx, findPlanLogChunksSQL, planID)
	if err != nil {
		return nil, fmt.Errorf("query FindPlanLogChunks: %w", err)
	}
	defer rows.Close()
	items := []FindPlanLogChunksRow{}
	for rows.Next() {
		var item FindPlanLogChunksRow
		if err := rows.Scan(&item.Chunk, &item.Start, &item.End); err != nil {
			return nil, fmt.Errorf("scan FindPlanLogChunks row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindPlanLogChunks rows: %w", err)
	}
	return items, err
}

// FindPlanLogChunksBatch implements Querier.FindPlanLogChunksBatch.
func (q *DBQuerier) FindPlanLogChunksBatch(batch genericBatch, planID *string) {
	batch.Queue(findPlanLogChunksSQL, planID)
}

// FindPlanLogChunksScan implements Querier.FindPlanLogChunksScan.
func (q *DBQuerier) FindPlanLogChunksScan(results pgx.BatchResults) ([]FindPlanLogChunksRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindPlanLogChunksBatch: %w", err)
	}
	defer rows.Close()
	items := []FindPlanLogChunksRow{}
	for rows.Next() {
		var item FindPlanLogChunksRow
		if err := rows.Scan(&item.Chunk, &item.Start, &item.End); err != nil {
			return nil, fmt.Errorf("scan FindPlanLogChunksBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindPlanLogChunksBatch rows: %w", err)
	}
	return items, err
}
