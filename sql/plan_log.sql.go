// Code generated by pggen. DO NOT EDIT.

package sql

import (
	"context"
	"fmt"

	"github.com/jackc/pgx/v4"
)

const insertPlanLogChunkSQL = `INSERT INTO plan_logs (
    plan_id,
    chunk
) VALUES (
    $1,
    $2
)
RETURNING *;`

type InsertPlanLogChunkRow struct {
	PlanID  *string `json:"plan_id"`
	ChunkID int32   `json:"chunk_id"`
	Chunk   []byte  `json:"chunk"`
	Size    int32   `json:"size"`
	Start   *bool   `json:"start"`
	End     *bool   `json:"_end"`
}

func (s InsertPlanLogChunkRow) GetPlanID() *string { return s.PlanID }
func (s InsertPlanLogChunkRow) GetChunkID() int32  { return s.ChunkID }
func (s InsertPlanLogChunkRow) GetChunk() []byte   { return s.Chunk }
func (s InsertPlanLogChunkRow) GetSize() int32     { return s.Size }
func (s InsertPlanLogChunkRow) GetStart() *bool    { return s.Start }
func (s InsertPlanLogChunkRow) GetEnd() *bool      { return s.End }

// InsertPlanLogChunk implements Querier.InsertPlanLogChunk.
func (q *DBQuerier) InsertPlanLogChunk(ctx context.Context, planID *string, chunk []byte) (InsertPlanLogChunkRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertPlanLogChunk")
	row := q.conn.QueryRow(ctx, insertPlanLogChunkSQL, planID, chunk)
	var item InsertPlanLogChunkRow
	if err := row.Scan(&item.PlanID, &item.ChunkID, &item.Chunk, &item.Size, &item.Start, &item.End); err != nil {
		return item, fmt.Errorf("query InsertPlanLogChunk: %w", err)
	}
	return item, nil
}

// InsertPlanLogChunkBatch implements Querier.InsertPlanLogChunkBatch.
func (q *DBQuerier) InsertPlanLogChunkBatch(batch genericBatch, planID *string, chunk []byte) {
	batch.Queue(insertPlanLogChunkSQL, planID, chunk)
}

// InsertPlanLogChunkScan implements Querier.InsertPlanLogChunkScan.
func (q *DBQuerier) InsertPlanLogChunkScan(results pgx.BatchResults) (InsertPlanLogChunkRow, error) {
	row := results.QueryRow()
	var item InsertPlanLogChunkRow
	if err := row.Scan(&item.PlanID, &item.ChunkID, &item.Chunk, &item.Size, &item.Start, &item.End); err != nil {
		return item, fmt.Errorf("scan InsertPlanLogChunkBatch row: %w", err)
	}
	return item, nil
}

const findPlanLogChunksSQL = `SELECT string_agg(chunk, '')
FROM (
    SELECT plan_id, chunk
    FROM plan_logs
    WHERE plan_id = $1
    ORDER BY chunk_id
) c
GROUP BY plan_id
;`

// FindPlanLogChunks implements Querier.FindPlanLogChunks.
func (q *DBQuerier) FindPlanLogChunks(ctx context.Context, planID *string) ([]byte, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindPlanLogChunks")
	row := q.conn.QueryRow(ctx, findPlanLogChunksSQL, planID)
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("query FindPlanLogChunks: %w", err)
	}
	return item, nil
}

// FindPlanLogChunksBatch implements Querier.FindPlanLogChunksBatch.
func (q *DBQuerier) FindPlanLogChunksBatch(batch genericBatch, planID *string) {
	batch.Queue(findPlanLogChunksSQL, planID)
}

// FindPlanLogChunksScan implements Querier.FindPlanLogChunksScan.
func (q *DBQuerier) FindPlanLogChunksScan(results pgx.BatchResults) ([]byte, error) {
	row := results.QueryRow()
	item := []byte{}
	if err := row.Scan(&item); err != nil {
		return item, fmt.Errorf("scan FindPlanLogChunksBatch row: %w", err)
	}
	return item, nil
}
