// Code generated by pggen. DO NOT EDIT.

package sql

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
	"time"
)

const findOrganizationByNameSQL = `SELECT * FROM organizations WHERE name = $1;`

type FindOrganizationByNameRow struct {
	OrganizationID  string    `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            string    `json:"name"`
	SessionRemember int32     `json:"session_remember"`
	SessionTimeout  int32     `json:"session_timeout"`
}

// FindOrganizationByName implements Querier.FindOrganizationByName.
func (q *DBQuerier) FindOrganizationByName(ctx context.Context, name string) (FindOrganizationByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindOrganizationByName")
	row := q.conn.QueryRow(ctx, findOrganizationByNameSQL, name)
	var item FindOrganizationByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query FindOrganizationByName: %w", err)
	}
	return item, nil
}

// FindOrganizationByNameBatch implements Querier.FindOrganizationByNameBatch.
func (q *DBQuerier) FindOrganizationByNameBatch(batch genericBatch, name string) {
	batch.Queue(findOrganizationByNameSQL, name)
}

// FindOrganizationByNameScan implements Querier.FindOrganizationByNameScan.
func (q *DBQuerier) FindOrganizationByNameScan(results pgx.BatchResults) (FindOrganizationByNameRow, error) {
	row := results.QueryRow()
	var item FindOrganizationByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan FindOrganizationByNameBatch row: %w", err)
	}
	return item, nil
}

const findOrganizationByNameForUpdateSQL = `SELECT *
FROM organizations
WHERE name = $1
FOR UPDATE
;`

type FindOrganizationByNameForUpdateRow struct {
	OrganizationID  *string   `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            *string   `json:"name"`
	SessionRemember *int32    `json:"session_remember"`
	SessionTimeout  *int32    `json:"session_timeout"`
}

// FindOrganizationByNameForUpdate implements Querier.FindOrganizationByNameForUpdate.
func (q *DBQuerier) FindOrganizationByNameForUpdate(ctx context.Context, name string) (FindOrganizationByNameForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindOrganizationByNameForUpdate")
	row := q.conn.QueryRow(ctx, findOrganizationByNameForUpdateSQL, name)
	var item FindOrganizationByNameForUpdateRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query FindOrganizationByNameForUpdate: %w", err)
	}
	return item, nil
}

// FindOrganizationByNameForUpdateBatch implements Querier.FindOrganizationByNameForUpdateBatch.
func (q *DBQuerier) FindOrganizationByNameForUpdateBatch(batch genericBatch, name string) {
	batch.Queue(findOrganizationByNameForUpdateSQL, name)
}

// FindOrganizationByNameForUpdateScan implements Querier.FindOrganizationByNameForUpdateScan.
func (q *DBQuerier) FindOrganizationByNameForUpdateScan(results pgx.BatchResults) (FindOrganizationByNameForUpdateRow, error) {
	row := results.QueryRow()
	var item FindOrganizationByNameForUpdateRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan FindOrganizationByNameForUpdateBatch row: %w", err)
	}
	return item, nil
}

const findOrganizationsSQL = `SELECT *
FROM organizations
LIMIT $1 OFFSET $2;`

type FindOrganizationsRow struct {
	OrganizationID  *string   `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            *string   `json:"name"`
	SessionRemember *int32    `json:"session_remember"`
	SessionTimeout  *int32    `json:"session_timeout"`
}

// FindOrganizations implements Querier.FindOrganizations.
func (q *DBQuerier) FindOrganizations(ctx context.Context, limit int, offset int) ([]FindOrganizationsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindOrganizations")
	rows, err := q.conn.Query(ctx, findOrganizationsSQL, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("query FindOrganizations: %w", err)
	}
	defer rows.Close()
	items := []FindOrganizationsRow{}
	for rows.Next() {
		var item FindOrganizationsRow
		if err := rows.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
			return nil, fmt.Errorf("scan FindOrganizations row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindOrganizations rows: %w", err)
	}
	return items, err
}

// FindOrganizationsBatch implements Querier.FindOrganizationsBatch.
func (q *DBQuerier) FindOrganizationsBatch(batch genericBatch, limit int, offset int) {
	batch.Queue(findOrganizationsSQL, limit, offset)
}

// FindOrganizationsScan implements Querier.FindOrganizationsScan.
func (q *DBQuerier) FindOrganizationsScan(results pgx.BatchResults) ([]FindOrganizationsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindOrganizationsBatch: %w", err)
	}
	defer rows.Close()
	items := []FindOrganizationsRow{}
	for rows.Next() {
		var item FindOrganizationsRow
		if err := rows.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
			return nil, fmt.Errorf("scan FindOrganizationsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindOrganizationsBatch rows: %w", err)
	}
	return items, err
}

const countOrganizationsSQL = `SELECT count(*)
FROM organizations;`

// CountOrganizations implements Querier.CountOrganizations.
func (q *DBQuerier) CountOrganizations(ctx context.Context) (*int, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CountOrganizations")
	row := q.conn.QueryRow(ctx, countOrganizationsSQL)
	var item int
	if err := row.Scan(&item); err != nil {
		return &item, fmt.Errorf("query CountOrganizations: %w", err)
	}
	return &item, nil
}

// CountOrganizationsBatch implements Querier.CountOrganizationsBatch.
func (q *DBQuerier) CountOrganizationsBatch(batch genericBatch) {
	batch.Queue(countOrganizationsSQL)
}

// CountOrganizationsScan implements Querier.CountOrganizationsScan.
func (q *DBQuerier) CountOrganizationsScan(results pgx.BatchResults) (*int, error) {
	row := results.QueryRow()
	var item int
	if err := row.Scan(&item); err != nil {
		return &item, fmt.Errorf("scan CountOrganizationsBatch row: %w", err)
	}
	return &item, nil
}

const insertOrganizationSQL = `INSERT INTO organizations (
    organization_id,
    created_at,
    updated_at,
    name,
    session_remember,
    session_timeout
) VALUES (
    $1,
    current_timestamp,
    current_timestamp,
    $2,
    $3,
    $4
)
RETURNING *;`

type InsertOrganizationParams struct {
	ID              string
	Name            string
	SessionRemember int32
	SessionTimeout  int32
}

type InsertOrganizationRow struct {
	OrganizationID  string    `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            string    `json:"name"`
	SessionRemember int32     `json:"session_remember"`
	SessionTimeout  int32     `json:"session_timeout"`
}

// InsertOrganization implements Querier.InsertOrganization.
func (q *DBQuerier) InsertOrganization(ctx context.Context, params InsertOrganizationParams) (InsertOrganizationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertOrganization")
	row := q.conn.QueryRow(ctx, insertOrganizationSQL, params.ID, params.Name, params.SessionRemember, params.SessionTimeout)
	var item InsertOrganizationRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query InsertOrganization: %w", err)
	}
	return item, nil
}

// InsertOrganizationBatch implements Querier.InsertOrganizationBatch.
func (q *DBQuerier) InsertOrganizationBatch(batch genericBatch, params InsertOrganizationParams) {
	batch.Queue(insertOrganizationSQL, params.ID, params.Name, params.SessionRemember, params.SessionTimeout)
}

// InsertOrganizationScan implements Querier.InsertOrganizationScan.
func (q *DBQuerier) InsertOrganizationScan(results pgx.BatchResults) (InsertOrganizationRow, error) {
	row := results.QueryRow()
	var item InsertOrganizationRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan InsertOrganizationBatch row: %w", err)
	}
	return item, nil
}

const updateOrganizationNameByNameSQL = `UPDATE organizations
SET
    name = $1,
    updated_at = current_timestamp
WHERE name = $2
RETURNING *;`

type UpdateOrganizationNameByNameRow struct {
	OrganizationID  string    `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            string    `json:"name"`
	SessionRemember int32     `json:"session_remember"`
	SessionTimeout  int32     `json:"session_timeout"`
}

// UpdateOrganizationNameByName implements Querier.UpdateOrganizationNameByName.
func (q *DBQuerier) UpdateOrganizationNameByName(ctx context.Context, newName string, name string) (UpdateOrganizationNameByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateOrganizationNameByName")
	row := q.conn.QueryRow(ctx, updateOrganizationNameByNameSQL, newName, name)
	var item UpdateOrganizationNameByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query UpdateOrganizationNameByName: %w", err)
	}
	return item, nil
}

// UpdateOrganizationNameByNameBatch implements Querier.UpdateOrganizationNameByNameBatch.
func (q *DBQuerier) UpdateOrganizationNameByNameBatch(batch genericBatch, newName string, name string) {
	batch.Queue(updateOrganizationNameByNameSQL, newName, name)
}

// UpdateOrganizationNameByNameScan implements Querier.UpdateOrganizationNameByNameScan.
func (q *DBQuerier) UpdateOrganizationNameByNameScan(results pgx.BatchResults) (UpdateOrganizationNameByNameRow, error) {
	row := results.QueryRow()
	var item UpdateOrganizationNameByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan UpdateOrganizationNameByNameBatch row: %w", err)
	}
	return item, nil
}

const updateOrganizationSessionRememberByNameSQL = `UPDATE organizations
SET
    session_remember = $1,
    updated_at = current_timestamp
WHERE name = $2
RETURNING *;`

type UpdateOrganizationSessionRememberByNameRow struct {
	OrganizationID  string    `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            string    `json:"name"`
	SessionRemember int32     `json:"session_remember"`
	SessionTimeout  int32     `json:"session_timeout"`
}

// UpdateOrganizationSessionRememberByName implements Querier.UpdateOrganizationSessionRememberByName.
func (q *DBQuerier) UpdateOrganizationSessionRememberByName(ctx context.Context, sessionRemember int32, name string) (UpdateOrganizationSessionRememberByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateOrganizationSessionRememberByName")
	row := q.conn.QueryRow(ctx, updateOrganizationSessionRememberByNameSQL, sessionRemember, name)
	var item UpdateOrganizationSessionRememberByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query UpdateOrganizationSessionRememberByName: %w", err)
	}
	return item, nil
}

// UpdateOrganizationSessionRememberByNameBatch implements Querier.UpdateOrganizationSessionRememberByNameBatch.
func (q *DBQuerier) UpdateOrganizationSessionRememberByNameBatch(batch genericBatch, sessionRemember int32, name string) {
	batch.Queue(updateOrganizationSessionRememberByNameSQL, sessionRemember, name)
}

// UpdateOrganizationSessionRememberByNameScan implements Querier.UpdateOrganizationSessionRememberByNameScan.
func (q *DBQuerier) UpdateOrganizationSessionRememberByNameScan(results pgx.BatchResults) (UpdateOrganizationSessionRememberByNameRow, error) {
	row := results.QueryRow()
	var item UpdateOrganizationSessionRememberByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan UpdateOrganizationSessionRememberByNameBatch row: %w", err)
	}
	return item, nil
}

const updateOrganizationSessionTimeoutByNameSQL = `UPDATE organizations
SET
    session_timeout = $1,
    updated_at = current_timestamp
WHERE name = $2
RETURNING *;`

type UpdateOrganizationSessionTimeoutByNameRow struct {
	OrganizationID  string    `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            string    `json:"name"`
	SessionRemember int32     `json:"session_remember"`
	SessionTimeout  int32     `json:"session_timeout"`
}

// UpdateOrganizationSessionTimeoutByName implements Querier.UpdateOrganizationSessionTimeoutByName.
func (q *DBQuerier) UpdateOrganizationSessionTimeoutByName(ctx context.Context, sessionTimeout int32, name string) (UpdateOrganizationSessionTimeoutByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateOrganizationSessionTimeoutByName")
	row := q.conn.QueryRow(ctx, updateOrganizationSessionTimeoutByNameSQL, sessionTimeout, name)
	var item UpdateOrganizationSessionTimeoutByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query UpdateOrganizationSessionTimeoutByName: %w", err)
	}
	return item, nil
}

// UpdateOrganizationSessionTimeoutByNameBatch implements Querier.UpdateOrganizationSessionTimeoutByNameBatch.
func (q *DBQuerier) UpdateOrganizationSessionTimeoutByNameBatch(batch genericBatch, sessionTimeout int32, name string) {
	batch.Queue(updateOrganizationSessionTimeoutByNameSQL, sessionTimeout, name)
}

// UpdateOrganizationSessionTimeoutByNameScan implements Querier.UpdateOrganizationSessionTimeoutByNameScan.
func (q *DBQuerier) UpdateOrganizationSessionTimeoutByNameScan(results pgx.BatchResults) (UpdateOrganizationSessionTimeoutByNameRow, error) {
	row := results.QueryRow()
	var item UpdateOrganizationSessionTimeoutByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan UpdateOrganizationSessionTimeoutByNameBatch row: %w", err)
	}
	return item, nil
}

const deleteOrganizationSQL = `DELETE
FROM organizations
WHERE name = $1;`

// DeleteOrganization implements Querier.DeleteOrganization.
func (q *DBQuerier) DeleteOrganization(ctx context.Context, name string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteOrganization")
	cmdTag, err := q.conn.Exec(ctx, deleteOrganizationSQL, name)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteOrganization: %w", err)
	}
	return cmdTag, err
}

// DeleteOrganizationBatch implements Querier.DeleteOrganizationBatch.
func (q *DBQuerier) DeleteOrganizationBatch(batch genericBatch, name string) {
	batch.Queue(deleteOrganizationSQL, name)
}

// DeleteOrganizationScan implements Querier.DeleteOrganizationScan.
func (q *DBQuerier) DeleteOrganizationScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteOrganizationBatch: %w", err)
	}
	return cmdTag, err
}
