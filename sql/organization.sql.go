// Code generated by pggen. DO NOT EDIT.

package sql

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
	"time"
)

const findOrganizationByNameSQL = `SELECT * FROM organizations WHERE name = $1;`

type FindOrganizationByNameRow struct {
	OrganizationID  *string   `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            *string   `json:"name"`
	SessionRemember *int32    `json:"session_remember"`
	SessionTimeout  *int32    `json:"session_timeout"`
}

func (s FindOrganizationByNameRow) GetOrganizationID() *string { return s.OrganizationID }
func (s FindOrganizationByNameRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindOrganizationByNameRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindOrganizationByNameRow) GetName() *string { return s.Name }
func (s FindOrganizationByNameRow) GetSessionRemember() *int32 { return s.SessionRemember }
func (s FindOrganizationByNameRow) GetSessionTimeout() *int32 { return s.SessionTimeout }


// FindOrganizationByName implements Querier.FindOrganizationByName.
func (q *DBQuerier) FindOrganizationByName(ctx context.Context, name *string) (FindOrganizationByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindOrganizationByName")
	row := q.conn.QueryRow(ctx, findOrganizationByNameSQL, name)
	var item FindOrganizationByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query FindOrganizationByName: %w", err)
	}
	return item, nil
}

// FindOrganizationByNameBatch implements Querier.FindOrganizationByNameBatch.
func (q *DBQuerier) FindOrganizationByNameBatch(batch genericBatch, name *string) {
	batch.Queue(findOrganizationByNameSQL, name)
}

// FindOrganizationByNameScan implements Querier.FindOrganizationByNameScan.
func (q *DBQuerier) FindOrganizationByNameScan(results pgx.BatchResults) (FindOrganizationByNameRow, error) {
	row := results.QueryRow()
	var item FindOrganizationByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan FindOrganizationByNameBatch row: %w", err)
	}
	return item, nil
}

const findOrganizationsSQL = `SELECT
    array_agg(organizations) AS organizations,
    count(*) OVER()          AS full_count
FROM organizations
LIMIT $1 OFFSET $2;`

type FindOrganizationsRow struct {
	Organizations []Organizations `json:"organizations"`
	FullCount     *int            `json:"full_count"`
}

func (s FindOrganizationsRow) GetOrganizations() []Organizations { return s.Organizations }
func (s FindOrganizationsRow) GetFullCount() *int { return s.FullCount }


// FindOrganizations implements Querier.FindOrganizations.
func (q *DBQuerier) FindOrganizations(ctx context.Context, limit int, offset int) (FindOrganizationsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindOrganizations")
	row := q.conn.QueryRow(ctx, findOrganizationsSQL, limit, offset)
	var item FindOrganizationsRow
	organizationsArray := q.types.newOrganizationsArray()
	if err := row.Scan(organizationsArray, &item.FullCount); err != nil {
		return item, fmt.Errorf("query FindOrganizations: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindOrganizations row: %w", err)
	}
	return item, nil
}

// FindOrganizationsBatch implements Querier.FindOrganizationsBatch.
func (q *DBQuerier) FindOrganizationsBatch(batch genericBatch, limit int, offset int) {
	batch.Queue(findOrganizationsSQL, limit, offset)
}

// FindOrganizationsScan implements Querier.FindOrganizationsScan.
func (q *DBQuerier) FindOrganizationsScan(results pgx.BatchResults) (FindOrganizationsRow, error) {
	row := results.QueryRow()
	var item FindOrganizationsRow
	organizationsArray := q.types.newOrganizationsArray()
	if err := row.Scan(organizationsArray, &item.FullCount); err != nil {
		return item, fmt.Errorf("scan FindOrganizationsBatch row: %w", err)
	}
	if err := organizationsArray.AssignTo(&item.Organizations); err != nil {
		return item, fmt.Errorf("assign FindOrganizations row: %w", err)
	}
	return item, nil
}

const insertOrganizationSQL = `INSERT INTO organizations (
    organization_id,
    created_at,
    updated_at,
    name,
    session_remember,
    session_timeout
) VALUES (
    $1,
    NOW(),
    NOW(),
    $2,
    $3,
    $4
)
RETURNING *;`

type InsertOrganizationParams struct {
	ID              *string
	Name            *string
	SessionRemember int32
	SessionTimeout  int32
}

type InsertOrganizationRow struct {
	OrganizationID  *string   `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            *string   `json:"name"`
	SessionRemember *int32    `json:"session_remember"`
	SessionTimeout  *int32    `json:"session_timeout"`
}

func (s InsertOrganizationRow) GetOrganizationID() *string { return s.OrganizationID }
func (s InsertOrganizationRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s InsertOrganizationRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s InsertOrganizationRow) GetName() *string { return s.Name }
func (s InsertOrganizationRow) GetSessionRemember() *int32 { return s.SessionRemember }
func (s InsertOrganizationRow) GetSessionTimeout() *int32 { return s.SessionTimeout }


// InsertOrganization implements Querier.InsertOrganization.
func (q *DBQuerier) InsertOrganization(ctx context.Context, params InsertOrganizationParams) (InsertOrganizationRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertOrganization")
	row := q.conn.QueryRow(ctx, insertOrganizationSQL, params.ID, params.Name, params.SessionRemember, params.SessionTimeout)
	var item InsertOrganizationRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query InsertOrganization: %w", err)
	}
	return item, nil
}

// InsertOrganizationBatch implements Querier.InsertOrganizationBatch.
func (q *DBQuerier) InsertOrganizationBatch(batch genericBatch, params InsertOrganizationParams) {
	batch.Queue(insertOrganizationSQL, params.ID, params.Name, params.SessionRemember, params.SessionTimeout)
}

// InsertOrganizationScan implements Querier.InsertOrganizationScan.
func (q *DBQuerier) InsertOrganizationScan(results pgx.BatchResults) (InsertOrganizationRow, error) {
	row := results.QueryRow()
	var item InsertOrganizationRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan InsertOrganizationBatch row: %w", err)
	}
	return item, nil
}

const updateOrganizationNameByNameSQL = `UPDATE organizations
SET
    name = $1,
    updated_at = NOW()
WHERE name = $2
RETURNING *;`

type UpdateOrganizationNameByNameRow struct {
	OrganizationID  *string   `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            *string   `json:"name"`
	SessionRemember *int32    `json:"session_remember"`
	SessionTimeout  *int32    `json:"session_timeout"`
}

func (s UpdateOrganizationNameByNameRow) GetOrganizationID() *string { return s.OrganizationID }
func (s UpdateOrganizationNameByNameRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s UpdateOrganizationNameByNameRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s UpdateOrganizationNameByNameRow) GetName() *string { return s.Name }
func (s UpdateOrganizationNameByNameRow) GetSessionRemember() *int32 { return s.SessionRemember }
func (s UpdateOrganizationNameByNameRow) GetSessionTimeout() *int32 { return s.SessionTimeout }


// UpdateOrganizationNameByName implements Querier.UpdateOrganizationNameByName.
func (q *DBQuerier) UpdateOrganizationNameByName(ctx context.Context, newName *string, name *string) (UpdateOrganizationNameByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateOrganizationNameByName")
	row := q.conn.QueryRow(ctx, updateOrganizationNameByNameSQL, newName, name)
	var item UpdateOrganizationNameByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query UpdateOrganizationNameByName: %w", err)
	}
	return item, nil
}

// UpdateOrganizationNameByNameBatch implements Querier.UpdateOrganizationNameByNameBatch.
func (q *DBQuerier) UpdateOrganizationNameByNameBatch(batch genericBatch, newName *string, name *string) {
	batch.Queue(updateOrganizationNameByNameSQL, newName, name)
}

// UpdateOrganizationNameByNameScan implements Querier.UpdateOrganizationNameByNameScan.
func (q *DBQuerier) UpdateOrganizationNameByNameScan(results pgx.BatchResults) (UpdateOrganizationNameByNameRow, error) {
	row := results.QueryRow()
	var item UpdateOrganizationNameByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan UpdateOrganizationNameByNameBatch row: %w", err)
	}
	return item, nil
}

const updateOrganizationSessionRememberByNameSQL = `UPDATE organizations
SET
    session_remember = $1,
    updated_at = NOW()
WHERE name = $2
RETURNING *;`

type UpdateOrganizationSessionRememberByNameRow struct {
	OrganizationID  *string   `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            *string   `json:"name"`
	SessionRemember *int32    `json:"session_remember"`
	SessionTimeout  *int32    `json:"session_timeout"`
}

func (s UpdateOrganizationSessionRememberByNameRow) GetOrganizationID() *string { return s.OrganizationID }
func (s UpdateOrganizationSessionRememberByNameRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s UpdateOrganizationSessionRememberByNameRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s UpdateOrganizationSessionRememberByNameRow) GetName() *string { return s.Name }
func (s UpdateOrganizationSessionRememberByNameRow) GetSessionRemember() *int32 { return s.SessionRemember }
func (s UpdateOrganizationSessionRememberByNameRow) GetSessionTimeout() *int32 { return s.SessionTimeout }


// UpdateOrganizationSessionRememberByName implements Querier.UpdateOrganizationSessionRememberByName.
func (q *DBQuerier) UpdateOrganizationSessionRememberByName(ctx context.Context, sessionRemember int32, name *string) (UpdateOrganizationSessionRememberByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateOrganizationSessionRememberByName")
	row := q.conn.QueryRow(ctx, updateOrganizationSessionRememberByNameSQL, sessionRemember, name)
	var item UpdateOrganizationSessionRememberByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query UpdateOrganizationSessionRememberByName: %w", err)
	}
	return item, nil
}

// UpdateOrganizationSessionRememberByNameBatch implements Querier.UpdateOrganizationSessionRememberByNameBatch.
func (q *DBQuerier) UpdateOrganizationSessionRememberByNameBatch(batch genericBatch, sessionRemember int32, name *string) {
	batch.Queue(updateOrganizationSessionRememberByNameSQL, sessionRemember, name)
}

// UpdateOrganizationSessionRememberByNameScan implements Querier.UpdateOrganizationSessionRememberByNameScan.
func (q *DBQuerier) UpdateOrganizationSessionRememberByNameScan(results pgx.BatchResults) (UpdateOrganizationSessionRememberByNameRow, error) {
	row := results.QueryRow()
	var item UpdateOrganizationSessionRememberByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan UpdateOrganizationSessionRememberByNameBatch row: %w", err)
	}
	return item, nil
}

const updateOrganizationSessionTimeoutByNameSQL = `UPDATE organizations
SET
    session_timeout = $1,
    updated_at = NOW()
WHERE name = $2
RETURNING *;`

type UpdateOrganizationSessionTimeoutByNameRow struct {
	OrganizationID  *string   `json:"organization_id"`
	CreatedAt       time.Time `json:"created_at"`
	UpdatedAt       time.Time `json:"updated_at"`
	Name            *string   `json:"name"`
	SessionRemember *int32    `json:"session_remember"`
	SessionTimeout  *int32    `json:"session_timeout"`
}

func (s UpdateOrganizationSessionTimeoutByNameRow) GetOrganizationID() *string { return s.OrganizationID }
func (s UpdateOrganizationSessionTimeoutByNameRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s UpdateOrganizationSessionTimeoutByNameRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s UpdateOrganizationSessionTimeoutByNameRow) GetName() *string { return s.Name }
func (s UpdateOrganizationSessionTimeoutByNameRow) GetSessionRemember() *int32 { return s.SessionRemember }
func (s UpdateOrganizationSessionTimeoutByNameRow) GetSessionTimeout() *int32 { return s.SessionTimeout }


// UpdateOrganizationSessionTimeoutByName implements Querier.UpdateOrganizationSessionTimeoutByName.
func (q *DBQuerier) UpdateOrganizationSessionTimeoutByName(ctx context.Context, sessionTimeout int32, name *string) (UpdateOrganizationSessionTimeoutByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateOrganizationSessionTimeoutByName")
	row := q.conn.QueryRow(ctx, updateOrganizationSessionTimeoutByNameSQL, sessionTimeout, name)
	var item UpdateOrganizationSessionTimeoutByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("query UpdateOrganizationSessionTimeoutByName: %w", err)
	}
	return item, nil
}

// UpdateOrganizationSessionTimeoutByNameBatch implements Querier.UpdateOrganizationSessionTimeoutByNameBatch.
func (q *DBQuerier) UpdateOrganizationSessionTimeoutByNameBatch(batch genericBatch, sessionTimeout int32, name *string) {
	batch.Queue(updateOrganizationSessionTimeoutByNameSQL, sessionTimeout, name)
}

// UpdateOrganizationSessionTimeoutByNameScan implements Querier.UpdateOrganizationSessionTimeoutByNameScan.
func (q *DBQuerier) UpdateOrganizationSessionTimeoutByNameScan(results pgx.BatchResults) (UpdateOrganizationSessionTimeoutByNameRow, error) {
	row := results.QueryRow()
	var item UpdateOrganizationSessionTimeoutByNameRow
	if err := row.Scan(&item.OrganizationID, &item.CreatedAt, &item.UpdatedAt, &item.Name, &item.SessionRemember, &item.SessionTimeout); err != nil {
		return item, fmt.Errorf("scan UpdateOrganizationSessionTimeoutByNameBatch row: %w", err)
	}
	return item, nil
}

const deleteOrganizationSQL = `DELETE
FROM organizations
WHERE name = $1;`

// DeleteOrganization implements Querier.DeleteOrganization.
func (q *DBQuerier) DeleteOrganization(ctx context.Context, name *string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteOrganization")
	cmdTag, err := q.conn.Exec(ctx, deleteOrganizationSQL, name)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteOrganization: %w", err)
	}
	return cmdTag, err
}

// DeleteOrganizationBatch implements Querier.DeleteOrganizationBatch.
func (q *DBQuerier) DeleteOrganizationBatch(batch genericBatch, name *string) {
	batch.Queue(deleteOrganizationSQL, name)
}

// DeleteOrganizationScan implements Querier.DeleteOrganizationScan.
func (q *DBQuerier) DeleteOrganizationScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteOrganizationBatch: %w", err)
	}
	return cmdTag, err
}
