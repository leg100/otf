// Code generated by pggen. DO NOT EDIT.

package sql

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
	"time"
)

const insertRunSQL = `INSERT INTO runs (
    run_id,
    plan_id,
    apply_id,
    created_at,
    updated_at,
    is_destroy,
    position_in_queue,
    refresh,
    refresh_only,
    status,
    plan_status,
    apply_status,
    replace_addrs,
    target_addrs,
    configuration_version_id,
    workspace_id
) VALUES (
    $1,
    $2,
    $3,
    current_timestamp,
    current_timestamp,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14
)
RETURNING *;`

type InsertRunParams struct {
	ID                     string
	PlanID                 string
	ApplyID                string
	IsDestroy              bool
	PositionInQueue        int32
	Refresh                bool
	RefreshOnly            bool
	Status                 string
	PlanStatus             string
	ApplyStatus            string
	ReplaceAddrs           []string
	TargetAddrs            []string
	ConfigurationVersionID string
	WorkspaceID            string
}

type InsertRunRow struct {
	RunID                       string    `json:"run_id"`
	PlanID                      string    `json:"plan_id"`
	ApplyID                     string    `json:"apply_id"`
	CreatedAt                   time.Time `json:"created_at"`
	UpdatedAt                   time.Time `json:"updated_at"`
	IsDestroy                   bool      `json:"is_destroy"`
	PositionInQueue             int32     `json:"position_in_queue"`
	Refresh                     bool      `json:"refresh"`
	RefreshOnly                 bool      `json:"refresh_only"`
	Status                      string    `json:"status"`
	ReplaceAddrs                []string  `json:"replace_addrs"`
	TargetAddrs                 []string  `json:"target_addrs"`
	PlanStatus                  string    `json:"plan_status"`
	PlanBin                     []byte    `json:"plan_bin"`
	PlanJson                    []byte    `json:"plan_json"`
	PlannedResourceAdditions    *int32    `json:"planned_resource_additions"`
	PlannedResourceChanges      *int32    `json:"planned_resource_changes"`
	PlannedResourceDestructions *int32    `json:"planned_resource_destructions"`
	ApplyStatus                 string    `json:"apply_status"`
	AppliedResourceAdditions    *int32    `json:"applied_resource_additions"`
	AppliedResourceChanges      *int32    `json:"applied_resource_changes"`
	AppliedResourceDestructions *int32    `json:"applied_resource_destructions"`
	WorkspaceID                 string    `json:"workspace_id"`
	ConfigurationVersionID      string    `json:"configuration_version_id"`
}

func (s InsertRunRow) GetRunID() string { return s.RunID }
func (s InsertRunRow) GetPlanID() string { return s.PlanID }
func (s InsertRunRow) GetApplyID() string { return s.ApplyID }
func (s InsertRunRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s InsertRunRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s InsertRunRow) GetIsDestroy() bool { return s.IsDestroy }
func (s InsertRunRow) GetPositionInQueue() int32 { return s.PositionInQueue }
func (s InsertRunRow) GetRefresh() bool { return s.Refresh }
func (s InsertRunRow) GetRefreshOnly() bool { return s.RefreshOnly }
func (s InsertRunRow) GetStatus() string { return s.Status }
func (s InsertRunRow) GetReplaceAddrs() []string { return s.ReplaceAddrs }
func (s InsertRunRow) GetTargetAddrs() []string { return s.TargetAddrs }
func (s InsertRunRow) GetPlanStatus() string { return s.PlanStatus }
func (s InsertRunRow) GetPlanBin() []byte { return s.PlanBin }
func (s InsertRunRow) GetPlanJson() []byte { return s.PlanJson }
func (s InsertRunRow) GetPlannedResourceAdditions() *int32 { return s.PlannedResourceAdditions }
func (s InsertRunRow) GetPlannedResourceChanges() *int32 { return s.PlannedResourceChanges }
func (s InsertRunRow) GetPlannedResourceDestructions() *int32 { return s.PlannedResourceDestructions }
func (s InsertRunRow) GetApplyStatus() string { return s.ApplyStatus }
func (s InsertRunRow) GetAppliedResourceAdditions() *int32 { return s.AppliedResourceAdditions }
func (s InsertRunRow) GetAppliedResourceChanges() *int32 { return s.AppliedResourceChanges }
func (s InsertRunRow) GetAppliedResourceDestructions() *int32 { return s.AppliedResourceDestructions }
func (s InsertRunRow) GetWorkspaceID() string { return s.WorkspaceID }
func (s InsertRunRow) GetConfigurationVersionID() string { return s.ConfigurationVersionID }


// InsertRun implements Querier.InsertRun.
func (q *DBQuerier) InsertRun(ctx context.Context, params InsertRunParams) (InsertRunRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertRun")
	row := q.conn.QueryRow(ctx, insertRunSQL, params.ID, params.PlanID, params.ApplyID, params.IsDestroy, params.PositionInQueue, params.Refresh, params.RefreshOnly, params.Status, params.PlanStatus, params.ApplyStatus, params.ReplaceAddrs, params.TargetAddrs, params.ConfigurationVersionID, params.WorkspaceID)
	var item InsertRunRow
	if err := row.Scan(&item.RunID, &item.PlanID, &item.ApplyID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.ReplaceAddrs, &item.TargetAddrs, &item.PlanStatus, &item.PlanBin, &item.PlanJson, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.WorkspaceID, &item.ConfigurationVersionID); err != nil {
		return item, fmt.Errorf("query InsertRun: %w", err)
	}
	return item, nil
}

// InsertRunBatch implements Querier.InsertRunBatch.
func (q *DBQuerier) InsertRunBatch(batch genericBatch, params InsertRunParams) {
	batch.Queue(insertRunSQL, params.ID, params.PlanID, params.ApplyID, params.IsDestroy, params.PositionInQueue, params.Refresh, params.RefreshOnly, params.Status, params.PlanStatus, params.ApplyStatus, params.ReplaceAddrs, params.TargetAddrs, params.ConfigurationVersionID, params.WorkspaceID)
}

// InsertRunScan implements Querier.InsertRunScan.
func (q *DBQuerier) InsertRunScan(results pgx.BatchResults) (InsertRunRow, error) {
	row := results.QueryRow()
	var item InsertRunRow
	if err := row.Scan(&item.RunID, &item.PlanID, &item.ApplyID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.ReplaceAddrs, &item.TargetAddrs, &item.PlanStatus, &item.PlanBin, &item.PlanJson, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.WorkspaceID, &item.ConfigurationVersionID); err != nil {
		return item, fmt.Errorf("scan InsertRunBatch row: %w", err)
	}
	return item, nil
}

const insertRunStatusTimestampSQL = `INSERT INTO run_status_timestamps (
    run_id,
    status,
    timestamp
) VALUES (
    $1,
    $2,
    current_timestamp
)
RETURNING *;`

type InsertRunStatusTimestampRow struct {
	RunID     string    `json:"run_id"`
	Status    string    `json:"status"`
	Timestamp time.Time `json:"timestamp"`
}

func (s InsertRunStatusTimestampRow) GetRunID() string { return s.RunID }
func (s InsertRunStatusTimestampRow) GetStatus() string { return s.Status }
func (s InsertRunStatusTimestampRow) GetTimestamp() time.Time { return s.Timestamp }


// InsertRunStatusTimestamp implements Querier.InsertRunStatusTimestamp.
func (q *DBQuerier) InsertRunStatusTimestamp(ctx context.Context, id string, status string) (InsertRunStatusTimestampRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertRunStatusTimestamp")
	row := q.conn.QueryRow(ctx, insertRunStatusTimestampSQL, id, status)
	var item InsertRunStatusTimestampRow
	if err := row.Scan(&item.RunID, &item.Status, &item.Timestamp); err != nil {
		return item, fmt.Errorf("query InsertRunStatusTimestamp: %w", err)
	}
	return item, nil
}

// InsertRunStatusTimestampBatch implements Querier.InsertRunStatusTimestampBatch.
func (q *DBQuerier) InsertRunStatusTimestampBatch(batch genericBatch, id string, status string) {
	batch.Queue(insertRunStatusTimestampSQL, id, status)
}

// InsertRunStatusTimestampScan implements Querier.InsertRunStatusTimestampScan.
func (q *DBQuerier) InsertRunStatusTimestampScan(results pgx.BatchResults) (InsertRunStatusTimestampRow, error) {
	row := results.QueryRow()
	var item InsertRunStatusTimestampRow
	if err := row.Scan(&item.RunID, &item.Status, &item.Timestamp); err != nil {
		return item, fmt.Errorf("scan InsertRunStatusTimestampBatch row: %w", err)
	}
	return item, nil
}

const findRunsByWorkspaceIDSQL = `SELECT
    runs.run_id,
    runs.created_at,
    runs.updated_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.status,
    runs.plan_status,
    runs.planned_resource_additions,
    runs.planned_resource_changes,
    runs.planned_resource_destructions,
    runs.apply_status,
    runs.applied_resource_additions,
    runs.applied_resource_changes,
    runs.applied_resource_destructions,
    runs.replace_addrs,
    runs.target_addrs,
    (configuration_versions.*)::"configuration_versions" AS configuration_version,
    (workspaces.*)::"workspaces" AS workspace,
    (
        SELECT array_agg(rst.*) AS run_status_timestamps
        FROM run_status_timestamps rst
        WHERE rst.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamps,
    (
        SELECT array_agg(pst.*) AS plan_status_timestamps
        FROM plan_status_timestamps pst
        WHERE pst.run_id = runs.run_id
        GROUP BY run_id
    ) AS plan_status_timestamps,
    (
        SELECT array_agg(ast.*) AS apply_status_timestamps
        FROM apply_status_timestamps ast
        WHERE ast.run_id = runs.run_id
        GROUP BY run_id
    ) AS apply_status_timestamps,
    count(*) OVER() AS full_count
FROM runs
JOIN configuration_versions USING(workspace_id)
JOIN workspaces USING(workspace_id)
WHERE workspaces.workspace_id = $1
LIMIT $2 OFFSET $3
;`

type FindRunsByWorkspaceIDParams struct {
	WorkspaceID string
	Limit       int
	Offset      int
}

type FindRunsByWorkspaceIDRow struct {
	RunID                       *string                 `json:"run_id"`
	CreatedAt                   time.Time               `json:"created_at"`
	UpdatedAt                   time.Time               `json:"updated_at"`
	IsDestroy                   *bool                   `json:"is_destroy"`
	PositionInQueue             *int32                  `json:"position_in_queue"`
	Refresh                     *bool                   `json:"refresh"`
	RefreshOnly                 *bool                   `json:"refresh_only"`
	Status                      *string                 `json:"status"`
	PlanStatus                  *string                 `json:"plan_status"`
	PlannedResourceAdditions    *int32                  `json:"planned_resource_additions"`
	PlannedResourceChanges      *int32                  `json:"planned_resource_changes"`
	PlannedResourceDestructions *int32                  `json:"planned_resource_destructions"`
	ApplyStatus                 *string                 `json:"apply_status"`
	AppliedResourceAdditions    *int32                  `json:"applied_resource_additions"`
	AppliedResourceChanges      *int32                  `json:"applied_resource_changes"`
	AppliedResourceDestructions *int32                  `json:"applied_resource_destructions"`
	ReplaceAddrs                []string                `json:"replace_addrs"`
	TargetAddrs                 []string                `json:"target_addrs"`
	ConfigurationVersion        ConfigurationVersions   `json:"configuration_version"`
	Workspace                   Workspaces              `json:"workspace"`
	RunStatusTimestamps         []RunStatusTimestamps   `json:"run_status_timestamps"`
	PlanStatusTimestamps        []PlanStatusTimestamps  `json:"plan_status_timestamps"`
	ApplyStatusTimestamps       []ApplyStatusTimestamps `json:"apply_status_timestamps"`
	FullCount                   *int                    `json:"full_count"`
}

func (s FindRunsByWorkspaceIDRow) GetRunID() *string { return s.RunID }
func (s FindRunsByWorkspaceIDRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindRunsByWorkspaceIDRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindRunsByWorkspaceIDRow) GetIsDestroy() *bool { return s.IsDestroy }
func (s FindRunsByWorkspaceIDRow) GetPositionInQueue() *int32 { return s.PositionInQueue }
func (s FindRunsByWorkspaceIDRow) GetRefresh() *bool { return s.Refresh }
func (s FindRunsByWorkspaceIDRow) GetRefreshOnly() *bool { return s.RefreshOnly }
func (s FindRunsByWorkspaceIDRow) GetStatus() *string { return s.Status }
func (s FindRunsByWorkspaceIDRow) GetPlanStatus() *string { return s.PlanStatus }
func (s FindRunsByWorkspaceIDRow) GetPlannedResourceAdditions() *int32 { return s.PlannedResourceAdditions }
func (s FindRunsByWorkspaceIDRow) GetPlannedResourceChanges() *int32 { return s.PlannedResourceChanges }
func (s FindRunsByWorkspaceIDRow) GetPlannedResourceDestructions() *int32 { return s.PlannedResourceDestructions }
func (s FindRunsByWorkspaceIDRow) GetApplyStatus() *string { return s.ApplyStatus }
func (s FindRunsByWorkspaceIDRow) GetAppliedResourceAdditions() *int32 { return s.AppliedResourceAdditions }
func (s FindRunsByWorkspaceIDRow) GetAppliedResourceChanges() *int32 { return s.AppliedResourceChanges }
func (s FindRunsByWorkspaceIDRow) GetAppliedResourceDestructions() *int32 { return s.AppliedResourceDestructions }
func (s FindRunsByWorkspaceIDRow) GetReplaceAddrs() []string { return s.ReplaceAddrs }
func (s FindRunsByWorkspaceIDRow) GetTargetAddrs() []string { return s.TargetAddrs }
func (s FindRunsByWorkspaceIDRow) GetConfigurationVersion() ConfigurationVersions { return s.ConfigurationVersion }
func (s FindRunsByWorkspaceIDRow) GetWorkspace() Workspaces { return s.Workspace }
func (s FindRunsByWorkspaceIDRow) GetRunStatusTimestamps() []RunStatusTimestamps { return s.RunStatusTimestamps }
func (s FindRunsByWorkspaceIDRow) GetPlanStatusTimestamps() []PlanStatusTimestamps { return s.PlanStatusTimestamps }
func (s FindRunsByWorkspaceIDRow) GetApplyStatusTimestamps() []ApplyStatusTimestamps { return s.ApplyStatusTimestamps }
func (s FindRunsByWorkspaceIDRow) GetFullCount() *int { return s.FullCount }


// FindRunsByWorkspaceID implements Querier.FindRunsByWorkspaceID.
func (q *DBQuerier) FindRunsByWorkspaceID(ctx context.Context, params FindRunsByWorkspaceIDParams) ([]FindRunsByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunsByWorkspaceID")
	rows, err := q.conn.Query(ctx, findRunsByWorkspaceIDSQL, params.WorkspaceID, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindRunsByWorkspaceID: %w", err)
	}
	defer rows.Close()
	items := []FindRunsByWorkspaceIDRow{}
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	for rows.Next() {
		var item FindRunsByWorkspaceIDRow
		if err := rows.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindRunsByWorkspaceID row: %w", err)
		}
		if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunsByWorkspaceID rows: %w", err)
	}
	return items, err
}

// FindRunsByWorkspaceIDBatch implements Querier.FindRunsByWorkspaceIDBatch.
func (q *DBQuerier) FindRunsByWorkspaceIDBatch(batch genericBatch, params FindRunsByWorkspaceIDParams) {
	batch.Queue(findRunsByWorkspaceIDSQL, params.WorkspaceID, params.Limit, params.Offset)
}

// FindRunsByWorkspaceIDScan implements Querier.FindRunsByWorkspaceIDScan.
func (q *DBQuerier) FindRunsByWorkspaceIDScan(results pgx.BatchResults) ([]FindRunsByWorkspaceIDRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindRunsByWorkspaceIDBatch: %w", err)
	}
	defer rows.Close()
	items := []FindRunsByWorkspaceIDRow{}
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	for rows.Next() {
		var item FindRunsByWorkspaceIDRow
		if err := rows.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindRunsByWorkspaceIDBatch row: %w", err)
		}
		if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceID row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunsByWorkspaceIDBatch rows: %w", err)
	}
	return items, err
}

const findRunsByWorkspaceNameSQL = `SELECT
    runs.run_id,
    runs.created_at,
    runs.updated_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.status,
    runs.plan_status,
    runs.planned_resource_additions,
    runs.planned_resource_changes,
    runs.planned_resource_destructions,
    runs.apply_status,
    runs.applied_resource_additions,
    runs.applied_resource_changes,
    runs.applied_resource_destructions,
    runs.replace_addrs,
    runs.target_addrs,
    (configuration_versions.*)::"configuration_versions" AS configuration_version,
    (workspaces.*)::"workspaces" AS workspace,
    (
        SELECT array_agg(rst.*) AS run_status_timestamps
        FROM run_status_timestamps rst
        WHERE rst.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamps,
    (
        SELECT array_agg(pst.*) AS plan_status_timestamps
        FROM plan_status_timestamps pst
        WHERE pst.run_id = runs.run_id
        GROUP BY run_id
    ) AS plan_status_timestamps,
    (
        SELECT array_agg(ast.*) AS apply_status_timestamps
        FROM apply_status_timestamps ast
        WHERE ast.run_id = runs.run_id
        GROUP BY run_id
    ) AS apply_status_timestamps,
    count(*) OVER() AS full_count
FROM runs
JOIN configuration_versions USING(workspace_id)
JOIN workspaces USING(workspace_id)
JOIN organizations USING(organization_id)
WHERE workspaces.name = $1
AND organizations.name = $2
LIMIT $3 OFFSET $4
;`

type FindRunsByWorkspaceNameParams struct {
	WorkspaceName    string
	OrganizationName string
	Limit            int
	Offset           int
}

type FindRunsByWorkspaceNameRow struct {
	RunID                       *string                 `json:"run_id"`
	CreatedAt                   time.Time               `json:"created_at"`
	UpdatedAt                   time.Time               `json:"updated_at"`
	IsDestroy                   *bool                   `json:"is_destroy"`
	PositionInQueue             *int32                  `json:"position_in_queue"`
	Refresh                     *bool                   `json:"refresh"`
	RefreshOnly                 *bool                   `json:"refresh_only"`
	Status                      *string                 `json:"status"`
	PlanStatus                  *string                 `json:"plan_status"`
	PlannedResourceAdditions    *int32                  `json:"planned_resource_additions"`
	PlannedResourceChanges      *int32                  `json:"planned_resource_changes"`
	PlannedResourceDestructions *int32                  `json:"planned_resource_destructions"`
	ApplyStatus                 *string                 `json:"apply_status"`
	AppliedResourceAdditions    *int32                  `json:"applied_resource_additions"`
	AppliedResourceChanges      *int32                  `json:"applied_resource_changes"`
	AppliedResourceDestructions *int32                  `json:"applied_resource_destructions"`
	ReplaceAddrs                []string                `json:"replace_addrs"`
	TargetAddrs                 []string                `json:"target_addrs"`
	ConfigurationVersion        ConfigurationVersions   `json:"configuration_version"`
	Workspace                   Workspaces              `json:"workspace"`
	RunStatusTimestamps         []RunStatusTimestamps   `json:"run_status_timestamps"`
	PlanStatusTimestamps        []PlanStatusTimestamps  `json:"plan_status_timestamps"`
	ApplyStatusTimestamps       []ApplyStatusTimestamps `json:"apply_status_timestamps"`
	FullCount                   *int                    `json:"full_count"`
}

func (s FindRunsByWorkspaceNameRow) GetRunID() *string { return s.RunID }
func (s FindRunsByWorkspaceNameRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindRunsByWorkspaceNameRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindRunsByWorkspaceNameRow) GetIsDestroy() *bool { return s.IsDestroy }
func (s FindRunsByWorkspaceNameRow) GetPositionInQueue() *int32 { return s.PositionInQueue }
func (s FindRunsByWorkspaceNameRow) GetRefresh() *bool { return s.Refresh }
func (s FindRunsByWorkspaceNameRow) GetRefreshOnly() *bool { return s.RefreshOnly }
func (s FindRunsByWorkspaceNameRow) GetStatus() *string { return s.Status }
func (s FindRunsByWorkspaceNameRow) GetPlanStatus() *string { return s.PlanStatus }
func (s FindRunsByWorkspaceNameRow) GetPlannedResourceAdditions() *int32 { return s.PlannedResourceAdditions }
func (s FindRunsByWorkspaceNameRow) GetPlannedResourceChanges() *int32 { return s.PlannedResourceChanges }
func (s FindRunsByWorkspaceNameRow) GetPlannedResourceDestructions() *int32 { return s.PlannedResourceDestructions }
func (s FindRunsByWorkspaceNameRow) GetApplyStatus() *string { return s.ApplyStatus }
func (s FindRunsByWorkspaceNameRow) GetAppliedResourceAdditions() *int32 { return s.AppliedResourceAdditions }
func (s FindRunsByWorkspaceNameRow) GetAppliedResourceChanges() *int32 { return s.AppliedResourceChanges }
func (s FindRunsByWorkspaceNameRow) GetAppliedResourceDestructions() *int32 { return s.AppliedResourceDestructions }
func (s FindRunsByWorkspaceNameRow) GetReplaceAddrs() []string { return s.ReplaceAddrs }
func (s FindRunsByWorkspaceNameRow) GetTargetAddrs() []string { return s.TargetAddrs }
func (s FindRunsByWorkspaceNameRow) GetConfigurationVersion() ConfigurationVersions { return s.ConfigurationVersion }
func (s FindRunsByWorkspaceNameRow) GetWorkspace() Workspaces { return s.Workspace }
func (s FindRunsByWorkspaceNameRow) GetRunStatusTimestamps() []RunStatusTimestamps { return s.RunStatusTimestamps }
func (s FindRunsByWorkspaceNameRow) GetPlanStatusTimestamps() []PlanStatusTimestamps { return s.PlanStatusTimestamps }
func (s FindRunsByWorkspaceNameRow) GetApplyStatusTimestamps() []ApplyStatusTimestamps { return s.ApplyStatusTimestamps }
func (s FindRunsByWorkspaceNameRow) GetFullCount() *int { return s.FullCount }


// FindRunsByWorkspaceName implements Querier.FindRunsByWorkspaceName.
func (q *DBQuerier) FindRunsByWorkspaceName(ctx context.Context, params FindRunsByWorkspaceNameParams) ([]FindRunsByWorkspaceNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunsByWorkspaceName")
	rows, err := q.conn.Query(ctx, findRunsByWorkspaceNameSQL, params.WorkspaceName, params.OrganizationName, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindRunsByWorkspaceName: %w", err)
	}
	defer rows.Close()
	items := []FindRunsByWorkspaceNameRow{}
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	for rows.Next() {
		var item FindRunsByWorkspaceNameRow
		if err := rows.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindRunsByWorkspaceName row: %w", err)
		}
		if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunsByWorkspaceName rows: %w", err)
	}
	return items, err
}

// FindRunsByWorkspaceNameBatch implements Querier.FindRunsByWorkspaceNameBatch.
func (q *DBQuerier) FindRunsByWorkspaceNameBatch(batch genericBatch, params FindRunsByWorkspaceNameParams) {
	batch.Queue(findRunsByWorkspaceNameSQL, params.WorkspaceName, params.OrganizationName, params.Limit, params.Offset)
}

// FindRunsByWorkspaceNameScan implements Querier.FindRunsByWorkspaceNameScan.
func (q *DBQuerier) FindRunsByWorkspaceNameScan(results pgx.BatchResults) ([]FindRunsByWorkspaceNameRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindRunsByWorkspaceNameBatch: %w", err)
	}
	defer rows.Close()
	items := []FindRunsByWorkspaceNameRow{}
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	for rows.Next() {
		var item FindRunsByWorkspaceNameRow
		if err := rows.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindRunsByWorkspaceNameBatch row: %w", err)
		}
		if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByWorkspaceName row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunsByWorkspaceNameBatch rows: %w", err)
	}
	return items, err
}

const findRunsByStatusesSQL = `SELECT
    runs.run_id,
    runs.created_at,
    runs.updated_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.status,
    runs.plan_status,
    runs.planned_resource_additions,
    runs.planned_resource_changes,
    runs.planned_resource_destructions,
    runs.apply_status,
    runs.applied_resource_additions,
    runs.applied_resource_changes,
    runs.applied_resource_destructions,
    runs.replace_addrs,
    runs.target_addrs,
    (configuration_versions.*)::"configuration_versions" AS configuration_version,
    (workspaces.*)::"workspaces" AS workspace,
    (
        SELECT array_agg(rst.*) AS run_status_timestamps
        FROM run_status_timestamps rst
        WHERE rst.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamps,
    (
        SELECT array_agg(pst.*) AS plan_status_timestamps
        FROM plan_status_timestamps pst
        WHERE pst.run_id = runs.run_id
        GROUP BY run_id
    ) AS plan_status_timestamps,
    (
        SELECT array_agg(ast.*) AS apply_status_timestamps
        FROM apply_status_timestamps ast
        WHERE ast.run_id = runs.run_id
        GROUP BY run_id
    ) AS apply_status_timestamps,
    count(*) OVER() AS full_count
FROM runs
JOIN configuration_versions USING(workspace_id)
JOIN workspaces USING(workspace_id)
WHERE runs.status = ANY($1)
LIMIT $2 OFFSET $3
;`

type FindRunsByStatusesParams struct {
	Statuses []string
	Limit    int
	Offset   int
}

type FindRunsByStatusesRow struct {
	RunID                       *string                 `json:"run_id"`
	CreatedAt                   time.Time               `json:"created_at"`
	UpdatedAt                   time.Time               `json:"updated_at"`
	IsDestroy                   *bool                   `json:"is_destroy"`
	PositionInQueue             *int32                  `json:"position_in_queue"`
	Refresh                     *bool                   `json:"refresh"`
	RefreshOnly                 *bool                   `json:"refresh_only"`
	Status                      *string                 `json:"status"`
	PlanStatus                  *string                 `json:"plan_status"`
	PlannedResourceAdditions    *int32                  `json:"planned_resource_additions"`
	PlannedResourceChanges      *int32                  `json:"planned_resource_changes"`
	PlannedResourceDestructions *int32                  `json:"planned_resource_destructions"`
	ApplyStatus                 *string                 `json:"apply_status"`
	AppliedResourceAdditions    *int32                  `json:"applied_resource_additions"`
	AppliedResourceChanges      *int32                  `json:"applied_resource_changes"`
	AppliedResourceDestructions *int32                  `json:"applied_resource_destructions"`
	ReplaceAddrs                []string                `json:"replace_addrs"`
	TargetAddrs                 []string                `json:"target_addrs"`
	ConfigurationVersion        ConfigurationVersions   `json:"configuration_version"`
	Workspace                   Workspaces              `json:"workspace"`
	RunStatusTimestamps         []RunStatusTimestamps   `json:"run_status_timestamps"`
	PlanStatusTimestamps        []PlanStatusTimestamps  `json:"plan_status_timestamps"`
	ApplyStatusTimestamps       []ApplyStatusTimestamps `json:"apply_status_timestamps"`
	FullCount                   *int                    `json:"full_count"`
}

func (s FindRunsByStatusesRow) GetRunID() *string { return s.RunID }
func (s FindRunsByStatusesRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindRunsByStatusesRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindRunsByStatusesRow) GetIsDestroy() *bool { return s.IsDestroy }
func (s FindRunsByStatusesRow) GetPositionInQueue() *int32 { return s.PositionInQueue }
func (s FindRunsByStatusesRow) GetRefresh() *bool { return s.Refresh }
func (s FindRunsByStatusesRow) GetRefreshOnly() *bool { return s.RefreshOnly }
func (s FindRunsByStatusesRow) GetStatus() *string { return s.Status }
func (s FindRunsByStatusesRow) GetPlanStatus() *string { return s.PlanStatus }
func (s FindRunsByStatusesRow) GetPlannedResourceAdditions() *int32 { return s.PlannedResourceAdditions }
func (s FindRunsByStatusesRow) GetPlannedResourceChanges() *int32 { return s.PlannedResourceChanges }
func (s FindRunsByStatusesRow) GetPlannedResourceDestructions() *int32 { return s.PlannedResourceDestructions }
func (s FindRunsByStatusesRow) GetApplyStatus() *string { return s.ApplyStatus }
func (s FindRunsByStatusesRow) GetAppliedResourceAdditions() *int32 { return s.AppliedResourceAdditions }
func (s FindRunsByStatusesRow) GetAppliedResourceChanges() *int32 { return s.AppliedResourceChanges }
func (s FindRunsByStatusesRow) GetAppliedResourceDestructions() *int32 { return s.AppliedResourceDestructions }
func (s FindRunsByStatusesRow) GetReplaceAddrs() []string { return s.ReplaceAddrs }
func (s FindRunsByStatusesRow) GetTargetAddrs() []string { return s.TargetAddrs }
func (s FindRunsByStatusesRow) GetConfigurationVersion() ConfigurationVersions { return s.ConfigurationVersion }
func (s FindRunsByStatusesRow) GetWorkspace() Workspaces { return s.Workspace }
func (s FindRunsByStatusesRow) GetRunStatusTimestamps() []RunStatusTimestamps { return s.RunStatusTimestamps }
func (s FindRunsByStatusesRow) GetPlanStatusTimestamps() []PlanStatusTimestamps { return s.PlanStatusTimestamps }
func (s FindRunsByStatusesRow) GetApplyStatusTimestamps() []ApplyStatusTimestamps { return s.ApplyStatusTimestamps }
func (s FindRunsByStatusesRow) GetFullCount() *int { return s.FullCount }


// FindRunsByStatuses implements Querier.FindRunsByStatuses.
func (q *DBQuerier) FindRunsByStatuses(ctx context.Context, params FindRunsByStatusesParams) ([]FindRunsByStatusesRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunsByStatuses")
	rows, err := q.conn.Query(ctx, findRunsByStatusesSQL, params.Statuses, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindRunsByStatuses: %w", err)
	}
	defer rows.Close()
	items := []FindRunsByStatusesRow{}
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	for rows.Next() {
		var item FindRunsByStatusesRow
		if err := rows.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindRunsByStatuses row: %w", err)
		}
		if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunsByStatuses rows: %w", err)
	}
	return items, err
}

// FindRunsByStatusesBatch implements Querier.FindRunsByStatusesBatch.
func (q *DBQuerier) FindRunsByStatusesBatch(batch genericBatch, params FindRunsByStatusesParams) {
	batch.Queue(findRunsByStatusesSQL, params.Statuses, params.Limit, params.Offset)
}

// FindRunsByStatusesScan implements Querier.FindRunsByStatusesScan.
func (q *DBQuerier) FindRunsByStatusesScan(results pgx.BatchResults) ([]FindRunsByStatusesRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindRunsByStatusesBatch: %w", err)
	}
	defer rows.Close()
	items := []FindRunsByStatusesRow{}
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	for rows.Next() {
		var item FindRunsByStatusesRow
		if err := rows.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindRunsByStatusesBatch row: %w", err)
		}
		if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
			return nil, fmt.Errorf("assign FindRunsByStatuses row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindRunsByStatusesBatch rows: %w", err)
	}
	return items, err
}

const findRunByIDSQL = `SELECT
    runs.run_id,
    runs.created_at,
    runs.updated_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.status,
    runs.plan_status,
    runs.planned_resource_additions,
    runs.planned_resource_changes,
    runs.planned_resource_destructions,
    runs.apply_status,
    runs.applied_resource_additions,
    runs.applied_resource_changes,
    runs.applied_resource_destructions,
    runs.replace_addrs,
    runs.target_addrs,
    (configuration_versions.*)::"configuration_versions" AS configuration_version,
    (workspaces.*)::"workspaces" AS workspace,
    (
        SELECT array_agg(rst.*) AS run_status_timestamps
        FROM run_status_timestamps rst
        WHERE rst.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamps,
    (
        SELECT array_agg(pst.*) AS plan_status_timestamps
        FROM plan_status_timestamps pst
        WHERE pst.run_id = runs.run_id
        GROUP BY run_id
    ) AS plan_status_timestamps,
    (
        SELECT array_agg(ast.*) AS apply_status_timestamps
        FROM apply_status_timestamps ast
        WHERE ast.run_id = runs.run_id
        GROUP BY run_id
    ) AS apply_status_timestamps
FROM runs
JOIN configuration_versions USING(workspace_id)
JOIN workspaces USING(workspace_id)
WHERE runs.run_id = $1
;`

type FindRunByIDRow struct {
	RunID                       *string                 `json:"run_id"`
	CreatedAt                   time.Time               `json:"created_at"`
	UpdatedAt                   time.Time               `json:"updated_at"`
	IsDestroy                   *bool                   `json:"is_destroy"`
	PositionInQueue             *int32                  `json:"position_in_queue"`
	Refresh                     *bool                   `json:"refresh"`
	RefreshOnly                 *bool                   `json:"refresh_only"`
	Status                      *string                 `json:"status"`
	PlanStatus                  *string                 `json:"plan_status"`
	PlannedResourceAdditions    *int32                  `json:"planned_resource_additions"`
	PlannedResourceChanges      *int32                  `json:"planned_resource_changes"`
	PlannedResourceDestructions *int32                  `json:"planned_resource_destructions"`
	ApplyStatus                 *string                 `json:"apply_status"`
	AppliedResourceAdditions    *int32                  `json:"applied_resource_additions"`
	AppliedResourceChanges      *int32                  `json:"applied_resource_changes"`
	AppliedResourceDestructions *int32                  `json:"applied_resource_destructions"`
	ReplaceAddrs                []string                `json:"replace_addrs"`
	TargetAddrs                 []string                `json:"target_addrs"`
	ConfigurationVersion        ConfigurationVersions   `json:"configuration_version"`
	Workspace                   Workspaces              `json:"workspace"`
	RunStatusTimestamps         []RunStatusTimestamps   `json:"run_status_timestamps"`
	PlanStatusTimestamps        []PlanStatusTimestamps  `json:"plan_status_timestamps"`
	ApplyStatusTimestamps       []ApplyStatusTimestamps `json:"apply_status_timestamps"`
}

func (s FindRunByIDRow) GetRunID() *string { return s.RunID }
func (s FindRunByIDRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindRunByIDRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindRunByIDRow) GetIsDestroy() *bool { return s.IsDestroy }
func (s FindRunByIDRow) GetPositionInQueue() *int32 { return s.PositionInQueue }
func (s FindRunByIDRow) GetRefresh() *bool { return s.Refresh }
func (s FindRunByIDRow) GetRefreshOnly() *bool { return s.RefreshOnly }
func (s FindRunByIDRow) GetStatus() *string { return s.Status }
func (s FindRunByIDRow) GetPlanStatus() *string { return s.PlanStatus }
func (s FindRunByIDRow) GetPlannedResourceAdditions() *int32 { return s.PlannedResourceAdditions }
func (s FindRunByIDRow) GetPlannedResourceChanges() *int32 { return s.PlannedResourceChanges }
func (s FindRunByIDRow) GetPlannedResourceDestructions() *int32 { return s.PlannedResourceDestructions }
func (s FindRunByIDRow) GetApplyStatus() *string { return s.ApplyStatus }
func (s FindRunByIDRow) GetAppliedResourceAdditions() *int32 { return s.AppliedResourceAdditions }
func (s FindRunByIDRow) GetAppliedResourceChanges() *int32 { return s.AppliedResourceChanges }
func (s FindRunByIDRow) GetAppliedResourceDestructions() *int32 { return s.AppliedResourceDestructions }
func (s FindRunByIDRow) GetReplaceAddrs() []string { return s.ReplaceAddrs }
func (s FindRunByIDRow) GetTargetAddrs() []string { return s.TargetAddrs }
func (s FindRunByIDRow) GetConfigurationVersion() ConfigurationVersions { return s.ConfigurationVersion }
func (s FindRunByIDRow) GetWorkspace() Workspaces { return s.Workspace }
func (s FindRunByIDRow) GetRunStatusTimestamps() []RunStatusTimestamps { return s.RunStatusTimestamps }
func (s FindRunByIDRow) GetPlanStatusTimestamps() []PlanStatusTimestamps { return s.PlanStatusTimestamps }
func (s FindRunByIDRow) GetApplyStatusTimestamps() []ApplyStatusTimestamps { return s.ApplyStatusTimestamps }


// FindRunByID implements Querier.FindRunByID.
func (q *DBQuerier) FindRunByID(ctx context.Context, runID string) (FindRunByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunByID")
	row := q.conn.QueryRow(ctx, findRunByIDSQL, runID)
	var item FindRunByIDRow
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	if err := row.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray); err != nil {
		return item, fmt.Errorf("query FindRunByID: %w", err)
	}
	if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	return item, nil
}

// FindRunByIDBatch implements Querier.FindRunByIDBatch.
func (q *DBQuerier) FindRunByIDBatch(batch genericBatch, runID string) {
	batch.Queue(findRunByIDSQL, runID)
}

// FindRunByIDScan implements Querier.FindRunByIDScan.
func (q *DBQuerier) FindRunByIDScan(results pgx.BatchResults) (FindRunByIDRow, error) {
	row := results.QueryRow()
	var item FindRunByIDRow
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	if err := row.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray); err != nil {
		return item, fmt.Errorf("scan FindRunByIDBatch row: %w", err)
	}
	if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByID row: %w", err)
	}
	return item, nil
}

const findRunByPlanIDSQL = `SELECT
    runs.run_id,
    runs.created_at,
    runs.updated_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.status,
    runs.plan_status,
    runs.planned_resource_additions,
    runs.planned_resource_changes,
    runs.planned_resource_destructions,
    runs.apply_status,
    runs.applied_resource_additions,
    runs.applied_resource_changes,
    runs.applied_resource_destructions,
    runs.replace_addrs,
    runs.target_addrs,
    (configuration_versions.*)::"configuration_versions" AS configuration_version,
    (workspaces.*)::"workspaces" AS workspace,
    (
        SELECT array_agg(rst.*) AS run_status_timestamps
        FROM run_status_timestamps rst
        WHERE rst.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamps,
    (
        SELECT array_agg(pst.*) AS plan_status_timestamps
        FROM plan_status_timestamps pst
        WHERE pst.run_id = runs.run_id
        GROUP BY run_id
    ) AS plan_status_timestamps,
    (
        SELECT array_agg(ast.*) AS apply_status_timestamps
        FROM apply_status_timestamps ast
        WHERE ast.run_id = runs.run_id
        GROUP BY run_id
    ) AS apply_status_timestamps
FROM runs
JOIN configuration_versions USING(workspace_id)
JOIN workspaces USING(workspace_id)
WHERE runs.plan_id = $1
;`

type FindRunByPlanIDRow struct {
	RunID                       *string                 `json:"run_id"`
	CreatedAt                   time.Time               `json:"created_at"`
	UpdatedAt                   time.Time               `json:"updated_at"`
	IsDestroy                   *bool                   `json:"is_destroy"`
	PositionInQueue             *int32                  `json:"position_in_queue"`
	Refresh                     *bool                   `json:"refresh"`
	RefreshOnly                 *bool                   `json:"refresh_only"`
	Status                      *string                 `json:"status"`
	PlanStatus                  *string                 `json:"plan_status"`
	PlannedResourceAdditions    *int32                  `json:"planned_resource_additions"`
	PlannedResourceChanges      *int32                  `json:"planned_resource_changes"`
	PlannedResourceDestructions *int32                  `json:"planned_resource_destructions"`
	ApplyStatus                 *string                 `json:"apply_status"`
	AppliedResourceAdditions    *int32                  `json:"applied_resource_additions"`
	AppliedResourceChanges      *int32                  `json:"applied_resource_changes"`
	AppliedResourceDestructions *int32                  `json:"applied_resource_destructions"`
	ReplaceAddrs                []string                `json:"replace_addrs"`
	TargetAddrs                 []string                `json:"target_addrs"`
	ConfigurationVersion        ConfigurationVersions   `json:"configuration_version"`
	Workspace                   Workspaces              `json:"workspace"`
	RunStatusTimestamps         []RunStatusTimestamps   `json:"run_status_timestamps"`
	PlanStatusTimestamps        []PlanStatusTimestamps  `json:"plan_status_timestamps"`
	ApplyStatusTimestamps       []ApplyStatusTimestamps `json:"apply_status_timestamps"`
}

func (s FindRunByPlanIDRow) GetRunID() *string { return s.RunID }
func (s FindRunByPlanIDRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindRunByPlanIDRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindRunByPlanIDRow) GetIsDestroy() *bool { return s.IsDestroy }
func (s FindRunByPlanIDRow) GetPositionInQueue() *int32 { return s.PositionInQueue }
func (s FindRunByPlanIDRow) GetRefresh() *bool { return s.Refresh }
func (s FindRunByPlanIDRow) GetRefreshOnly() *bool { return s.RefreshOnly }
func (s FindRunByPlanIDRow) GetStatus() *string { return s.Status }
func (s FindRunByPlanIDRow) GetPlanStatus() *string { return s.PlanStatus }
func (s FindRunByPlanIDRow) GetPlannedResourceAdditions() *int32 { return s.PlannedResourceAdditions }
func (s FindRunByPlanIDRow) GetPlannedResourceChanges() *int32 { return s.PlannedResourceChanges }
func (s FindRunByPlanIDRow) GetPlannedResourceDestructions() *int32 { return s.PlannedResourceDestructions }
func (s FindRunByPlanIDRow) GetApplyStatus() *string { return s.ApplyStatus }
func (s FindRunByPlanIDRow) GetAppliedResourceAdditions() *int32 { return s.AppliedResourceAdditions }
func (s FindRunByPlanIDRow) GetAppliedResourceChanges() *int32 { return s.AppliedResourceChanges }
func (s FindRunByPlanIDRow) GetAppliedResourceDestructions() *int32 { return s.AppliedResourceDestructions }
func (s FindRunByPlanIDRow) GetReplaceAddrs() []string { return s.ReplaceAddrs }
func (s FindRunByPlanIDRow) GetTargetAddrs() []string { return s.TargetAddrs }
func (s FindRunByPlanIDRow) GetConfigurationVersion() ConfigurationVersions { return s.ConfigurationVersion }
func (s FindRunByPlanIDRow) GetWorkspace() Workspaces { return s.Workspace }
func (s FindRunByPlanIDRow) GetRunStatusTimestamps() []RunStatusTimestamps { return s.RunStatusTimestamps }
func (s FindRunByPlanIDRow) GetPlanStatusTimestamps() []PlanStatusTimestamps { return s.PlanStatusTimestamps }
func (s FindRunByPlanIDRow) GetApplyStatusTimestamps() []ApplyStatusTimestamps { return s.ApplyStatusTimestamps }


// FindRunByPlanID implements Querier.FindRunByPlanID.
func (q *DBQuerier) FindRunByPlanID(ctx context.Context, planID string) (FindRunByPlanIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunByPlanID")
	row := q.conn.QueryRow(ctx, findRunByPlanIDSQL, planID)
	var item FindRunByPlanIDRow
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	if err := row.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray); err != nil {
		return item, fmt.Errorf("query FindRunByPlanID: %w", err)
	}
	if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	return item, nil
}

// FindRunByPlanIDBatch implements Querier.FindRunByPlanIDBatch.
func (q *DBQuerier) FindRunByPlanIDBatch(batch genericBatch, planID string) {
	batch.Queue(findRunByPlanIDSQL, planID)
}

// FindRunByPlanIDScan implements Querier.FindRunByPlanIDScan.
func (q *DBQuerier) FindRunByPlanIDScan(results pgx.BatchResults) (FindRunByPlanIDRow, error) {
	row := results.QueryRow()
	var item FindRunByPlanIDRow
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	if err := row.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray); err != nil {
		return item, fmt.Errorf("scan FindRunByPlanIDBatch row: %w", err)
	}
	if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByPlanID row: %w", err)
	}
	return item, nil
}

const findRunByApplyIDSQL = `SELECT
    runs.run_id,
    runs.created_at,
    runs.updated_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.status,
    runs.plan_status,
    runs.planned_resource_additions,
    runs.planned_resource_changes,
    runs.planned_resource_destructions,
    runs.apply_status,
    runs.applied_resource_additions,
    runs.applied_resource_changes,
    runs.applied_resource_destructions,
    runs.replace_addrs,
    runs.target_addrs,
    (configuration_versions.*)::"configuration_versions" AS configuration_version,
    (workspaces.*)::"workspaces" AS workspace,
    (
        SELECT array_agg(rst.*) AS run_status_timestamps
        FROM run_status_timestamps rst
        WHERE rst.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamps,
    (
        SELECT array_agg(pst.*) AS plan_status_timestamps
        FROM plan_status_timestamps pst
        WHERE pst.run_id = runs.run_id
        GROUP BY run_id
    ) AS plan_status_timestamps,
    (
        SELECT array_agg(ast.*) AS apply_status_timestamps
        FROM apply_status_timestamps ast
        WHERE ast.run_id = runs.run_id
        GROUP BY run_id
    ) AS apply_status_timestamps
FROM runs
JOIN configuration_versions USING(workspace_id)
JOIN workspaces USING(workspace_id)
WHERE runs.apply_id = $1
;`

type FindRunByApplyIDRow struct {
	RunID                       *string                 `json:"run_id"`
	CreatedAt                   time.Time               `json:"created_at"`
	UpdatedAt                   time.Time               `json:"updated_at"`
	IsDestroy                   *bool                   `json:"is_destroy"`
	PositionInQueue             *int32                  `json:"position_in_queue"`
	Refresh                     *bool                   `json:"refresh"`
	RefreshOnly                 *bool                   `json:"refresh_only"`
	Status                      *string                 `json:"status"`
	PlanStatus                  *string                 `json:"plan_status"`
	PlannedResourceAdditions    *int32                  `json:"planned_resource_additions"`
	PlannedResourceChanges      *int32                  `json:"planned_resource_changes"`
	PlannedResourceDestructions *int32                  `json:"planned_resource_destructions"`
	ApplyStatus                 *string                 `json:"apply_status"`
	AppliedResourceAdditions    *int32                  `json:"applied_resource_additions"`
	AppliedResourceChanges      *int32                  `json:"applied_resource_changes"`
	AppliedResourceDestructions *int32                  `json:"applied_resource_destructions"`
	ReplaceAddrs                []string                `json:"replace_addrs"`
	TargetAddrs                 []string                `json:"target_addrs"`
	ConfigurationVersion        ConfigurationVersions   `json:"configuration_version"`
	Workspace                   Workspaces              `json:"workspace"`
	RunStatusTimestamps         []RunStatusTimestamps   `json:"run_status_timestamps"`
	PlanStatusTimestamps        []PlanStatusTimestamps  `json:"plan_status_timestamps"`
	ApplyStatusTimestamps       []ApplyStatusTimestamps `json:"apply_status_timestamps"`
}

func (s FindRunByApplyIDRow) GetRunID() *string { return s.RunID }
func (s FindRunByApplyIDRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindRunByApplyIDRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindRunByApplyIDRow) GetIsDestroy() *bool { return s.IsDestroy }
func (s FindRunByApplyIDRow) GetPositionInQueue() *int32 { return s.PositionInQueue }
func (s FindRunByApplyIDRow) GetRefresh() *bool { return s.Refresh }
func (s FindRunByApplyIDRow) GetRefreshOnly() *bool { return s.RefreshOnly }
func (s FindRunByApplyIDRow) GetStatus() *string { return s.Status }
func (s FindRunByApplyIDRow) GetPlanStatus() *string { return s.PlanStatus }
func (s FindRunByApplyIDRow) GetPlannedResourceAdditions() *int32 { return s.PlannedResourceAdditions }
func (s FindRunByApplyIDRow) GetPlannedResourceChanges() *int32 { return s.PlannedResourceChanges }
func (s FindRunByApplyIDRow) GetPlannedResourceDestructions() *int32 { return s.PlannedResourceDestructions }
func (s FindRunByApplyIDRow) GetApplyStatus() *string { return s.ApplyStatus }
func (s FindRunByApplyIDRow) GetAppliedResourceAdditions() *int32 { return s.AppliedResourceAdditions }
func (s FindRunByApplyIDRow) GetAppliedResourceChanges() *int32 { return s.AppliedResourceChanges }
func (s FindRunByApplyIDRow) GetAppliedResourceDestructions() *int32 { return s.AppliedResourceDestructions }
func (s FindRunByApplyIDRow) GetReplaceAddrs() []string { return s.ReplaceAddrs }
func (s FindRunByApplyIDRow) GetTargetAddrs() []string { return s.TargetAddrs }
func (s FindRunByApplyIDRow) GetConfigurationVersion() ConfigurationVersions { return s.ConfigurationVersion }
func (s FindRunByApplyIDRow) GetWorkspace() Workspaces { return s.Workspace }
func (s FindRunByApplyIDRow) GetRunStatusTimestamps() []RunStatusTimestamps { return s.RunStatusTimestamps }
func (s FindRunByApplyIDRow) GetPlanStatusTimestamps() []PlanStatusTimestamps { return s.PlanStatusTimestamps }
func (s FindRunByApplyIDRow) GetApplyStatusTimestamps() []ApplyStatusTimestamps { return s.ApplyStatusTimestamps }


// FindRunByApplyID implements Querier.FindRunByApplyID.
func (q *DBQuerier) FindRunByApplyID(ctx context.Context, applyID string) (FindRunByApplyIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunByApplyID")
	row := q.conn.QueryRow(ctx, findRunByApplyIDSQL, applyID)
	var item FindRunByApplyIDRow
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	if err := row.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray); err != nil {
		return item, fmt.Errorf("query FindRunByApplyID: %w", err)
	}
	if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	return item, nil
}

// FindRunByApplyIDBatch implements Querier.FindRunByApplyIDBatch.
func (q *DBQuerier) FindRunByApplyIDBatch(batch genericBatch, applyID string) {
	batch.Queue(findRunByApplyIDSQL, applyID)
}

// FindRunByApplyIDScan implements Querier.FindRunByApplyIDScan.
func (q *DBQuerier) FindRunByApplyIDScan(results pgx.BatchResults) (FindRunByApplyIDRow, error) {
	row := results.QueryRow()
	var item FindRunByApplyIDRow
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	if err := row.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray); err != nil {
		return item, fmt.Errorf("scan FindRunByApplyIDBatch row: %w", err)
	}
	if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByApplyID row: %w", err)
	}
	return item, nil
}

const findRunByIDForUpdateSQL = `SELECT
    runs.run_id,
    runs.created_at,
    runs.updated_at,
    runs.is_destroy,
    runs.position_in_queue,
    runs.refresh,
    runs.refresh_only,
    runs.status,
    runs.plan_status,
    runs.planned_resource_additions,
    runs.planned_resource_changes,
    runs.planned_resource_destructions,
    runs.apply_status,
    runs.applied_resource_additions,
    runs.applied_resource_changes,
    runs.applied_resource_destructions,
    runs.replace_addrs,
    runs.target_addrs,
    (configuration_versions.*)::"configuration_versions" AS configuration_version,
    (workspaces.*)::"workspaces" AS workspace,
    (
        SELECT array_agg(rst.*) AS run_status_timestamps
        FROM run_status_timestamps rst
        WHERE rst.run_id = runs.run_id
        GROUP BY run_id
    ) AS run_status_timestamps,
    (
        SELECT array_agg(pst.*) AS plan_status_timestamps
        FROM plan_status_timestamps pst
        WHERE pst.run_id = runs.run_id
        GROUP BY run_id
    ) AS plan_status_timestamps,
    (
        SELECT array_agg(ast.*) AS apply_status_timestamps
        FROM apply_status_timestamps ast
        WHERE ast.run_id = runs.run_id
        GROUP BY run_id
    ) AS apply_status_timestamps
FROM runs
JOIN configuration_versions USING(workspace_id)
JOIN workspaces USING(workspace_id)
WHERE runs.run_id = $1
FOR UPDATE
;`

type FindRunByIDForUpdateRow struct {
	RunID                       *string                 `json:"run_id"`
	CreatedAt                   time.Time               `json:"created_at"`
	UpdatedAt                   time.Time               `json:"updated_at"`
	IsDestroy                   *bool                   `json:"is_destroy"`
	PositionInQueue             *int32                  `json:"position_in_queue"`
	Refresh                     *bool                   `json:"refresh"`
	RefreshOnly                 *bool                   `json:"refresh_only"`
	Status                      *string                 `json:"status"`
	PlanStatus                  *string                 `json:"plan_status"`
	PlannedResourceAdditions    *int32                  `json:"planned_resource_additions"`
	PlannedResourceChanges      *int32                  `json:"planned_resource_changes"`
	PlannedResourceDestructions *int32                  `json:"planned_resource_destructions"`
	ApplyStatus                 *string                 `json:"apply_status"`
	AppliedResourceAdditions    *int32                  `json:"applied_resource_additions"`
	AppliedResourceChanges      *int32                  `json:"applied_resource_changes"`
	AppliedResourceDestructions *int32                  `json:"applied_resource_destructions"`
	ReplaceAddrs                []string                `json:"replace_addrs"`
	TargetAddrs                 []string                `json:"target_addrs"`
	ConfigurationVersion        ConfigurationVersions   `json:"configuration_version"`
	Workspace                   Workspaces              `json:"workspace"`
	RunStatusTimestamps         []RunStatusTimestamps   `json:"run_status_timestamps"`
	PlanStatusTimestamps        []PlanStatusTimestamps  `json:"plan_status_timestamps"`
	ApplyStatusTimestamps       []ApplyStatusTimestamps `json:"apply_status_timestamps"`
}

func (s FindRunByIDForUpdateRow) GetRunID() *string { return s.RunID }
func (s FindRunByIDForUpdateRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s FindRunByIDForUpdateRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s FindRunByIDForUpdateRow) GetIsDestroy() *bool { return s.IsDestroy }
func (s FindRunByIDForUpdateRow) GetPositionInQueue() *int32 { return s.PositionInQueue }
func (s FindRunByIDForUpdateRow) GetRefresh() *bool { return s.Refresh }
func (s FindRunByIDForUpdateRow) GetRefreshOnly() *bool { return s.RefreshOnly }
func (s FindRunByIDForUpdateRow) GetStatus() *string { return s.Status }
func (s FindRunByIDForUpdateRow) GetPlanStatus() *string { return s.PlanStatus }
func (s FindRunByIDForUpdateRow) GetPlannedResourceAdditions() *int32 { return s.PlannedResourceAdditions }
func (s FindRunByIDForUpdateRow) GetPlannedResourceChanges() *int32 { return s.PlannedResourceChanges }
func (s FindRunByIDForUpdateRow) GetPlannedResourceDestructions() *int32 { return s.PlannedResourceDestructions }
func (s FindRunByIDForUpdateRow) GetApplyStatus() *string { return s.ApplyStatus }
func (s FindRunByIDForUpdateRow) GetAppliedResourceAdditions() *int32 { return s.AppliedResourceAdditions }
func (s FindRunByIDForUpdateRow) GetAppliedResourceChanges() *int32 { return s.AppliedResourceChanges }
func (s FindRunByIDForUpdateRow) GetAppliedResourceDestructions() *int32 { return s.AppliedResourceDestructions }
func (s FindRunByIDForUpdateRow) GetReplaceAddrs() []string { return s.ReplaceAddrs }
func (s FindRunByIDForUpdateRow) GetTargetAddrs() []string { return s.TargetAddrs }
func (s FindRunByIDForUpdateRow) GetConfigurationVersion() ConfigurationVersions { return s.ConfigurationVersion }
func (s FindRunByIDForUpdateRow) GetWorkspace() Workspaces { return s.Workspace }
func (s FindRunByIDForUpdateRow) GetRunStatusTimestamps() []RunStatusTimestamps { return s.RunStatusTimestamps }
func (s FindRunByIDForUpdateRow) GetPlanStatusTimestamps() []PlanStatusTimestamps { return s.PlanStatusTimestamps }
func (s FindRunByIDForUpdateRow) GetApplyStatusTimestamps() []ApplyStatusTimestamps { return s.ApplyStatusTimestamps }


// FindRunByIDForUpdate implements Querier.FindRunByIDForUpdate.
func (q *DBQuerier) FindRunByIDForUpdate(ctx context.Context, runID string) (FindRunByIDForUpdateRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindRunByIDForUpdate")
	row := q.conn.QueryRow(ctx, findRunByIDForUpdateSQL, runID)
	var item FindRunByIDForUpdateRow
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	if err := row.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray); err != nil {
		return item, fmt.Errorf("query FindRunByIDForUpdate: %w", err)
	}
	if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	return item, nil
}

// FindRunByIDForUpdateBatch implements Querier.FindRunByIDForUpdateBatch.
func (q *DBQuerier) FindRunByIDForUpdateBatch(batch genericBatch, runID string) {
	batch.Queue(findRunByIDForUpdateSQL, runID)
}

// FindRunByIDForUpdateScan implements Querier.FindRunByIDForUpdateScan.
func (q *DBQuerier) FindRunByIDForUpdateScan(results pgx.BatchResults) (FindRunByIDForUpdateRow, error) {
	row := results.QueryRow()
	var item FindRunByIDForUpdateRow
	configurationVersionRow := q.types.newConfigurationVersions()
	workspaceRow := q.types.newWorkspaces()
	runStatusTimestampsArray := q.types.newRunStatusTimestampsArray()
	planStatusTimestampsArray := q.types.newPlanStatusTimestampsArray()
	applyStatusTimestampsArray := q.types.newApplyStatusTimestampsArray()
	if err := row.Scan(&item.RunID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.PlanStatus, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.ReplaceAddrs, &item.TargetAddrs, configurationVersionRow, workspaceRow, runStatusTimestampsArray, planStatusTimestampsArray, applyStatusTimestampsArray); err != nil {
		return item, fmt.Errorf("scan FindRunByIDForUpdateBatch row: %w", err)
	}
	if err := configurationVersionRow.AssignTo(&item.ConfigurationVersion); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	if err := runStatusTimestampsArray.AssignTo(&item.RunStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	if err := planStatusTimestampsArray.AssignTo(&item.PlanStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	if err := applyStatusTimestampsArray.AssignTo(&item.ApplyStatusTimestamps); err != nil {
		return item, fmt.Errorf("assign FindRunByIDForUpdate row: %w", err)
	}
	return item, nil
}

const updateRunStatusSQL = `UPDATE runs
SET
    status = $1,
    updated_at = current_timestamp
WHERE run_id = $2
RETURNING *;`

type UpdateRunStatusRow struct {
	RunID                       string    `json:"run_id"`
	PlanID                      string    `json:"plan_id"`
	ApplyID                     string    `json:"apply_id"`
	CreatedAt                   time.Time `json:"created_at"`
	UpdatedAt                   time.Time `json:"updated_at"`
	IsDestroy                   bool      `json:"is_destroy"`
	PositionInQueue             int32     `json:"position_in_queue"`
	Refresh                     bool      `json:"refresh"`
	RefreshOnly                 bool      `json:"refresh_only"`
	Status                      string    `json:"status"`
	ReplaceAddrs                []string  `json:"replace_addrs"`
	TargetAddrs                 []string  `json:"target_addrs"`
	PlanStatus                  string    `json:"plan_status"`
	PlanBin                     []byte    `json:"plan_bin"`
	PlanJson                    []byte    `json:"plan_json"`
	PlannedResourceAdditions    *int32    `json:"planned_resource_additions"`
	PlannedResourceChanges      *int32    `json:"planned_resource_changes"`
	PlannedResourceDestructions *int32    `json:"planned_resource_destructions"`
	ApplyStatus                 string    `json:"apply_status"`
	AppliedResourceAdditions    *int32    `json:"applied_resource_additions"`
	AppliedResourceChanges      *int32    `json:"applied_resource_changes"`
	AppliedResourceDestructions *int32    `json:"applied_resource_destructions"`
	WorkspaceID                 string    `json:"workspace_id"`
	ConfigurationVersionID      string    `json:"configuration_version_id"`
}

func (s UpdateRunStatusRow) GetRunID() string { return s.RunID }
func (s UpdateRunStatusRow) GetPlanID() string { return s.PlanID }
func (s UpdateRunStatusRow) GetApplyID() string { return s.ApplyID }
func (s UpdateRunStatusRow) GetCreatedAt() time.Time { return s.CreatedAt }
func (s UpdateRunStatusRow) GetUpdatedAt() time.Time { return s.UpdatedAt }
func (s UpdateRunStatusRow) GetIsDestroy() bool { return s.IsDestroy }
func (s UpdateRunStatusRow) GetPositionInQueue() int32 { return s.PositionInQueue }
func (s UpdateRunStatusRow) GetRefresh() bool { return s.Refresh }
func (s UpdateRunStatusRow) GetRefreshOnly() bool { return s.RefreshOnly }
func (s UpdateRunStatusRow) GetStatus() string { return s.Status }
func (s UpdateRunStatusRow) GetReplaceAddrs() []string { return s.ReplaceAddrs }
func (s UpdateRunStatusRow) GetTargetAddrs() []string { return s.TargetAddrs }
func (s UpdateRunStatusRow) GetPlanStatus() string { return s.PlanStatus }
func (s UpdateRunStatusRow) GetPlanBin() []byte { return s.PlanBin }
func (s UpdateRunStatusRow) GetPlanJson() []byte { return s.PlanJson }
func (s UpdateRunStatusRow) GetPlannedResourceAdditions() *int32 { return s.PlannedResourceAdditions }
func (s UpdateRunStatusRow) GetPlannedResourceChanges() *int32 { return s.PlannedResourceChanges }
func (s UpdateRunStatusRow) GetPlannedResourceDestructions() *int32 { return s.PlannedResourceDestructions }
func (s UpdateRunStatusRow) GetApplyStatus() string { return s.ApplyStatus }
func (s UpdateRunStatusRow) GetAppliedResourceAdditions() *int32 { return s.AppliedResourceAdditions }
func (s UpdateRunStatusRow) GetAppliedResourceChanges() *int32 { return s.AppliedResourceChanges }
func (s UpdateRunStatusRow) GetAppliedResourceDestructions() *int32 { return s.AppliedResourceDestructions }
func (s UpdateRunStatusRow) GetWorkspaceID() string { return s.WorkspaceID }
func (s UpdateRunStatusRow) GetConfigurationVersionID() string { return s.ConfigurationVersionID }


// UpdateRunStatus implements Querier.UpdateRunStatus.
func (q *DBQuerier) UpdateRunStatus(ctx context.Context, status string, id string) (UpdateRunStatusRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateRunStatus")
	row := q.conn.QueryRow(ctx, updateRunStatusSQL, status, id)
	var item UpdateRunStatusRow
	if err := row.Scan(&item.RunID, &item.PlanID, &item.ApplyID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.ReplaceAddrs, &item.TargetAddrs, &item.PlanStatus, &item.PlanBin, &item.PlanJson, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.WorkspaceID, &item.ConfigurationVersionID); err != nil {
		return item, fmt.Errorf("query UpdateRunStatus: %w", err)
	}
	return item, nil
}

// UpdateRunStatusBatch implements Querier.UpdateRunStatusBatch.
func (q *DBQuerier) UpdateRunStatusBatch(batch genericBatch, status string, id string) {
	batch.Queue(updateRunStatusSQL, status, id)
}

// UpdateRunStatusScan implements Querier.UpdateRunStatusScan.
func (q *DBQuerier) UpdateRunStatusScan(results pgx.BatchResults) (UpdateRunStatusRow, error) {
	row := results.QueryRow()
	var item UpdateRunStatusRow
	if err := row.Scan(&item.RunID, &item.PlanID, &item.ApplyID, &item.CreatedAt, &item.UpdatedAt, &item.IsDestroy, &item.PositionInQueue, &item.Refresh, &item.RefreshOnly, &item.Status, &item.ReplaceAddrs, &item.TargetAddrs, &item.PlanStatus, &item.PlanBin, &item.PlanJson, &item.PlannedResourceAdditions, &item.PlannedResourceChanges, &item.PlannedResourceDestructions, &item.ApplyStatus, &item.AppliedResourceAdditions, &item.AppliedResourceChanges, &item.AppliedResourceDestructions, &item.WorkspaceID, &item.ConfigurationVersionID); err != nil {
		return item, fmt.Errorf("scan UpdateRunStatusBatch row: %w", err)
	}
	return item, nil
}

const deleteRunByIDSQL = `DELETE
FROM runs
WHERE run_id = $1;`

// DeleteRunByID implements Querier.DeleteRunByID.
func (q *DBQuerier) DeleteRunByID(ctx context.Context, runID string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteRunByID")
	cmdTag, err := q.conn.Exec(ctx, deleteRunByIDSQL, runID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteRunByID: %w", err)
	}
	return cmdTag, err
}

// DeleteRunByIDBatch implements Querier.DeleteRunByIDBatch.
func (q *DBQuerier) DeleteRunByIDBatch(batch genericBatch, runID string) {
	batch.Queue(deleteRunByIDSQL, runID)
}

// DeleteRunByIDScan implements Querier.DeleteRunByIDScan.
func (q *DBQuerier) DeleteRunByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteRunByIDBatch: %w", err)
	}
	return cmdTag, err
}
