// Code generated by pggen. DO NOT EDIT.

package db

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const findWorkspaceByNameSQL = `SELECT workspaces.*, (organizations.*)::"organizations" AS organization
FROM workspaces
JOIN organizations USING (organization_id)
WHERE workspaces.name = $1
AND organizations.name = $2;`

type FindWorkspaceByNameRow struct {
	WorkspaceID                *string            `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           *bool              `json:"allow_destroy_plan"`
	AutoApply                  *bool              `json:"auto_apply"`
	CanQueueDestroyPlan        *bool              `json:"can_queue_destroy_plan"`
	Description                *string            `json:"description"`
	Environment                *string            `json:"environment"`
	ExecutionMode              *string            `json:"execution_mode"`
	FileTriggersEnabled        *bool              `json:"file_triggers_enabled"`
	GlobalRemoteState          *bool              `json:"global_remote_state"`
	Locked                     *bool              `json:"locked"`
	MigrationEnvironment       *string            `json:"migration_environment"`
	Name                       *string            `json:"name"`
	QueueAllRuns               *bool              `json:"queue_all_runs"`
	SpeculativeEnabled         *bool              `json:"speculative_enabled"`
	SourceName                 *string            `json:"source_name"`
	SourceUrl                  *string            `json:"source_url"`
	StructuredRunOutputEnabled *bool              `json:"structured_run_output_enabled"`
	TerraformVersion           *string            `json:"terraform_version"`
	TriggerPrefixes            *string            `json:"trigger_prefixes"`
	WorkingDirectory           *string            `json:"working_directory"`
	OrganizationID             *string            `json:"organization_id"`
	Organization               Organizations      `json:"organization"`
}

// FindWorkspaceByName implements Querier.FindWorkspaceByName.
func (q *DBQuerier) FindWorkspaceByName(ctx context.Context, name string, organizationName string) (FindWorkspaceByNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByName")
	row := q.conn.QueryRow(ctx, findWorkspaceByNameSQL, name, organizationName)
	var item FindWorkspaceByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceUrl, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceByName: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	return item, nil
}

// FindWorkspaceByNameBatch implements Querier.FindWorkspaceByNameBatch.
func (q *DBQuerier) FindWorkspaceByNameBatch(batch genericBatch, name string, organizationName string) {
	batch.Queue(findWorkspaceByNameSQL, name, organizationName)
}

// FindWorkspaceByNameScan implements Querier.FindWorkspaceByNameScan.
func (q *DBQuerier) FindWorkspaceByNameScan(results pgx.BatchResults) (FindWorkspaceByNameRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceByNameRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceUrl, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceByNameBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByName row: %w", err)
	}
	return item, nil
}

const findWorkspaceByIDSQL = `SELECT workspaces.*, (organizations.*)::"organizations" AS organization
FROM workspaces
JOIN organizations USING (organization_id)
WHERE workspaces.workspace_id = $1;`

type FindWorkspaceByIDRow struct {
	WorkspaceID                *string            `json:"workspace_id"`
	CreatedAt                  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                  pgtype.Timestamptz `json:"updated_at"`
	AllowDestroyPlan           *bool              `json:"allow_destroy_plan"`
	AutoApply                  *bool              `json:"auto_apply"`
	CanQueueDestroyPlan        *bool              `json:"can_queue_destroy_plan"`
	Description                *string            `json:"description"`
	Environment                *string            `json:"environment"`
	ExecutionMode              *string            `json:"execution_mode"`
	FileTriggersEnabled        *bool              `json:"file_triggers_enabled"`
	GlobalRemoteState          *bool              `json:"global_remote_state"`
	Locked                     *bool              `json:"locked"`
	MigrationEnvironment       *string            `json:"migration_environment"`
	Name                       *string            `json:"name"`
	QueueAllRuns               *bool              `json:"queue_all_runs"`
	SpeculativeEnabled         *bool              `json:"speculative_enabled"`
	SourceName                 *string            `json:"source_name"`
	SourceUrl                  *string            `json:"source_url"`
	StructuredRunOutputEnabled *bool              `json:"structured_run_output_enabled"`
	TerraformVersion           *string            `json:"terraform_version"`
	TriggerPrefixes            *string            `json:"trigger_prefixes"`
	WorkingDirectory           *string            `json:"working_directory"`
	OrganizationID             *string            `json:"organization_id"`
	Organization               Organizations      `json:"organization"`
}

// FindWorkspaceByID implements Querier.FindWorkspaceByID.
func (q *DBQuerier) FindWorkspaceByID(ctx context.Context, id string) (FindWorkspaceByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindWorkspaceByID")
	row := q.conn.QueryRow(ctx, findWorkspaceByIDSQL, id)
	var item FindWorkspaceByIDRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceUrl, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("query FindWorkspaceByID: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	return item, nil
}

// FindWorkspaceByIDBatch implements Querier.FindWorkspaceByIDBatch.
func (q *DBQuerier) FindWorkspaceByIDBatch(batch genericBatch, id string) {
	batch.Queue(findWorkspaceByIDSQL, id)
}

// FindWorkspaceByIDScan implements Querier.FindWorkspaceByIDScan.
func (q *DBQuerier) FindWorkspaceByIDScan(results pgx.BatchResults) (FindWorkspaceByIDRow, error) {
	row := results.QueryRow()
	var item FindWorkspaceByIDRow
	organizationRow := q.types.newOrganizations()
	if err := row.Scan(&item.WorkspaceID, &item.CreatedAt, &item.UpdatedAt, &item.AllowDestroyPlan, &item.AutoApply, &item.CanQueueDestroyPlan, &item.Description, &item.Environment, &item.ExecutionMode, &item.FileTriggersEnabled, &item.GlobalRemoteState, &item.Locked, &item.MigrationEnvironment, &item.Name, &item.QueueAllRuns, &item.SpeculativeEnabled, &item.SourceName, &item.SourceUrl, &item.StructuredRunOutputEnabled, &item.TerraformVersion, &item.TriggerPrefixes, &item.WorkingDirectory, &item.OrganizationID, organizationRow); err != nil {
		return item, fmt.Errorf("scan FindWorkspaceByIDBatch row: %w", err)
	}
	if err := organizationRow.AssignTo(&item.Organization); err != nil {
		return item, fmt.Errorf("assign FindWorkspaceByID row: %w", err)
	}
	return item, nil
}

const deleteWorkspaceByIDSQL = `DELETE
FROM workspaces
WHERE workspace_id = $1;`

// DeleteWorkspaceByID implements Querier.DeleteWorkspaceByID.
func (q *DBQuerier) DeleteWorkspaceByID(ctx context.Context, workspaceID string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceByID")
	cmdTag, err := q.conn.Exec(ctx, deleteWorkspaceByIDSQL, workspaceID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteWorkspaceByID: %w", err)
	}
	return cmdTag, err
}

// DeleteWorkspaceByIDBatch implements Querier.DeleteWorkspaceByIDBatch.
func (q *DBQuerier) DeleteWorkspaceByIDBatch(batch genericBatch, workspaceID string) {
	batch.Queue(deleteWorkspaceByIDSQL, workspaceID)
}

// DeleteWorkspaceByIDScan implements Querier.DeleteWorkspaceByIDScan.
func (q *DBQuerier) DeleteWorkspaceByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteWorkspaceByIDBatch: %w", err)
	}
	return cmdTag, err
}

const deleteWorkspaceByNameSQL = `DELETE
FROM workspaces
USING organizations
WHERE workspaces.organization_id = organizations.organization_id
AND workspaces.name = $1
AND organizations.name = $2;`

// DeleteWorkspaceByName implements Querier.DeleteWorkspaceByName.
func (q *DBQuerier) DeleteWorkspaceByName(ctx context.Context, name string, organizationName string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteWorkspaceByName")
	cmdTag, err := q.conn.Exec(ctx, deleteWorkspaceByNameSQL, name, organizationName)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteWorkspaceByName: %w", err)
	}
	return cmdTag, err
}

// DeleteWorkspaceByNameBatch implements Querier.DeleteWorkspaceByNameBatch.
func (q *DBQuerier) DeleteWorkspaceByNameBatch(batch genericBatch, name string, organizationName string) {
	batch.Queue(deleteWorkspaceByNameSQL, name, organizationName)
}

// DeleteWorkspaceByNameScan implements Querier.DeleteWorkspaceByNameScan.
func (q *DBQuerier) DeleteWorkspaceByNameScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteWorkspaceByNameBatch: %w", err)
	}
	return cmdTag, err
}
