// Code generated by pggen. DO NOT EDIT.

package db

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const insertStateVersionSQL = `INSERT INTO state_versions (
    state_version_id,
    created_at,
    updated_at,
    serial,
    state,
    workspace_id
) VALUES (
    $1,
    NOW(),
    NOW(),
    $2,
    $3,
    $4
)
RETURNING *
;`

type InsertStateVersionParams struct {
	ID          string
	Serial      int32
	State       []byte
	WorkspaceID string
}

type InsertStateVersionRow struct {
	StateVersionID string             `json:"state_version_id"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	Serial         int32              `json:"serial"`
	VcsCommitSha   *string            `json:"vcs_commit_sha"`
	VcsCommitUrl   *string            `json:"vcs_commit_url"`
	State          []byte             `json:"state"`
	WorkspaceID    string             `json:"workspace_id"`
}

// InsertStateVersion implements Querier.InsertStateVersion.
func (q *DBQuerier) InsertStateVersion(ctx context.Context, params InsertStateVersionParams) (InsertStateVersionRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "InsertStateVersion")
	row := q.conn.QueryRow(ctx, insertStateVersionSQL, params.ID, params.Serial, params.State, params.WorkspaceID)
	var item InsertStateVersionRow
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.UpdatedAt, &item.Serial, &item.VcsCommitSha, &item.VcsCommitUrl, &item.State, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("query InsertStateVersion: %w", err)
	}
	return item, nil
}

// InsertStateVersionBatch implements Querier.InsertStateVersionBatch.
func (q *DBQuerier) InsertStateVersionBatch(batch genericBatch, params InsertStateVersionParams) {
	batch.Queue(insertStateVersionSQL, params.ID, params.Serial, params.State, params.WorkspaceID)
}

// InsertStateVersionScan implements Querier.InsertStateVersionScan.
func (q *DBQuerier) InsertStateVersionScan(results pgx.BatchResults) (InsertStateVersionRow, error) {
	row := results.QueryRow()
	var item InsertStateVersionRow
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.UpdatedAt, &item.Serial, &item.VcsCommitSha, &item.VcsCommitUrl, &item.State, &item.WorkspaceID); err != nil {
		return item, fmt.Errorf("scan InsertStateVersionBatch row: %w", err)
	}
	return item, nil
}

const findStateVersionsByWorkspaceNameSQL = `SELECT state_versions.*,
    (workspaces.*)::"workspaces" AS workspace,
    array_agg(state_version_outputs) AS state_version_outputs,
    count(*) OVER() AS full_count
FROM state_versions
JOIN workspaces USING (workspace_id)
JOIN organizations USING (organization_id)
JOIN state_version_outputs USING (state_version_id)
WHERE workspaces.name = $1
AND organizations.name = $2
GROUP BY state_versions.state_version_id, workspaces.workspace_id
LIMIT $3
OFFSET $4
;`

type FindStateVersionsByWorkspaceNameParams struct {
	WorkspaceName    string
	OrganizationName string
	Limit            int
	Offset           int
}

type FindStateVersionsByWorkspaceNameRow struct {
	StateVersionID      *string               `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz    `json:"updated_at"`
	Serial              *int32                `json:"serial"`
	VcsCommitSha        *string               `json:"vcs_commit_sha"`
	VcsCommitUrl        *string               `json:"vcs_commit_url"`
	State               pgtype.Bytea          `json:"state"`
	WorkspaceID         *string               `json:"workspace_id"`
	Workspace           Workspaces            `json:"workspace"`
	StateVersionOutputs []StateVersionOutputs `json:"state_version_outputs"`
	FullCount           *int                  `json:"full_count"`
}

// FindStateVersionsByWorkspaceName implements Querier.FindStateVersionsByWorkspaceName.
func (q *DBQuerier) FindStateVersionsByWorkspaceName(ctx context.Context, params FindStateVersionsByWorkspaceNameParams) ([]FindStateVersionsByWorkspaceNameRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionsByWorkspaceName")
	rows, err := q.conn.Query(ctx, findStateVersionsByWorkspaceNameSQL, params.WorkspaceName, params.OrganizationName, params.Limit, params.Offset)
	if err != nil {
		return nil, fmt.Errorf("query FindStateVersionsByWorkspaceName: %w", err)
	}
	defer rows.Close()
	items := []FindStateVersionsByWorkspaceNameRow{}
	workspaceRow := q.types.newWorkspaces()
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	for rows.Next() {
		var item FindStateVersionsByWorkspaceNameRow
		if err := rows.Scan(&item.StateVersionID, &item.CreatedAt, &item.UpdatedAt, &item.Serial, &item.VcsCommitSha, &item.VcsCommitUrl, &item.State, &item.WorkspaceID, workspaceRow, stateVersionOutputsArray, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindStateVersionsByWorkspaceName row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindStateVersionsByWorkspaceName row: %w", err)
		}
		if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
			return nil, fmt.Errorf("assign FindStateVersionsByWorkspaceName row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindStateVersionsByWorkspaceName rows: %w", err)
	}
	return items, err
}

// FindStateVersionsByWorkspaceNameBatch implements Querier.FindStateVersionsByWorkspaceNameBatch.
func (q *DBQuerier) FindStateVersionsByWorkspaceNameBatch(batch genericBatch, params FindStateVersionsByWorkspaceNameParams) {
	batch.Queue(findStateVersionsByWorkspaceNameSQL, params.WorkspaceName, params.OrganizationName, params.Limit, params.Offset)
}

// FindStateVersionsByWorkspaceNameScan implements Querier.FindStateVersionsByWorkspaceNameScan.
func (q *DBQuerier) FindStateVersionsByWorkspaceNameScan(results pgx.BatchResults) ([]FindStateVersionsByWorkspaceNameRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindStateVersionsByWorkspaceNameBatch: %w", err)
	}
	defer rows.Close()
	items := []FindStateVersionsByWorkspaceNameRow{}
	workspaceRow := q.types.newWorkspaces()
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	for rows.Next() {
		var item FindStateVersionsByWorkspaceNameRow
		if err := rows.Scan(&item.StateVersionID, &item.CreatedAt, &item.UpdatedAt, &item.Serial, &item.VcsCommitSha, &item.VcsCommitUrl, &item.State, &item.WorkspaceID, workspaceRow, stateVersionOutputsArray, &item.FullCount); err != nil {
			return nil, fmt.Errorf("scan FindStateVersionsByWorkspaceNameBatch row: %w", err)
		}
		if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
			return nil, fmt.Errorf("assign FindStateVersionsByWorkspaceName row: %w", err)
		}
		if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
			return nil, fmt.Errorf("assign FindStateVersionsByWorkspaceName row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindStateVersionsByWorkspaceNameBatch rows: %w", err)
	}
	return items, err
}

const findStateVersionByIDSQL = `SELECT state_versions.*,
    (workspaces.*)::"workspaces" AS workspace,
    array_agg(state_version_outputs) AS state_version_outputs
FROM state_versions
JOIN workspaces USING (workspace_id)
JOIN state_version_outputs USING (state_version_id)
WHERE state_versions.state_version_id = $1
GROUP BY state_versions.state_version_id, workspaces.workspace_id
;`

type FindStateVersionByIDRow struct {
	StateVersionID      *string               `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz    `json:"updated_at"`
	Serial              *int32                `json:"serial"`
	VcsCommitSha        *string               `json:"vcs_commit_sha"`
	VcsCommitUrl        *string               `json:"vcs_commit_url"`
	State               pgtype.Bytea          `json:"state"`
	WorkspaceID         *string               `json:"workspace_id"`
	Workspace           Workspaces            `json:"workspace"`
	StateVersionOutputs []StateVersionOutputs `json:"state_version_outputs"`
}

// FindStateVersionByID implements Querier.FindStateVersionByID.
func (q *DBQuerier) FindStateVersionByID(ctx context.Context, id string) (FindStateVersionByIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionByID")
	row := q.conn.QueryRow(ctx, findStateVersionByIDSQL, id)
	var item FindStateVersionByIDRow
	workspaceRow := q.types.newWorkspaces()
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.UpdatedAt, &item.Serial, &item.VcsCommitSha, &item.VcsCommitUrl, &item.State, &item.WorkspaceID, workspaceRow, stateVersionOutputsArray); err != nil {
		return item, fmt.Errorf("query FindStateVersionByID: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindStateVersionByID row: %w", err)
	}
	if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
		return item, fmt.Errorf("assign FindStateVersionByID row: %w", err)
	}
	return item, nil
}

// FindStateVersionByIDBatch implements Querier.FindStateVersionByIDBatch.
func (q *DBQuerier) FindStateVersionByIDBatch(batch genericBatch, id string) {
	batch.Queue(findStateVersionByIDSQL, id)
}

// FindStateVersionByIDScan implements Querier.FindStateVersionByIDScan.
func (q *DBQuerier) FindStateVersionByIDScan(results pgx.BatchResults) (FindStateVersionByIDRow, error) {
	row := results.QueryRow()
	var item FindStateVersionByIDRow
	workspaceRow := q.types.newWorkspaces()
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.UpdatedAt, &item.Serial, &item.VcsCommitSha, &item.VcsCommitUrl, &item.State, &item.WorkspaceID, workspaceRow, stateVersionOutputsArray); err != nil {
		return item, fmt.Errorf("scan FindStateVersionByIDBatch row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindStateVersionByID row: %w", err)
	}
	if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
		return item, fmt.Errorf("assign FindStateVersionByID row: %w", err)
	}
	return item, nil
}

const findStateVersionLatestByWorkspaceIDSQL = `SELECT state_versions.*,
    (workspaces.*)::"workspaces" AS workspace,
    array_agg(state_version_outputs) AS state_version_outputs
FROM state_versions
JOIN workspaces USING (workspace_id)
JOIN state_version_outputs USING (state_version_id)
WHERE workspaces.workspace_id = $1
GROUP BY state_versions.state_version_id, workspaces.workspace_id
ORDER BY state_versions.serial DESC, state_versions.created_at DESC
;`

type FindStateVersionLatestByWorkspaceIDRow struct {
	StateVersionID      *string               `json:"state_version_id"`
	CreatedAt           pgtype.Timestamptz    `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz    `json:"updated_at"`
	Serial              *int32                `json:"serial"`
	VcsCommitSha        *string               `json:"vcs_commit_sha"`
	VcsCommitUrl        *string               `json:"vcs_commit_url"`
	State               pgtype.Bytea          `json:"state"`
	WorkspaceID         *string               `json:"workspace_id"`
	Workspace           Workspaces            `json:"workspace"`
	StateVersionOutputs []StateVersionOutputs `json:"state_version_outputs"`
}

// FindStateVersionLatestByWorkspaceID implements Querier.FindStateVersionLatestByWorkspaceID.
func (q *DBQuerier) FindStateVersionLatestByWorkspaceID(ctx context.Context, workspaceID string) (FindStateVersionLatestByWorkspaceIDRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindStateVersionLatestByWorkspaceID")
	row := q.conn.QueryRow(ctx, findStateVersionLatestByWorkspaceIDSQL, workspaceID)
	var item FindStateVersionLatestByWorkspaceIDRow
	workspaceRow := q.types.newWorkspaces()
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.UpdatedAt, &item.Serial, &item.VcsCommitSha, &item.VcsCommitUrl, &item.State, &item.WorkspaceID, workspaceRow, stateVersionOutputsArray); err != nil {
		return item, fmt.Errorf("query FindStateVersionLatestByWorkspaceID: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindStateVersionLatestByWorkspaceID row: %w", err)
	}
	if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
		return item, fmt.Errorf("assign FindStateVersionLatestByWorkspaceID row: %w", err)
	}
	return item, nil
}

// FindStateVersionLatestByWorkspaceIDBatch implements Querier.FindStateVersionLatestByWorkspaceIDBatch.
func (q *DBQuerier) FindStateVersionLatestByWorkspaceIDBatch(batch genericBatch, workspaceID string) {
	batch.Queue(findStateVersionLatestByWorkspaceIDSQL, workspaceID)
}

// FindStateVersionLatestByWorkspaceIDScan implements Querier.FindStateVersionLatestByWorkspaceIDScan.
func (q *DBQuerier) FindStateVersionLatestByWorkspaceIDScan(results pgx.BatchResults) (FindStateVersionLatestByWorkspaceIDRow, error) {
	row := results.QueryRow()
	var item FindStateVersionLatestByWorkspaceIDRow
	workspaceRow := q.types.newWorkspaces()
	stateVersionOutputsArray := q.types.newStateVersionOutputsArray()
	if err := row.Scan(&item.StateVersionID, &item.CreatedAt, &item.UpdatedAt, &item.Serial, &item.VcsCommitSha, &item.VcsCommitUrl, &item.State, &item.WorkspaceID, workspaceRow, stateVersionOutputsArray); err != nil {
		return item, fmt.Errorf("scan FindStateVersionLatestByWorkspaceIDBatch row: %w", err)
	}
	if err := workspaceRow.AssignTo(&item.Workspace); err != nil {
		return item, fmt.Errorf("assign FindStateVersionLatestByWorkspaceID row: %w", err)
	}
	if err := stateVersionOutputsArray.AssignTo(&item.StateVersionOutputs); err != nil {
		return item, fmt.Errorf("assign FindStateVersionLatestByWorkspaceID row: %w", err)
	}
	return item, nil
}

const deleteStateVersionByIDSQL = `DELETE
FROM state_versions
WHERE state_version_id = $1
;`

// DeleteStateVersionByID implements Querier.DeleteStateVersionByID.
func (q *DBQuerier) DeleteStateVersionByID(ctx context.Context, stateVersionID string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "DeleteStateVersionByID")
	cmdTag, err := q.conn.Exec(ctx, deleteStateVersionByIDSQL, stateVersionID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query DeleteStateVersionByID: %w", err)
	}
	return cmdTag, err
}

// DeleteStateVersionByIDBatch implements Querier.DeleteStateVersionByIDBatch.
func (q *DBQuerier) DeleteStateVersionByIDBatch(batch genericBatch, stateVersionID string) {
	batch.Queue(deleteStateVersionByIDSQL, stateVersionID)
}

// DeleteStateVersionByIDScan implements Querier.DeleteStateVersionByIDScan.
func (q *DBQuerier) DeleteStateVersionByIDScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec DeleteStateVersionByIDBatch: %w", err)
	}
	return cmdTag, err
}
